# 민지

# 16장

# 16 국제화

## **16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원**

- HTTP 메시지는 어떤 언어로 된 콘텐츠든 이미지, 동영상 혹은 그 외 다른 종류의 미디어처럼 실어 나를 수 있다.
  - HTTP에서 엔터티 본문이란 그저 비트들로 가득 찬 상자에 불과
- 국제 콘텐츠를 지원하기 위해 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘서 클라이언트가 올바르게 문서를 이루고 있는 비트들을 문자들로 풀어내고 올바르게 처리해서 사용자에게 콘텐츠를 제공해줄 수 있도록 할 필요가 있다.
- 서버는 클라이언트에게 문서의 문자와 언어를 HTTP Content-Type charset 매개변수와 Content-Language 헤더를 통해 알려준다.
  - 이 헤더들은 엔터티 본문의 ‘비트들로 가득 찬 상자’에 무엇이 들어있는지, 어떻게 콘텐츠를 화면에 출력될 올바른 글자들로 바꾸는지, 그리고 그 텍스트가 어떤 언어에 해당하는지 서술한다.
- 클라이언트는 서버에게 자신이 어떤 차셋 인코딩 알고리즘들과 언어들을 이해하며 그중 무엇을 선호하는지 말해주기 위해 Accept-Charset 과 Accept-Language헤더를 보낸다.

## **16.2 문자집합과 HTTP**

### **16.2.1 Charset은 글자를 비트로 변환하는 인코딩이다.**

- HTTP charset 값은 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 말해준다.
  - 각 charset 태그는 비트들을 글자들로 변환하거나 혹은 그 반대의 일을 해주는 알고리즘을 명명한다.
- 다음 Content-Type 헤더는 수신자에게 콘텐츠가 HTML 파일임을 말해주고 charset 매개변수는 수신자에게 콘텐츠 비트들을 글자등로 디코딩하기 위해 iso-8859-6 아랍 문자집합 디코딩 기법을 사용하라고 말해준다.
  ```
  Content-Type: text/html; charset=iso-8859-6
  ```
  - iso-8859-6 인코딩 구조는 8비트 값을 숫자와 구두점 그리고 다른 기호들을 포함한 라틴 문자와 아랍 문자로 매핑한다.
- 몇몇 문자 인코딩은 글자 당 비트 수가 일정하지 않아 더 복잡한 가변길이 코드다.
  - 이러한 종류의 코딩은 중국어나 일본어와 같이 많은 글자로 이루어진 문자체계를 지원하기 위해 추가적인 비트를 사용할 수 있게 해준다.

### **16.2.2 문자집합과 인코딩은 어떻게 동작하는가**

- 비트들을 문자로 변환하는 것은 두 단계에 걸쳐 일어난다.

1. 문서를 이루는 비트들은 특정 코딩된 문자집합의 특정문자(각각 번호가 매겨져 있음)로 식별될 수 있는 문자 코드로 변환된다.
2. 문자 코드는 코딩된 문자집합의 특정 요소를 선택하기 위해 사용된다.

- 국제화된 문자 시스템의 핵심 목표는 표현(시각적인 표현방식)에서 의미(글자들)를 분리하는 것이다.
  - HTTP 는 문자 데이터 및 그와 관련된 언어와 차셋 라벨의 전송에만 관심을 갖는다.
  - 글자의 모양을 어떻게 표현할 것인가 하는 것은 사용자의 그래픽 디스플레이 소프트웨어(브라우저, 운영체제, 글꼴)가 결정한다.

### **16.2.3 잘못된 charset은 잘못된 글자들을 낳는다**

- 만약 클라이언트가 잘못된 charset 매개변수를 사용한다면 클라이언트는 이상한 깨진 글자를 보여주게 될 것이다.

### **16.2.4 표준화된 MIME 차셋 값**

- 특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME 차셋이라고 부른다.
- HTTP는 표준화된 MIME 차셋 태그를 `Content-Type`과 `Aceept-Charset헤더`에 사용한다.

### **16.2.5 Content-Type charset 헤더와 META 태그**

- 웹 서버는 `클라이언트에게 MIME 차셋 태그를 charset 매개변수와 함께 Content-Type 헤더에 담아보낸다`.
  - 만약 문자집합이 명시적으로 나열되지 않았다면 수신자는 콘텐츠로부터 문자집합을 추측하려 시도한다.
  - HTML 콘텐츠에서 문자 집합은 문자 집합을 서술하는 태그에서 찾을 수 있다.
- 아래는 어떻게 HTML META 태그가 문자집합을 일본어 인코딩 iso-2022-jp 로 설정하는지 보여준다. 만약 문서가 HTML 이 아니라면 혹은 META Content-Type 태그가 없다면 소프트웨어는 언어와 인코딩에 대한 일반적인 패턴을 찾기 위해 실제 텍스트를 스캐닝하여 문자 인코딩을 추측한다.

```
<head>
  <META HTTP-EQUIV=”Content-Type” CONTENT="text/html; charset=iso-2022-jp>
  <meta lang="jp" />
  <title>일본어 문서</title>
</head>
<body>
  ...
</body>
```

### **16.2.6 Aceept-Charset 헤더**

- HTTP 클라이언트는 서버에게 정확히 어떤 문자 체계를 그들이 지원하는지 `Accept-Charset 요청 헤더`를 통해 알려준다.
- Accept-Charset 헤더의 값은 `클라이언트가 지원하는 문자 인코딩 목록`을 제공한다.
- Accept-Charset 요청 헤더에 대응하는 `Content-Charset 응답 헤더는 존재하지 않는다는 것`에 주의
- 응답 문자집합은 MIME 과의 호환을 위해 Content-Type 응답 헤더의 charset 매개변수를 통해 서버로부터 돌려받는다.

## **16.3 다중언어 문자 인코딩에 관한 지침**

### **16.3.1 문자 집합 용어**

여덟 개의 전자 문자 체계 용어이다.

- 문자: 글쓰기의 최소 단위 ex) 알파벳,숫자
- 글리프: 하나의 글자를 표현하기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태
- 코딩된 문자: 우리가 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자.
- 코드 공간: 문자 코드 값으로 사용하려고 계획해 둔 정수의 범위
- 코드 너비: 각 문자 코드의 비트 개수
- 사용 가능 문자 집합: 글자들에 대한 특정한 작업 집합
- 코딩된 문자집합: 사용 가능 문자집합
- 문자 인코딩 구조: 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘

### **16.3.2 차셋은 형편없는 이름이다.**

- MIME 차셋 태그(Content-type) 는 문자집합을 의미하는 것이 결코 아니다
- MIME 차셋 값은 데이터 비트를 고유한 문자의 코드로 매핑하는 **알고리즘의 이름**이다.
- 문자 인코딩 구조와 코디왼 문자집합의 개념을 합친 것이다.

### **16.3.3 문자**

- 문자는 쓰기의 기본적인 구성요소다.
- 하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자, 수학 기호, 혹은 그 외에 다른 쓰기의 기본 단위를 표현한다.
- 다른 여러 가지 쓰기 형태를 가질 수 있다. ex) `영어의 필기체`

### **16.3.4 글리프, 연자 그리고 표현 형태**

- 문자는 유일하고 추상화된 언어의 요소
- **글리프**는 **각 글자를 그리는 특정한 방법**
- 각 문자는 미적인 양식과 스크립트에 따라 여러 글리프를 가진다.
- 일반적인 규칙은, **글리프** 하나를 다른 것으로 바꾸었을 때 텍스트의 의미가 바뀐다면 그 두 글리프들은 **서로 다른 글자**

### **16.3.5 코딩된 문자집합 표준**

- 코딩된 문자집합은 보통 코드 번호로 인덱싱된 글자에 대응시키는 배열로 구현된다.
  - `US-ASCII :모든 문자집합의 어머니`
    - 아스키는 '정보교환을 위한 미국 표준 코드'로 표준화된 **가장 유명한 코딩된 문자집합**
  - `iso-8859` : 국제적인 글쓰기를 위해 글자들을 하이 비트를 이용해서 추가한, `US-ASCII`의 8비트 확대집합들이다
    - 지역에 따라 커스터마이징된 문자집합 제공
    - ex) `iso-8859-1`: 영어,프랑스어
  - `JIS X 0201` : 아스키를 일본어 가타카나 반각문자를 더해 확장한 극단적으로 작은 문자집합이다
  - `JIS X 0208 과 JIS X 0212`
  - `UCS: 국제문자세트`
    - 전세계의 모든 글자를 하나의 코딩된 문자집합으로 통합하려고 노력하는 세계적인 표준이다

### **16.3.6 문자 인코딩 구조**

- 고정폭 - 각 코딩된 문자를 고정된 길이의 비트로 표현한다 ex) `iso-8859`
- 가변폭(비모달) - 다른 문자 코드번호에 다른 길이의 비트를 사용한다 ex) `Utf-8`
- 가변폭(모달) - 다른 모드로의 전환을 위한 특별한 'escape' 패턴을 사용한다

**인코딩 구조**

- `8비트` - 간단히 각 문자 코드를 그에 대응하는 8비트 값으로 인코딩한다
- `UTF-8` 인키있는 UCS를 위해 설계된 문자 인코딩 구조다. 문자코드의 값을 위해 비모달 가변길이 인코딩을 사용한다
- `iso-2022-jp` - 일본어 인터넷 문서를 위해 널리 사용되는 인코딩, escape 패턴 사용
- `euc-jp` - 일본어 인코딩이며, 'Extended Unix Code'의 약자로, 유닉스 운영체제에서 아시아 문자들을 지원하기 위해 처음 개발되었다.
- `euc-kr` - 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩으로, KS X 1003 과 KS X 1001 의 두 가지 문자 집합을 지원한다

## **17.내용 협상과 트랜스코딩**

### **17.1 내용 협상 기법**

- 서버에 있는 페이지들 중 어떤 것이 클라이언트에게 맞는지 판단하는 방법
  1. 클라이언트 주도 협상
  2. 서버 주도 협상
  3. 투명한 협상

### **17.2 클라이언트 주도 협상**

- 서버가 클라이언트의 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어 클라이언트가 보고 싶은 것을 선택하게 하는 것이다.
- 두 번의 요청 (클라이언트가 목록을 얻음, 원하는 페이지를 얻어오기 위한 요청)

> 서버는 클라이언트에게 선택지를 주는 방법
>
> - 여러가지 버전에 대한 링크와 설명이 담긴 HTML 페이지를 돌려준다.
> - `300`응답코드와 함께 HTTP/1.1응답을 돌려준다.

- 여러 개의 URL 을 요구한다는 단점(각 조건별 페이지가 존재) ex) `www.hardware.com , www.hardware.com/english, www.hardware.com/french`

### **17.3 서버 주도 협상**

- 앞에서 봤던 클라이언트 주도 협상은 서버와 클라이언트 사이에서 커뮤니케이션 많이 필요하다는 단점
- **서버에서 어떤 페이지를 보여줄 것인지 결정**
  - 클라이언트가 자신이 선호하는 페이지에 대한 정보를 요청 헤더에 담아서 보내야함
  - `Accept` 관련 헤더, `User-Agent` 헤더

**17.3.1 내용 협상 헤더**

- `Accept` : 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.
- `Accept-Language`: 서버가 어떤 언어로 보내도 되는지 알려준다.
- `Accept-Charset` : 서버가 어떤 차셋으로 보내도 되는지 알려준다.
- `Accept-Encoding` : 서버가 어떤 인코딩으로 보내도 되는지 알려준다.

**17.3.2 내용 협상 헤더의 품질값**

- HTTP 프로토콜은 클라이언트가 각 선호의 카테고리마다 여러 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 품질값을 정의하였다.
- q값은 0.0부터 1.0까지의 값을 가진다.(커질수록 높은 선호도) `Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0`

**17.3.3 그 외의 헤더들에 의해 결정**

- `User-Agent`와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들어내려고 시도할 수 있다.
- 캐시는 반드시 캐시된 문서의 올바른 최신버전을 제공해주려 하기 때문에 HTTP 프로토콜은 서버가 응답에 넣어 보낼 수 있는 `Vary` 헤더를 정의한다.

**17.3.4 아파치의 내용 협상**

- 웹 사이트 디렉터리에서, 배리언트(variant)를 갖는 웹 사이트의 각 URI를 위한 type-map파일을 만든다.
- 그 type-map파일은 모든 배리언트와 그들 각각에 대응하는 내용 협상 헤더들을 나열한다.
- 아파치가 그 디렉터리에 대해 자동으로 type-map 파일을 생성하도록 하는 MultiViews 지시어를 켠다.

### **17.4 투명 협상**

- `투명협상`: 클라이언트 입장에서 `협상하는 중개자 프락시를 둠으로써 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거`한다
- 프락시는 클라이언트의 기대가 무엇인지 알고 있고 클라이언트의 입장에서 협상을 수행할 수 있는 능력이 있는 것으로 가정됨(프락시는 콘텐츠에 대한 요청을 보고 클라이언트의 요구사항을 파악하고 있다)
- 투명한 내용 협상을 지원하기 위해 서버는 클라이언트의 요청에 가장 잘 맞는 것이 무엇인지 판별하려면 어떤 요청 헤더를 검사해야 하는지 프락시에게 반드시 말해줄 수 있어야 한다
- HTTP/1.1 명세는 투명 협상에 대한 어떤 메커니즘도 정의하지 않았지만, 대신 `Vary 헤더`를 정의했다
  - 서버는 응답에 `Vary 헤더`를 포함시켜 보냄으로써 중개자에게 `내용 협상을 위해 어떤 헤더를 사용하고 있는지 알려줄 수 있다`
- 캐시 프락시는 단일한 URL을 통해 접근할 수 있는 문서의 여러 다른 사본을 저장할 수 있다
  - 만약 서버가 그들의 캐시에 대한 의사결정 프로세스를 캐시에게 알려주었다면 캐시는 서버의 입장에서 클라이언트와 협상할 수 있다
  - 캐시는 또한 콘텐츠를 트랜스코딩하기에 훌륭한 장소인데 캐시안에 설치되어 있는 범용 트랜스코더는 특정 서버에 국한되지 않고 어떤 서버의 콘텐츠든 트랜스코딩할 수 있기 때문

### **17.4.1 캐시와 얼터네이트(alternate)**

- 콘텐츠를 캐시하는 것은 그 콘텐츠가 나중에 재사용될 것이라고 예상하기 때문
- 캐시는 클라이언트에게 올바른 캐시된 응답을 돌려주기 위해 서버가 응답을 돌려줄 때 사용했던 의사결정 로직의 상당 부분을 그대로 사용해야 한다.
- 캐시는 첫번째 요청을 서버로 그대로 전달하고 응답을 저장한다
- 두번째 응답은 캐시가 URL에 대응하는 문서을 찾아서 돌려준 것이다.
  - 그러나 이 문서는 프랑스어로 되어 있고 요청자는 스페인어 문서르 원한다
  - 만약 캐시가 프랑스어 문서를 그대로 요청자에게 돌려보낸다면 이것은 잘못된 동작이 될 것이다
- 그러므로 `캐시는 반드시 두번째 응답도 서버에게 그대로 전달하고 그 URL에 대한 이번의 응답과 지난번의 응답을 모두 저장해야 한다`
- 서버와 마찬가지로 캐시는 이제 같은 URL에 대해 두개의 문서를 갖게 된다
- 이 다른 버전은 `배리언트(variant)` 나 `얼터네이트(alternate)`로 불린다
- 따라서, `내용 협상`은 `배리언트 중에서 클라이언트 요청에 가장 잘 맞는 것을 선택하는 과정`으로 이해될 수 있다

### **17.4.2 Vary 헤더**

- HTTP `Vary 응답 헤더`는 `서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두(일반적인 내용 협상 헤더 외에 추가로 더해서)를 나열`한다
  - 예를 들어 제공된 문서가 `User-Agent헤더에 의존한다면 Vary 헤더는 반드시 “User-Agent”를 포함`해야 한다
- 새 요청이 도착했을 때 캐시는 `내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾는다`
  - 그러나 캐시가 문서를 클라이언트에게 제공해줄 수 있게 되기 전에 `캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary헤더가 들어있는지 확인`해야 한다
  - 만약 존재한다면 그 Vary 헤더가 명시하고 있는 헤더들은 새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야만 한다. 왜냐하면 서버는 클라이언트의 요청 헤더에 따라 그들의 응답이 달라질 수 있기 때문에 `투명 협상을 구현하기 위해 캐시는 반드시 캐시된 배리언트와 함게 클라이언트 요청 헤더와 그에 알맞은 서버 응답 헤더 양쪽 모두를 저장`해야 한다
- 만약 서버의 Vary 헤더가 이렇다면, 거대한 수의 다른 User-Agent 와 Cookie 값이 많은 배리언트를 만들어낼 것이다
  ```
  Vary: User - Agent, Cookie;
  ```
- `캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 한다`
  - 캐시가 검색을 할 때 먼저 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고 다음에 요청의 배리언트를 캐시된 배리언트와 맞춰본다. `만약 맞는 것이 없으면 캐시는 문서를 서버에서 가져온다`

### **17.5 트랜스 코딩**

- 지금까지 클라이언트와 서버가 협상을 통해 어떤 URL이 가리키는 문서들 중에서 클라이언트의 요구에 가장 잘 맞는 것 하나를 선택해 보내줄 수 있는 메커니즘에 대해 이야기했다. 이 메커니즘은 클라이언트의 요구에 맞는 문서가 존재해야 동작한다.
- 그러나 `서버가 클라이언트의 요구에 맞는 문서를 아예 갖고 있지 않다면 어떻게 되는가?`
  - 서버는 에러로 응답해야겠지만 이론적으로 `서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수도 있다`
  - 이 옵션을 `트랜스코딩` 이라고 부른다
- 트랜스코딩에는 `포맷변환`, `정보 합성`, `내용 주입`의 세 종류가 있다

### **17.5.1 포맷 변환**

- `포맷변환`: 데이터를 클라이언트가 볼 수 있도록 `한 포맷에서 다른 포맷으로 변환`하는 것이다
- 오래된 모바일 단말기가 데스크톱 클라이언트에서 보기 위해 만들어진 문서에 접근하려고 한다면 HTML을 WML로 변환해줄 필요가 있을 것이다
- 접속속도가 느리고 고해상도 이미지에 별로 관심이 없는 클라이언트에서 이미지가 많은 페이지를 쉽게 볼 수 있게 해주려면 이미지들을 칼라에서 흑백으로 변환하고 축소하여 크기와 해상도를 줄여주어야 할 것이다
- `포맷변환은 내용 협상 헤더에 의해 주도`된다

### **17.5.2 정보 합성**

- `문서에서 정보의 요점을 추출`하는 것을 `정보 합성`이라고 하는데 이는 트랜스코딩 과정에서 유용할 수 있다
- 예를 들어 각 절의 제목에 기반한 문서의 개요 생성이나 체이지에서 광고 및 로고 제거를 들 수 있다
- 본문의 키워드에 기반하여 페이지를 분류하는 기술은 문서의 핵심을 요약할 때도 역시 유용하다
  - 이 기술은 포털 사이트의 웹페이지 디렉터리와 같은 자동화된 웹페이지 분류 시스템에 의해 종종 사용된다

### **17.5.3 콘텐츠 주입**

- 지금까지 서술한 두 종류의 트랜스코딩은 일반적으로 웹 문서의 양을 줄이지만 `오히려 양을 늘리는 또 다른 종류의 변환인 내용 주입 트랜스코딩`이라는 것도 있다
- 내용 주입 트랜스코딩의 예로 자동 광고 생성과 사용자 추적 시스템이 잇다
- 지나가는 모든 HTML 페이지에 자동으로 광고를 삽입하는 광고 삽입 트랜스코더를 상상해보자
  - 현재 관련이 있거나 어떻게든 특정 사용자를 대상으로 하는 광고를 그때그때 효과적으로 삽입하기 위해 동적으로 이루어진다
- 사용자 추적 시스템 또한 어떻게 페이지가 보여지고 클라이언트가 웹을 돌아다니는지에 대한 통계를 수집하기 위해 페이지에 동적으로 콘텐츠를 추가할 수 있도록 만들어져 있다

  ***

### **트랜스코딩 vs 정적으로 미리 생성해놓기**

- 트랜스코딩의 대안은 웹 서버에서 웹페이지의 여러가지 사본을 만드는 것이다
  - 예를 들어 하나는 HTMl로, 또 하나는 WML로…
  - 그러나 이것은 여러가지 이유로 그다지 현실적인 기법이 될 수 없다
  - 페이지에 대한 어떠한 작은 변화도 여러 페이지의 수정을 요구하게 되고 각 페이지의 모든 버전을 저장하기 위해 더 많은 공간이 필요하게 되며 또한 페이지들을 관리하고 그것들 중 올바른 것을 골라서 제공해주는 웹 서버를 프로그래밍하기 어려워진다
- 광고 삽입과 같은 몇몇 트랜스코딩은 정적인 방법으로는 수행될 수 없다
  - 어떤 광고가 삽입될 것인지는 페이지를 요청한 사용자에게 달려있기 때문이다
- 루트 페이지를 그때그때 필요할 때마다 변환하는 것은 정적으로 미리 생성해놓는 것보다 더 쉬운 해결책이다
  - 그러나 이는 콘텐츠 제공에 있어 대기시간 증가로 인한 비용을 초래할 수 있다
  - 그러나 이들 계산 중 몇몇은 제삼자에게 수행하게 하여 웹 서버의 부담을 덜 수 있다
  - 변환은 더 싼 프락시나 캐시에 있는 외부 에이전트에 의해 수행될 수 있다
