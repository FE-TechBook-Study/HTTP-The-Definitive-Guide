# 상현
# 16장 국제화

## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

클라이언트는 서버에게 다음 헤더를 보내서 사용 가능한 인코딩 알고리즘과 언어 정보를 전달:

- Accept-Chartset & Accept-Language

서버는 클라이언트에게 다음 헤더를 보내서 콘텐츠는 다음 언어임으로 전달:

- HTTP Content-Type charset 매개변수와 Content-Language

### 16.2 문자집합과 HTTP

### 16.2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다

HTTP 차셋 값은 엔티티 콘텐츠 비트들을 특정 문자 체계의 글자로 바꾼 방법을 표시
차셋 값은 IANA가 관리
에) `Content-Type: text/html; charset=iso-8859-6`: 글자를 디코딩하려면 `iso-8859-6` 아랍 문자집합 디코딩 기법 사용

### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가

엔티티의 비트들을 문자로 변환하는 것은 두 단계로 나뉨:

1. 문서를 이루는 비트들을 특정 문자로 식별될 수 있는 문자 코드로 변환
    1. 트워크에 흘려보내는 건 비트 스트림. 예: `1110 0001`
    2. 이건 8비트(=1바이트) 단위로 묶어서 숫자 값(문자 코드,  255)으로 읽음
        1. `1110 0001` → 2진수 → 225(10진수) = 0xE1(16진수)
2. 문자 코드를 인코딩하는 charset에 대조하여 어떤 언어로 해석을 할건지 선택
    1. ISO-8859-6에서 255는 “ARABIC LETTER FEH”를 의미

### 16.2.3 잘못된 차셋은 글자를 낳는다

서버가 클라이언트로 보내는 charset의 값이 다르면 완전히 다른 언어로 인식을 하고 해석

### 16.2.4 표준화된 MIME 차셋 값

개정된 문서인 [Character Set](https://www.iana.org/assignments/character-sets/character-sets.xhtml)에서 확인 가능

### 16.2.5 Content-Type charset 헤더와 META 태그

수신자(클라이언트)는 헤더에서 문자집합(charset)에 대한 내용이 명시되어 있지 않다면 HTML 콘텐츠에서 찾으려고 하며 `<META-HTTP-EQUIV=”Content-Type”>`에서 확인 가능

### 16.2.6 Accept-Charset 헤더

대부분의 클라이언트는 모든 종류의 문자 코딩과 매핑 시스템을 지원하지 않기에 서버에서 어떤 문자 체계를 지원하는지 Accept-Charset 요청 헤더를 통해 전달

해당 정보의 응답값은 Content-Type에 존재하는 것을 유의

## 16.3 다중언어 문자 인코딩에 대한 지침

### 16.3.1 문자집합 용어

여덟 개의 전자 문자 체계 용어

- 문자: 유니코드(Unicode)라는 국제 문자  세트 계획에 따라서 여러 언어의 여러 글자에게 알맞고 유일한 이름을 부여하기 위한 표준화된 이름 집합
- 글리프(glyph): 하나의 글자를 표현하기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태
- 코딩된 문자(coded character): 우리가 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자
- 코드 공간(coding space): 문자 코드값으로 사용하려고 계획에 둔 정수의 범위
- 코드 너비(code width): 각 문자 코드(고정된 크기의) 비트 개수
- 사용  가능 문자집합(character repertoire): 글자들에 대한 특정한 집합(세상에 존재하는 모든 글자의 부분집합)
- 코딩된 문자집합(coded character set): 사용 가능한 문자집합을 받아서 각 글자에 코드 공간의 코드를 할당해주는 코딩된 문자들의 집합(실제 글자들에 숫자로 된 문자 코드를 대응시킨 것)
- 문자 인코딩 구조: 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘

### 16.3.2 ‘차셋(charset)’은 형편없는 이름이다

MIME에 있는 charset은 문자 인코딩 구조 + 코딩된 문자집합 개념
RFC2616 에서 ‘character set’이라는 표준 용어가 있지만, ‘charset’이라는 비표준 용어도 RFC2277에서 인정

### 16.3.3 문자

하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자(중국어같은), 수학 기호, 혹은 그 외의 다른 쓰기의 기본 단위

문자는 글꼴이나 스타일에 독립적이고, 문자는 각 위치에 따라서 형태가 변하기도 함

### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 형태

글리프는 각 글자를 그리는 특정한 방법
연자란 쓰기를 보다 멋지게 보이도록 하기 위해 많은 필기체와 활자체가 인접한 글자들이 부드럽게 이어지게 해주는 것

만약 글리프가 달라도 같은 의미라면 같은 글자, 글리프가 달라져서 의미가 달라지면 다른 글자

![스크린샷 2025-08-22 오전 9.45.47.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fd4066982-b9c4-4163-8334-d50f444ce276%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.45.47.png/size/w=2000?exp=1756084718&sig=v17PmFkvbzk2MbhF7NmcBY4bDeqc0Ci6Or_FGc28RGQ&id=257438a5-b001-8062-8887-da84d71619b5&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

### 16.3.5 코딩된 문자집합(Coded Character Set)

코딩된 문자집함은 정수를 글자로 대응
보통 코드 번호로 인덱싱된 배열로 구현되고 원소들은 문자들

![스크린샷 2025-08-22 오전 9.57.02.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F310bb4df-42c4-41b6-99d6-bc6f512c0393%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.57.02.png/size/w=2000?exp=1756084745&sig=w5y5CL9IjkwfaeRkvtdqkNqhvplwR4W6LPE6P3F1crA&id=257438a5-b001-8040-9e0a-dae3e6d814b5&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- US-ASCII: 모든 문자집합의 어머니
    - 정보교환을 위한 미국 표준 코드롤 가장 유명한 코딩된 문자집합
- iso-8859
    - 국제적인 글쓰기를 위해 필요한 글자들을 하이 비트를 이용해서 추가한 US-ASCII의 8비트 확대집합
        - iso-8859-1: 서유럽어(영어, 프랑스어 등등)
        - iso-8859-2: 중앙 및 동유럽어(체코어, 폴란드어 등)
        - iso-8859-3: 남유럽어
        - iso-8859-4: 북유럽어
        - iso-8859-5: 키릴(불가리어, 러시아어, 세르비아어)
        - iso-8859-6: 아랍어
        - iso-8859-7: 그리스어
        - iso-8859-8: 히브리어
        - iso-8859-9: 터키어
        - iso-8859-10: 노르딕어
        - iso-8859-15: 새로운 유로 문자를 포함하기 위한 iso-8859-1의 변형
- JIS X 0201, JIS X 0212: 일본 문자집합
- UCS(Universal Character Set): 전세계의 모든 글자를 하나의 코딩된 문자집합으로 통합시켜려는 세계적인 표준어

### 16.3.3 문자 인코딩 구조

숫자로 된 문자 코드를 콘텐츠 비트들로 변환하고 다른 쪽에서는 그들을 다시 문자 코드로 환원
인코딩 구조는 다음 3가지로 분류:

- 고정폭: 각 코딩된 문자를 고정된 길이의 비트로 표현
- 가변폭(비모달): 다른 문자 코드 번호에 다른 길이의 비트를 사용.
- 가변폭(모달): 다른 모드로의 전환을 위해 특별한 ‘escape’패턴을 사용

인코딩 구조:

- 8비트, UTF-8, iso-2022-jp, euc-jp, euc-kr

## 16.4 언어 태그와 HTTP

### 16.4.1 Content-Language 헤더

엔티티가 어떤 언어 사용자를 대상으로 하고 있는지 서술
만약 여러 언어 사용자를 대상으로 하고 있다면 다음과 같이 설정 가능
`Content-Language: mi, en`

텍스트만이 아니라 오디오 클립, 동영상, 그리고 애플리케이션도 특정 언어 사용자를 대상으로 가능

### 16.4.2 Accept-Language 헤더

클라이언트가 원하는 언어를 요청할 때 Accept-Language에 담아서 요청 가능

### 16.4.3 언어 태그 종류

언어 태그는 RFC 3066에 표준화된 문법을 가지고 있다
언어 태그는 다음을 표현하기 위해 사용 가능

- 일반적인 언어의 종류
- 특정 국가의 언어
- 방언
- 지방서
- 그 외의, 다른 언어의 변형이 아닌 표준 언어
- 비표준 언어

### 16.4.4 서브태그

언어 태그는 하이픈(-)으로 분리된 하나 이상의 서브태그로 이루어짐

- 첫 번째 서브태그: 주 서브태그이자 값들의 표준화
- 두 번째 서브태그: 선택적이고 자시만의 이름 표준
- 세 번째 서브태그: 서브 태그에 등록X

![스크린샷 2025-08-22 오전 11.33.11.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fbbe28648-0d79-4986-8819-97c165683402%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.33.11.png/size/w=2000?exp=1756084759&sig=HQFLIjCnpdE595DSY3XyIogmooQUzvV8DnyfH-098Ek&id=257438a5-b001-8047-a7d8-cb0b69049bad&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

### 16.4.5 대소문자의 구분 및 표현

모든 태그는 대소문자 구분X. ‘en’과 ‘eN’은 같은 의미
그러나 관용적으로 언어는 소문자, 국가는 대문자로 사용

### 16.4.6 IANA 언어 태그 등록

언어 태그가 표준 국가와 언어 값의 조합이면 굳이 등록되지 않아도 됨. 아닌 것들이 등록될 필요

### 16.4.7 첫 번째 서브태그: 이름공간

첫 번째 서브태그는 보통 ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰

- 두 글자라면, ISO-636와 639-1 표준의 언어 코드
- 세 글자라면, 639-2 표준과 확정에 열거된 언어 코드
- 글자 ‘i’라면, 이 언어 태그는 IANA에 등록된 집단
- 글자 ‘x’라면, 이 언어 태그는 특정 개인이나 집단 전용의 비표준 확장 서브태그

### 16.4.8 두 번째 서브태그: 이름공간

ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가 코드

- 두 글자라면, ISO 3166에 정의된 국가/지역
- 3~8글자라면 IANA에 등록
- 한 글자라면 잘못된 것

### 16.4.9 나머지 번째 서브태그: 이름공간

8자 이하의 알파벳과 숫자 구성을 제외하고난 다른 규칙X

### 16.4.10 선호 언어 설정하기

웹 브라우저 프로필에서 선호 언어 설정 가능

## 16.5 국제화된 URI

### 16.5.1 국제적 가독성 vs 의미 있는 문자들

URI는 전 세계적으로 공유와 사용을 쉽게 하기 위해 제한된 공통 ASCII 문자집합 을 택했다. 
이로 인해 비영어권 사용자들이 쉽게 쓰거나 기억하기 어렵지만, URI 설계자들은 리소스 식별자의 가독성과 공유 보장성 을 더 중요시하여 제한된 ASCII 기반으로 URI를 정의했다

### 16.5.2 URI에서 사용될 수 있는 문자들

URI에서 사용할 수 있는 US-ASCII 문자들은 

- 예약된 문자들: 특별한 의미를 가지기에 일반적으로 사용 불가
- 예약되지 않는 문자들: 특별한 의미가 없기에 일반적으로 사용 가능
- 이스케이프 문자

### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

이스케이프는 예야된 문자나 다른 지원하지 않는 글자들(스페이스)을 안전하게 URI에 삽입하는 방법을 제공

이스케이프는 퍼센트 글자 하나와 뒤이은 16진수 글자 둘로 이루어진 세글자 문자열
예) 스페이스 → ‘%20’

URI를 사용하려면 언이스케이핑을 해야하고, 두 번 해서는 안 됨.
두 번 하게 된다면, 다른 상태로 해석 가능성되어 데이터 손실 가능

### 16.5.4 국제 문자들을 이스케이핑하기

이스케이프 값들은 US-ASCII(0-127) 코드의 범위에 꼭 존재
따라서 확장 문자들(128-255)에 주의 필요

### 16.5.5 URI에서 모달 전환

URI 이식성이 중요했기에 언어 유연성은 낮았고 그 결과 URI는 국제화에 친화적X.
URI 국제화하려는 노력은 현재 진행중

## 16.6 기타 고려사항

### 16.6.1 헤더와 명세에 맞지 않는 데이터

HTTP 헤더는 반드시 US-ASCII 문자집합으로 이루어짐. 
그러나 모든 것이 올바르게 구현되지 않았기에, 라이브러리 및 운영체제의 명세나 문서 확인 필요

### 16.6.2 날짜

HTTP는 올바른 GMT 날짜 형식을 요구하지만 모두가 규칙을 따르지 않음
명세에 맞지 않는 날짜도 받아들이고 충돌을 일으키지 않게 설계해야 하지만 파싱이 불가능 한것이 있다면 보수적으로 해동

### 16.6.3 도메인 이름

RFC 3492에 정의되어 있는 퓨니코드(유니코드 문자열을 호스트 명에서도 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법)를 활용하여 사용자가 입력한 다국어로 된 도메임 이름을 알파벳과 숫자 등으로 된 도메인 이름으로 변경

# 17장 내용 협상과 트랜스코딩

## 17.1 내용 협상 기법

클라이언트 주도: 클라이언트가 선택지에서 선택

서버 주도: 서버사 자동으로 판단

투명: 중개자가 선택

## 17.2 클라리언트 주소 협상

서버는 클라이언트에게 페이지 목록을 보여주고 클라이언트가 선택하는 방법
서버 입장에서 구현하기 쉽지만 두 번의 요청이 가야하는 느린 상황(첫 번째는 목록, 두 번째는 선택한 사본)
또한, 각 다른 페이지에 따른 파생 URL 필요(예: [xxxx.com/english](http://xxxx.com/english) 와 [xxxx.com/french](http://xxxx.com/french))

서버는 클라이언트에게 선택지를 표현하는 방법이 두 개가 있는데:

1. 여러 가지 버전에 대한 링크와 각각 설명이 있는 HTML 반환
2. 300 Mutliple Choices 응답코드로 HTTP 1.1응답을 반환

## 17.3 서버 주도 협상

위 두 번의 통신의 단점을 극복하기 위해서 서버에서 선택해서 주는 방법인데 클라이언트가 요청 헤더에 값 삽입 필요
응답 계산 방법은 두 가지:

- 내용 협상 헤더 확인. Accept 관련 헤더
- 내용 협상 헤더 이외의 다른 헤더 확인

### 17.3.1 내용 협상 헤더

다음 헤더를 통해서 서버에 선호 정보를 요청

- Accept: 어떤 미디어 타입 허용
- Accept-Language: 어떤 언어 허용
- Accept-Charset: 어떤 차셋 허용
- Accept-Encoding: 어떤 인코딩 허용

### 17.3.2 내용 헙상 헤더의 품질값

선택 가능항 항목을 선호도와 함께 전달 가능
`Accept-Language: en;q=0.5, fr;9=0.0, nl;q=1.0`

### 17.3.3 그 외의 헤더들에 의해 결정

User-Agent와 같은 다른 요청 헤더들을 이용해 응답 생성 가능
서버는 헤더들에서 정보를 추합해서 응답을 하거나 아니면 갖고 있는 것을 그냥 제공

### 17.3.4 아파치의 내용 협상

아파치에서는 콘텐츠 제공자가 내용 협상을 설정

- type-map 파일
    - 활성화하기 위해 서버 설정 파일에 다음과 같이 설정: `AddHandler type-map .var` → .var확장자는 type-map임을 표시
    - 파일 내부는 아래와 같이 작성
        
        ```tsx
        URI: xxxx.html
        
        URI: xxx.en.html
        Content-Type: text/html
        Contetnt-Language: en
        
        URI: xxx.fr.de.html
        Content-type: text/html;charset=iso-8859-2
        Content-language: fr, de
        ```
        
- Multiviews 사용하기
    - access.conf 파일의 적절한 절(<Directory>, <Location>, 혹은 <Files>)에 Options 지시어를 이용해서 웹 사이트를 포함한 디렉터리에 MultiViews를 반드시 활성화

### 17.3.5 서버 측 확장

ASP와 같이 서버 쪽에서 확장하는 방법. 자세한 내용은 8장
(확인해보니 동적 웹 서버니까 WAS와 같은 느낌)

## 17.4 투명 협상

클라이언트 입장에서 협상하는 중개자 프락시를 활용하여 클라이언트와 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 서버 부하를 제거

HTTP 1.1에는 투명협상에 대한 내용을 없지만 서버는 응답에 Vary해더를 활용하여 중개자에게 내용 협상을 위해 어떤 헤더를 사용하고 있는지 전달

캐시 프락시는 단일 URL에 어려 다른 사본을 저장 가능하며 캐시에게 의사결정 프로세스를 전달했다면 캐시가 클라이언트와 협상이 가능
또한, 콘텐츠 트랜스코딩하기 훌륭한 장소

### 17.4.1 캐시와 얼터네이트(alternate)

![스크린샷 2025-08-25 오전 9.25.57.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fdf85e3b3-c7cd-4101-867f-ae31ee579c0a%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-25_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.25.57.png/size/w=2000?exp=1756084776&sig=3eNxhwhZvBwFwkxm0EennmKDgdUF6MVSnfJrIk0QmtQ&id=25a438a5-b001-80f9-8c79-c063b057c3e2&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

캐시는 처음보는 요청에는 서버로 전달 후 내용을 저장하고 같은 요청은 캐시에서 전달
같은 URL이지만 다른 언어로 요청이 된다면 서버에 요청하고 캐시에 저장. 이 때 다른 버전은 variant나 alternate로 호칭

### 17.4.2 Vary 헤더

다른 문서를 보내는 서버의 판단이 User-Agent나 Accept이외의 다른 헤더에 기초가 될 때, 서버는 응답이 특정 요청 헤더 값에 따라 달라질 수 있음을 Vary 헤더를 사용
캐시는 이후 동일한 URL 요청이 들어왔을 때, Vary에 명시된 헤더들의 값이 동일해야만 저장된 응답을 재사용. 다르면 서버로부터 새 응답을 전달

## 17.5 트랜스코딩

그러나 서버는 클라이언트 요청에 알맞는 문서를 가지고 있다고 보장 불가능.
서버는 에러로 응답할 수도 있지만 클라리언트가 사용할 수 있는 무언가로 변환할 수 있으면 이를 “트랜스코딩”

트랜스코딩에는 포맷 변환, 정보 합성, 내용 주입 세 종류 존재

### 17.5.1 포맷 변환

클라이언트가 볼 수 있도록 다른 포맷으로 변환하는 것
예를 들어 모바일 단말기기 데스크톱 용 문서에 접근한다면 HTML을 WML로 전환 필요

포맷 변환은 아래 Accept 헤더를 통해 결정

- Accept: 어떤 미디어 타입 허용
- Accept-Language: 어떤 언어 허용
- Accept-Charset: 어떤 차셋 허용
- Accept-Encoding: 어떤 인코딩 허용

### 17.5.2 정보 합성

문서에서 정보의 요점을 추출하는 것을 정보 합성(information synthesis)
예를 들어, 각 절의 제목에 기반한 문서의 개요 생성 페이지

이 기술은 포털 사이트의 웹페이지 디렉터리와 같은 자동화된 웹페이지 분류 시스템에 의해 종종 사용된다

### 17.5.3 콘텐츠 주입

앞선 두 개는 웹 문서의 양을 줄이지만, 오히려 양을 늘이는 내용 주입(content-injection transcoding)이라는 것도 존재

예를 들어, 자동 광고 생성과 사용자 추적 시스템
광고 삽입 트랜스코더들은 사용자의 정보를 받아서 동적으로 페이지에 삽입

### 17.5.4 트랜스코딩 vs. 정적으로 미리 생성해놓기

트랜스코딩의 대안으로는 웹 서버에서 페이지의 여러 사본을 만드는 것
그러나, 현실적인지 못 한 것이, 작은 변경에도 모든 사본을 업데이트가 필요하며 저장공간 필요

반대로 트랜스코딩을 한 다는 것은 작업 절차가 늘어나기에 대기시간 증가로 이어질 수 있음. 이를 웹 서버가 아닌 비용이 저렴한 프락시나 캐시의 외부 에이전트에 의해 수행

![스크린샷 2025-08-25 오전 9.53.06.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F32c1da86-6e06-4cad-9562-776ea2898ced%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-25_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.53.06.png/size/w=2000?exp=1756084798&sig=4OQmcq-P16Q7ESTTvBY48Mh8BYUsF1E3Wh8zuqW-2aE&id=25a438a5-b001-8065-8727-d9ce3ab8125b&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

## 17.6 다음 단계

내용 협상에 대한 이야기는 다음 두 가지 이유로 Accept나 Content관련 헤더들에서 끝나지 않음

- HTTP의 내용 협상은 성능 제약을 초래. 유추하거나 탐색하는 과정이 비용이 클 수 있기에 간소화에 대한 방법이 갈구. 이를 RFC 2295와 2296에 존재
- HTTP는 내용 협상이 필요한 유일한 프로토콜이 아님. 다른 프로토콜 또한 클라이언트 요청에 맞는 응답을 주기 위해 비슷한 협상 문제가 있음
