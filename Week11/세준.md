# 16장 국제화

웹은 전 세계 사용자가 다양한 언어와 문자 체계를 사용한다. HTTP는 이런 국제적 요구를 충족하기 위해 **문자 인코딩, 언어 태그, 국제화 URI** 등 여러 메커니즘을 지원한다.

---

## 16.1 국제화에 필요한 HTTP 지원

- 서버 → 클라이언트: 콘텐츠의 문자 인코딩과 언어 정보 제공
  - `Content-Type: …; charset=UTF-8`
  - `Content-Language: en, fr`
- 클라이언트 → 서버: 지원 가능한 문자/언어 목록 전달
  - `Accept-Charset: utf-8, iso-8859-1`
  - `Accept-Language: fr, en;q=0.8`

💡 `q` 값은 **선호도(quality factor)**. 1.0이 기본, 값이 낮을수록 우선순위가 떨어짐.

---

## 16.2 문자집합과 HTTP

### 16.2.1 Charset = 비트 ↔ 글자 매핑 알고리즘

- `charset` 매개변수는 콘텐츠를 **어떤 인코딩으로 디코딩해야 하는지** 알려줌
- 예:

  ```
  Content-Type: text/html; charset=iso-8859-6

  ```

### 16.2.2 변환 과정

- 콘텐츠 비트 → **코드 값** → **문자(추상적 의미)** → **글리프(시각적 표현)**
- HTTP는 “문자 데이터와 인코딩 라벨 전달”까지만 신경 쓰고, 실제 **글꼴 렌더링**은 클라이언트 책임

### 16.2.3 잘못된 charset = 깨짐

- 클라이언트가 다른 인코딩으로 해석하면 글자가 깨짐

### 16.2.4 표준화된 MIME 차셋 값

- IANA가 MIME charset 태그 관리
- 예시:
  - `us-ascii`: 기본 ASCII
  - `iso-8859-1`: 서유럽 언어
  - `utf-8`: 전 세계 문자

### 16.2.5 Content-Type vs META

- 서버가 **HTTP 헤더**로 charset 전달
- HTML은 `<meta http-equiv="Content-Type">` 로도 가능
- 둘 다 없으면 브라우저가 **내용 추측(heuristic)** 시도

### 16.2.6 Accept-Charset

- 클라이언트가 지원하는 인코딩 목록 제공

  ```
  Accept-Charset: utf-8, iso-8859-1

  ```

---

## 16.3 다중언어 인코딩 지침

### 주요 용어

- **문자(character)**: 추상적 의미 단위
- **글리프(glyph)**: 문자의 시각적 표현
- **코딩된 문자집합(Coded Character Set)**: 문자 ↔ 코드 값 매핑 (예: ASCII)
- **문자 인코딩 구조**: 코드 값을 비트로 변환하는 방식

### 문자 인코딩 구조

- **고정폭** (예: 8비트 ASCII) → 단순하지만 공간 낭비
- **가변폭 비모달** (UTF-8) → 효율적, 널리 사용
- **가변폭 모달** (ISO-2022) → escape 시퀀스로 전환

💡 `charset`이라는 이름은 사실 “문자집합”이 아니라 **코딩된 문자집합 + 인코딩 구조**를 합친 개념을 지칭.

---

## 16.4 언어 태그와 HTTP

언어 태그: 문서가 **어떤 언어 사용자 대상인지** 지정

### Content-Language

- 엔터티가 사용자를 대상으로 하는 언어

  ```
  Content-Language: fr

  ```

### Accept-Language

- 클라이언트가 선호하는 언어 전달

  ```
  Accept-Language: es, en;q=0.8

  ```

### 언어 태그 표준

- 형식: `<언어>-<국가>-<기타>`
  - `en-US` (미국 영어)
  - `pt-BR` (브라질 포르투갈어)
  - `no-bok` (노르웨이어 방언)
- 대소문자 구분 없음 (언어는 소문자, 국가는 대문자)
- IANA가 등록 관리

---

## 16.5 국제화된 URI

### 문제

- URI는 **US-ASCII** 기반 설계 → 국제 사용자에게 불편

### 허용 문자

- **예약되지 않음**: [A-Za-z0-9-_.!~*'()]
- **예약됨**: ; / ? : @ & = + $ ,
- **이스케이프**: `%` + 16진수 두 자리

### 이스케이핑 예시

- 공백 → `%20`
- `?` → `%3F`
- `&` → `%26`
- `こんにちは` (일본어) → UTF-8 변환 후 퍼센트 인코딩

  ```
  %E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF

  ```

---

# 요약

- **HTTP 국제화 = 문자 인코딩 + 언어 태그 + 국제화 URI**
- 서버는 `Content-Type; charset`, `Content-Language`로 제공
- 클라이언트는 `Accept-Charset`, `Accept-Language`로 선호도 표시
- MIME charset은 **코딩된 문자집합 + 인코딩 구조**
- 언어 태그는 IANA 등록, 대소문자 구분 없음
- URI는 ASCII 기반이라, 국제 문자는 반드시 UTF-8 → 퍼센트 인코딩해야 함

결론적으로, HTTP 국제화는 **사용자 환경에 맞는 글자/언어/주소 표현을 정확히 교환**할 수 있도록 하는 규약이다.

# 17장 내용 협상과 트랜스코딩

**같은 URL**에 대해 **클라이언트/환경에 최적인 표현(representation)** 을 고르는 과정이 _내용 협상_

서버가 **가지고 있지 않은 최적본을 “즉석 변환”** 해 제공하는 게 _트랜스코딩이다._

---

## 1) 내용 협상 개요

### 1.1 왜 필요한가?

- 다국어/다국문자(한 URL, 다양한 언어판)
- 포맷/코덱 차이(HTML/JSON/AMP/모바일 경량판)
- 압축/인코딩(gzip, br)
- 클라이언트 능력(낮은 해상도, 구형 브라우저)

### 1.2 방식 3종 비교

| 방식 | 동작 | 장점 | 단점/리스크 |
| --- | --- | --- | --- |
| **클라이언트 주도** | 서버가 선택지(링크·목록)를 제시 → 사용자가 직접 선택 | 구현 가장 쉬움, 사용자가 _정확히_ 선택 | 왕복 증가(최소 2회 요청), 북마크/링크 일관성 문제 |
| **서버 주도** | 서버가 요청 헤더(주로 `Accept*`)를 해석해 자동 결정 | 빠름, 사용자 개입 없음, HTTP의 q값·`Vary`로 캐시 연동 가능 | 애매하면 추측 필요, 오판 가능 |
| **투명(프락시 주도)** | 프락시 캐시가 서버 대신 협상 | 원서버 부하 감소, 빠른 응답 | 표준 메커니즘이 제한적, 캐시 키 관리 어렵고 오류 시 잘못된 변형 제공 |

---

## 2) 서버 주도 협상

### 2.1 협상 입력값(요청 헤더)

- `Accept`: 미디어 타입 선호 (예: `text/html`, `application/json`)
- `Accept-Language`: 언어 선호 (예: `ko, en;q=0.8`)
- `Accept-Charset`: 문자 인코딩 (예: `utf-8`)
- `Accept-Encoding`: 전송 압축 (예: `gzip, br`)
- `User-Agent`, `Width/Save-Data` 같은 **환경 정보**도 힌트로 활용 가능(명세상 협상 헤더는 아니지만 실무에서 흔함)

### 2.2 q값(quality)로 선호 표현

```
Accept-Language: nl;q=1.0, en;q=0.5, fr;q=0.0
```

- 1.0이 최상, 0.0은 거부.
- 서버가 일치하는 변형(variant)을 점수화하여 최적을 고름.
- 없으면 **406 Not Acceptable** 또는 **추측/대체(트랜스코딩/기본값)**.

### 2.3 `Vary` 헤더 (캐시와의 약속)

응답에 `Vary`를 싣면, **캐시가 해당 요청 헤더값을 캐시 키에 포함**하여, 이후 각기 다른 선호에 **서로 다른 사본**을 돌려줄 수 있음.

- Vary: User-Agent, Cookie 는 변형 폭발(캐시 조각화) 유발. 정말 필요한 경우에만 최소화

```jsx
Vary: Accept, Accept - Language, Accept - Encoding;
```

### 2.4 선택 알고리즘(개요)

1. 후보 변형 수집(언어/포맷/인코딩별 파일 또는 동적 렌더링 가능본)
2. 각 변형에 대해 **매칭 점수** 계산
   - 미디어 타입 일치(+wildcard)
   - 언어 태그 일치(서브태그 포함, 예: `ko-KR` vs `ko`)
   - 차셋/인코딩 가능 여부
   - 서버 내부 가중치(품질) 반영 가능
3. 최고 점수 선택 → 응답 본문 + 정확한 **엔터티 헤더**(Content-\*) + `Vary` + (가능하면) **`Content-Location`**(선택된 변형의 고유 URL)

> Content-Location 을 넣어두면 캐시·링킹·디버깅이 쉬워진다.

---

## 3) 클라이언트 주도 협상

- 서버가 “선택 화면”을 보여 주고, 각 변형으로 연결(예: `/page.en`, `/page.ko`).
- 장점: **사용자가 오판을 바로잡을 수 있음**.
- 단점: 왕복 증가, 링크/북마크가 분산.

> 절충: 서버 주도 기본값 + 페이지 안에서 언어/포맷 스위처 제공.

---

## 4) 투명 협상(프락시/캐시 주도)

- 프락시가 원 서버 대신 협상 수행.
- 서버는 응답에 **`Vary`** 를 정확히 명시해 프락시가 **요청 헤더 기준으로 사본을 구분**하도록 도와야 함.

---

## 5) 아파치(HTTPD)에서의 내용 협상

### 5.1 Type-map 파일(명시 매핑)

- 설정:
  ```
  AddHandler type-map .var
  ```
- 예: `joes-hardware.var`
  ```
  URI: joes-hardware.html

  URI: joes-hardware.en.html
  Content-Type: text/html
  Content-Language: en

  URI: joes-hardware.fr.de.html
  Content-Type: text/html; charset=iso-8859-2
  Content-Language: fr, de
  ```
- 서버가 이 맵을 참고해 요청의 `Accept*` 와 매칭.

### 5.2 MultiViews(자동 매핑)

- 디렉터리 단위로:
  ```
  Options +MultiViews
  ```
- `joes-hardware` 요청 시 같은 디렉터리의 `joes-hardware.*` 후보를 스캔해 자동 협상.

---

## 6) 트랜스코딩(Transcoding)

서버가 **보유한 변형이 없을 때**, 기존 리소스를 **즉석 변환**해 “사용 가능한” 표현으로 바꿔 제공.

### 6.1 유형

- **포맷 변환**: HTML → WML, PNG → JPEG, 동영상 코덱/해상도 다운스케일
- **정보 합성(요약)**: 광고/로고 제거, 핵심 텍스트 추출
- **콘텐츠 주입**: 사용자 맞춤 배너/추적 스크립트 삽입 등

### 6.2 장단점

- 장점: **커버리지 확대**, 구형/약한 클라이언트에도 접근성 제공
- 단점/주의:
  - **정확성 저하**(품질 손실), 의미 왜곡 가능
  - **서명/무결성 헤더(예: Content-MD5)** 무효화
  - **캐시 적중률 하락**(요청별 결과 달라짐)
  - **지연 증가 & 서버 부하**
  - 법/정책(개인정보·추적) 이슈

### 6.3 vs. 다중 정적 사본

| 전략 | 장점 | 단점 |
| --- | --- | --- |
| **정적 다중 사본** | 빠름, 캐시 친화적, 품질 예측 가능 | 관리 폭증(모든 변화마다 N배 빌드/배포) |
| **트랜스코딩** | 사전 준비 적음, 유연 | CPU·지연 비용↑, 캐시 난도↑, 품질 불안정 |

---

## 7) 캐시와 협상: 정확한 동작 순서

1. 캐시가 요청 수신 → **캐시 키 구성 시 `Vary` 고려**
2. 적합한 변형이 캐시에 있나 확인
3. 없으면 원서버로 전달
4. 원서버 응답의 `Vary` 읽고 저장(요청 헤더 조합별로 **각 변형을 별도 캐시**)
5. 다음 요청부터 올바른 변형을 서빙

> 잘못된 예: 프랑스어 응답을 캐시에 저장하고 모든 언어 요청에 그대로 반환.
>
> 올바른 예: 언어마다 **별도 엔트리** 보관(또는 `Content-Location`/별도 URL).

---

## 8) 에러/상태 코드와 협상

- **300 Multiple Choices**: 선택지 제공(클라이언트 주도 유도)
- **406 Not Acceptable**: 협상 실패(요청의 `Accept*` 조건을 만족하는 표현 없음)
- **415 Unsupported Media Type**: 서버가 처리 불가한 본문 타입
- **304 Not Modified**: 조건부 요청/캐시 재검증 시 사용(협상이 일치하면 같은 ETag로 304)

---

## 10) 헤더 대응표

| 요청 헤더(선호)   | 응답 헤더(선택 결과)      | 비고              |
| ----------------- | ------------------------- | ----------------- |
| `Accept`          | `Content-Type`            | 미디어 타입 협상  |
| `Accept-Language` | `Content-Language`        | 언어 협상         |
| `Accept-Charset`  | `Content-Type; charset=…` | 문자 인코딩       |
| `Accept-Encoding` | `Content-Encoding`        | 전송 압축         |
| _(여러 개)_       | `Vary: …`                 | 캐시 키 구분 지시 |
