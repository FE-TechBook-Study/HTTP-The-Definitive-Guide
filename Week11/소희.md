# 16. 국제화

HTTP 애플리케이션은 여러 언어의 문자로 텍스트를 보여주고 요청하기 위해 문자집합 인코딩을 사용한다.

그리고 그것들은 사용자가 이해할 수 있는 언어만으로 콘텐츠를 서술하기 위해 언어 태그를 사요앟ㄴ다. 

- HTTP가 어떻게 여러 언어 문자들의 체계 및 표준과 상호작용하는지 설명한다.
- HTTP 프로그래머가 올바르게 업무를 수행하는데 도움이 될 수 있도록 전문용어, 기술, 표준의 간략한 개요를 제공한다.
- 언어를 위한 표준 명명 체계와, 어떻게 표준화된 언어 태그가 선택한 콘텐츠를 서술하는지에 대해 설명한다.
- 국제화된 URI의 규칙과 주의사항을 개괄적으로 서술한다.
- 날짜와 그 외 다른 국제화 이슈에 대해 간단히 논의한다.

# 1. 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

HTTP에서 엔터티 본문이란 그저 비트들로 가득 찬 상자에 불과하다.

국제 콘텐츠를 지원하기 위해, 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘서, 클라이언트가 올바르게 문서를 이루고 있는 비트들을 문자들로 풀어내고, 올바르게 처리해서 사용자에게 콘텐츠를 제공해줄 수 있도록 할 필요가 있다.

서버는 클라이언트에게 문서의 문자와 언어를 HTTP Content-Type charset 매개변수와 Content-Language 헤더를 통해 알려준다. 

클라이언트는 서버에게 자신이 어떤 차셋 인코딩 알고리즘들과 언어들을 이해하며 그중 무엇을 선호하는지 말해주기 위해 Accept-Charset 과 Accept-Language 헤더를 보낸다.

![image.png](attachment:a2889a59-bc08-4e7b-ab51-b3de00234e31:image.png)

# 2. 문자집합과 HTTP

## 2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다

HTTP 차셋 값은, 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 말해준다.

각 차셋 태그는 비트들을 글자들로 변환하거나 혹은 그 반대의 일을 해주는 알고리즘을 명명한다.

## 2.2 문자집합과 인코딩은 어떻게 동작하는가

우리는 문서를 이루는 비트들을 화면에 보여줄 수 있는 글자들로 변환하기를 원한다.

우리는 비트들을 문자로 변환하는 디코딩 알고리즘을 지칭하고 적용하는 표준화된 방법이 필요하다. 

비트들을 문자로 변환하는 것은 다음 두 단계에 걸쳐 일어난다.

1. 문서를 이루는 비트들은, 특정 코딩된 문자 집합의 특정 문자로 식별될수 있는 문자 코드로 변환된다. 이 예에서, 디코딩된 문자 코드는 225로 번호가 붙어있다.
2. 문자코드는 코딩된 문자집합의 특정 요소를 선택하기 위해 사용된다. iso-8859-6에서, 값 225는 ‘ARABIC LETTER FEH’에 해당한다. 

![image.png](attachment:33225e89-2f2a-4021-b63e-f3689968b35f:image.png)

국제화된 문자 시스템의 핵심 목표는 표현(시각적인 표현 방식)에서 의미(글자들)를 분리하는 것이다. 

HTTP는 문자 데이터 및 그와 관련된 언어와 차셋 라벨의 전송에만 관심을 갖는다. 글자의 모양을 어떻게 표현할 것인가 하는 것은 사용자의 그래픽 디스플레이 소프트웨어(브라우저, 운영체제, 글꼴)가 결정한다.

## 2.3 잘못된 차셋은 잘못된 글자들을 낳는다

클라이언트가 잘못된 charset 매개변수를 사용한다면, 클라이언트는 이상한 깨진 글자를 보여주게 될 것이다.

- 브라우저가 iso-8859-6 아랍 코드를 사용하면 아랍어로 보여질 것이고, iso-8859-7 그리스어를 사용한다면, 그리스어를 보여줄 것이다.

## 2.4 표준화된 MIME 차셋 값

특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME 차셋이라고 부른다.

HTTP는 표준화된 MIME 차셋 태그를 Content-Type과 Accept-Charset 헤더에 사용한다.

## 2.5 Content-Type charset 헤더와 META 태그

Content-Type: text/html; charset=iso-2022-jp

웹 서버는 클라이언트에게 MIME 차셋 태그를 charset 매개변수와 함께 Content-Type 헤더에 담아 보낸다.

## 2.6 Accept-Charset 헤더

HTTP 클라이언트는 서버에게 정확히 어떤 문자 체계를 그들이 지원하는지 Accept-Charset 요청 헤더를 통해 알려준다.

Accept-Charset 헤더의 값은 클라이언트가 지원하는 문자 인코딩의 목록을 제공한다.

Accept-Charset: iso-8859-1, utf-8

위 HTTP 요청 헤더는 클라이언트가 서유럽 iso-8859-1 문자 시스템을 UTF-8 가변길이 유니코드 호환 시스템만큼 잘 받아들일 수 있음을 말해준다. 이 문자 인코딩 구조 중 어떤 것으로 콘텐츠를 반환할지는 서버의 자유다.

# 4. 언어 태그와 HTTP

언어 태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열이다.

영어(en), 한국어(ko) 등 언어에 대한 언어 태그가 존재한다.

언어 태그는 미국 영어(en-US)등과 같이 지역에 따라 변형된 언어나 방언을 표현할 수 있다.

## 1. Content-Language 헤더

Content-Language 엔터티 헤더 필드는 엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술한다.

단순 텍스트 문서 뿐만 아니라, 오디오 클립, 동영상 그리고 애플리케이션도 특정 언어 사용자를 대상으로 할 수 있다. 

그러나 단지 여러 언어가 하나의 엔터티에 동시에 사용된다고 해서 반드시 여러 언어 사용자들을 대상으로 하고 있음을 의미하는 것은 아니다.

## 2. Accept-Language 헤더

클라이언트는 자신이 이해할 수 있는 콘텐츠를 요청하기 위해 Accept-Language와 Accept-Charset을 사용할 수 있다. 

# 5. 국제화된 URI

오늘날의 URI는 US-ASCII의 부분집합으로 구성되어 있다.

- URI는 기본적으로 ASCII만 직접 포함.
- 나머지는 퍼센트 인코딩(`%XX`) 처리.
- 수신 측에서 다시 디코딩해 원래 문자로 복원.


-----------------------
# 17. 내용 협상과 트랜스코딩

종종 하나의 URL이 여러 리소스에 대응할 필요가 있는 경우가 있다. 

콘텐츠를 여러 언어로 제공하려고 하는 웹사이트의 예를 들어보자.

사용자가 웹사이트를 요청했을 때, 서버는 어떤 버전을 제공해 주어야 하는가? 프랑스어? 영어?

HTTP는 클라이언트와 서버가 이러한 판단을 할 수 있도록 내용 협상(content-negotiation) 방법을 제공한다.

이 방법을 이용해서 하나의 URL이 여러 가지 리소스 중 적합한 것에 대응되도록 할 수 있다.

여기서 서로 다른 버전을 variant라고 부른다.

서버는 또한 특정 URL에 대해 어떤 콘텐츠가 클라이언트에게 보내주기 가장 적절한지에 대한 다른 판단도 할 수 있어야 한다.

트랜스코딩은 HTTP 클라이언트와 서버 사이의 내용 협상에 대한 응답에서 수행된다. 

# 1. 내용 협상 기법

서버에 있는 페이지들 중 어떤 것이 클라이언트에게 맞는지 판단하는 세 가지 방법

1. 클라이언트 주도 협상: 클라이언트에게 선택지를 줌
2. 서버 주도 협상: 서버가 자동으로 판단
3. 투명한 협상: 중개자에게 선택하도록 부탁하는 방법

![image.png](attachment:e0459621-0d86-4fa9-b73c-e84a47f311a9:image.png)

# 2. 클라이언트 주도 협상

서버가 클라이언트의 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어 클라이언트가 보고 싶은 것을 선택하게 하는 것.

각 페이지에 두 번의 요청이 필요하다는 단점이 있다.

한 번은 목록을 얻고 두 번째는 선택한 사본을 얻는 것이다.

기술적으로, 서버에게는 클라이언트에게 줄 선택지를 표현하는 두 가지 방법이 있다.

여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지를 돌려주거나, 300 Multiple Choices 응답 코드로 HTTP/1.1 응답을 돌려주는 것이다.

이 경우, 결정은 브라우저 사용자에 의해 수동으로 클라이언트 쪽에서 행해진다.

또한 여러 개의 URL(주 페이지 하나와 각 특정 조건별 페이지들)을 요구한다는 단점도 있다.

예를 들어 https://www.naver.com 에 대한 것이라면, 네이버 서버는 https://www.naver.com/english와 https://www.naver.com/korean에 대한 링크를 담은 페이지를 반환할 것이다.

# 3. 서버 주도 협상

클라이언트 주도 협상 대부분의 단점들은 요청에 대한 응답으로 돌려줄 최적의 페이지를 결정하기 위한 클라이언트와 서버 사이의 커뮤니케이션을 증가시킨다는 것이다.

이런 추가 커뮤니케이션을 줄이기 위한 한 가지 방법은 서버가 어떤 페이지를 돌려줄 것인지 결정하게 하는 것이다.

그러나 이렇게 하려면 클라이언트는 반드시 자신의 무엇을 선호하는지에 대한 충분한 정보를 서버에게 주어서 서버가 현명한 결정을 할 수 있게 해 주어야 한다. 

서버는 이 정보를 클라이언트의 요청 헤더에서 얻는다.

HTTP 서버가 클라이언트에게 보내줄 적절한 응답을 계산하기 위해 사용하는 메커니즘은 다음 두 가지다.

- 내용 협상 헤더들을 살펴본다. 서버는 클라이언트의 Accept 관련 헤더들을 들여다보고 그에 알맞은 응답 헤더를 준비한다.
- 내용 협상 헤더 외의 다른 헤더들을 살펴본다. 예를 들어, 서버는 클라이언트의 User-Agent 헤더에 기반하여 응답을 보내줄 수도 있다.

## 1. 내용 협상 헤더

클라이언트는 다음 HTTP 헤더들을 이용해 자신의 선호 정보를 보낼 수 있다.

- Accept: 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.
- Accept-Language: 서버가 어떤 언어로 보내도 되는지 알려준다.
- Accept-Charset: 서버가 어떤 차셋으로 보내도 되는지 알려준다.
- Accept-Encoding: 서버가 어떤 인코딩으로 보내도 되는지 알려준다.

엔터티 헤더는 선적 화물에 붙이는 라벨과 비슷하다. 그들은 메시지를 서버에서 클라이언트로 전송할 때 필요한 메시지 본문의 속성을 가리킨다.

내용 협상 헤더들은 클라이언트와 서버가 선호 정보를 서로 교환하고 문서들의 여러 버전 중 하나를 선택하는 것을 도와, 클라이언트의 선호에 가장 잘 맞는 문서를 제공해 주기 위한 목적으로 사용된다.

- HTTP에서도 서버가 **메시지 본문(=화물 내용물)**을 보낼 때, **엔터티 헤더(Entity Header)**를 함께 보냅니다.
    - 예: `Content-Type: text/html` → 안에 HTML 문서가 들어있음
    - 예: `Content-Length: 348` → 메시지 본문 크기는 348바이트
- 즉, 엔터티 헤더는 **“이 본문이 어떤 성격인지 알려주는 라벨”**입니다.
- HTTP에서도 비슷하게, 클라이언트(브라우저)가 **자신의 선호를 헤더로 서버에 전달**합니다.
    - 예: `Accept-Language: ko` → 한국어 버전 문서를 원함
    - 예: `Accept: application/json` → JSON 형식 선호
- 서버는 이 정보를 보고, 여러 버전 중 클라이언트에게 가장 잘 맞는 문서를 골라 줍니다.

![image.png](attachment:1d9da645-5010-40d5-ba2d-2e887a8cf62b:image.png)

HTTP는 상태가 없는 프로토콜이기 때문에(서버는 클라이언트가 이전 요청에서 보낸 선호 정보를 기억하지 않는다는 의미다.), 클라이언트는 자신의 선호 정보를 반드시 매 요청마다 보내야 한다.

HTTP는 클라이언트를 위해 선호에 대한 설명을 품짋값(q 값)을 이용해 전달할 수 있는 메커니즘을 제공한다.

## 3.2 내용 협상 헤더의 품질값

HTTP 프로토콜은 클라이언트가 각 선호의 카테고리마다 여러 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 품질값을 정의하였다.

![image.png](attachment:7a958bf7-6c09-4eb5-b15b-6400111a0d6e:image.png)

위의 헤더는 클라이언트가 네덜란드어(nl)로 된 문서를 받기를 원하나, 영어로 된 문서라도 받아들일 것임을 의미한다. 그러나 어떠한 경우에도 프랑스어나 터키어(fr, tr)버전을 원하지 않는다.

때때로 서버는 클라이언트의 선호에 대응하는 문서를 하나도 갖고 있지 않을 수 있다.

이 경우, 서버는 클라이언트의 선호에 맞추기 위해 문서를 고치거나 트랜스코딩할 수 있다. 

## 3.3 그 외의 헤더들에 의해 결정

서버는 또한 User-Agent 와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들어내려고 시도할 수 있다. 

예를 들어, 서버가 오래된 버전의 웹 브라우저는 자바스크립트를 지원하지 않는다는 것을 알고 있다면, 그들에게는 자바스크립트를포함하지 않은 페이지를 돌려줄 수도 있다.

서버는 정확한 대응을 찾아내거나 아니면 그냥 갖고 있는 것을 제공해주어야 한다.

캐시는 반드시 캐시된 문서의 올바른 ‘최선의’ 버전을 제공해주려 해야 하기 때문에, HTTP 프로토콜은 서버가 응답에 넣어 보낼 수 있는 Vary 헤더를 정의한다. 

Vary 헤더는 캐시에게(그리고 클라이언트나 그 외의 모든 다운스트림 프락시에게) 서버가 내줄 응답의 최선의 버전을 결정하기 위해 어떤 요청 헤더를 참고하고 있는지 말해준다. 

## 3.4 아파치의 내용 협상

만약 색인 페이지를 여러 가지 버전으로 제공해 주려고 한다면 우선 콘텐츠 제공자가 각각의 버전에 해당하는 파일들을 아파치 서버의 적절한 디렉터리에 모두 넣어주어야 한다. 

그런 뒤 다음 둘 중의 한 가지 방법으로 내용 헙상을 동작시킬 수 있다.

- 웹 사이트 디렉터리에서, variant를갖는 웹 사이트의 각 URI를 위한 type-map 파일을 만든다. 그 type-map 파일은 모든 배리언트와 그들 각각에 대응하는 내용 협상 헤더들을 나열한다.
- 아파치가 그 디렉터리에 대해 자동으로 type-map 파일을 생성하도록 하는 MultiViews 지시어를 켠다.

이 type-map 파일을 통해, 아파치 서버는 영어로 요청한 클라이언트에게는 영어 문서 파일을, 프랑스어로 요청한 클라이언트에게는 프랑스어 문서 파일을 보냄을 알 수 있다.

## 3.5 서버 측 확장

서버에서 내용 협상을 구현하는 또 다른 방법으로, 서버 쪽에서 확장 하는 방법이다. 

# 4. 투명 협상

클라이언트 입장에서 협상하는 중개자 프락시를 둠으로써 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거한다.

프락시는 클라이언트의 기대가 무엇인지 알고 있고, 클라이언트의 입장에서 협상을 수행할 수 있는 능력이 있는 것으로 가정된다. (프락시는 콘텐츠에 대한 요청을 보고 클라이언트의 요구사항을 파악하고 있다.)

서버는 클라이언트의 요청에 가장 잘 맞는 것이 무엇인지 판별하려면 어떤 요청 헤더를 검사해야 하는지 프락시에게 반드시 말해줄 수 있어야 한다.

서버는 응답에 Vary 헤더를 포함시켜 보냄으로써 중개자에게 내용 협상을 위해 어떤 헤더를 사용하고 있는지 알려줄 수 있다.

## 4.1 캐시와 얼터네이트(alternamte)

콘텐츠를 캐시하는 것은 그 콘텐츠가 나중에 재사용될 것이라고 예상하기 때문이다.

캐시는 클라이언트에게 올바로 캐시된 응답을 돌려주기 위해, 서버가 응답을 돌려줄 때 사용했던 의사결정 로직의 상당 부분을 그대로 사용해야 한다. 

## 4.2 Vary 헤더

![image.png](attachment:b5a6b144-eb7f-4339-81d6-9bd40d5058ea:image.png)

서버의 판단이 User-Agent와 같은 Accept 이외의 다른 헤더에 기초한 것이라면 무슨 일이 일어날까?

HTTP Vary 응답 헤더는 서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두를 나열한다. 

예를 들어, 제공된 문서가 User-Agent 헤더에 의존한다면, Vary 헤더는 반드시 “User-Agent”를 포함해야 한다.

새 요청이 도착했을 때, 캐시는 내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾는다.

그러나 캐시가 문서를 클라이언트에게 제공해 줄수 있게 되기전에, 캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary 헤더가 들어있는지 확인해야 한다.

Vary 헤더가 존재한다면, 그 헤더가명시하고 있는 헤더들은 새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야만 한다.

왜냐하면 서버는 클라이언트의 요청 헤더에 따라 그들의 응답이 달라질 수 있기 때문에, 투명 협상을 구현하기 위해 캐시는 반드시 캐시된 variant와 함께 클라이언트 요청 헤더와 그에 알맞은 서버 응답 헤더 양쪽 모두를 저장해야 한다. 

만약 서버의 Vary 헤더가 `Vary: User-Agent, Cookie` 라면, 거대한 수의 다른 User-Agent 와 Cookie 값이 많은 variant를 만들어 낼 것이다.

캐시는 각 배리언트마다 알맞은 문서 버전을 저장하여, 캐시가 검색 시 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고, 다음에 요청의 배리언트를 캐시된 배리언트와 맞춰본다. 

맞는 것이 없으면, 캐시는 문서를 서버에서 가져온다. 

![image.png](attachment:8ebb571e-62f6-41fa-b624-dcee4186a00c:image.png)

# 5. 트랜스코딩

지금까지 소개된 메커니즘은 클라이언트의 요구에 맞는 문서가 존재해야 동작한다.

그러나 서버가 클라이언트의 요구에 맞는 문서를 아예 갖고 있지 않다면 어떻게 되는가?

서버는 에러로 응답해야겠지만, 이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수도 있다. 이 옵션을 트랜스코딩이라고 부른다.

![image.png](attachment:a8576471-112d-4222-a2b7-13986911bee4:image.png)

트랜스코딩에는 포맷 변환, 정보 합성, 내용 주입의 세 종류가 있다.

## 5.1 포맷 변환

데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것이다.

내용 변환 혹은 트랜스코딩은 콘텐츠 인코딩이나 전송 인코딩과는 다르다.

전자가 콘텐츠를 특정 접근 장치에서 볼수 있도록 하기 위한 것임에 비해 후자 둘은 보통 콘텐츠의 더 효율적인 혹은 안전한 전송을 위한 것이다.

## 5.2 정보 합성

문서에서 정보의 요점을 추출하는 것.

예로, 각 절의 제목에 기반한 문서의 개요 생성이나 페이지에서 광고 및 로고 제거를 들 수 있다.

## 5.3 콘텐츠 주입

자동 광고 생성과 사용자 추적 시스템 등이 해당된다.

## 5.4 트랜스코딩 vs  정적으로 미리 생성해놓기

트랜스코딩의 대안은 웹 서버에서 웹 페이지의 여러 가지 사본을 만드는 것이다.

그러나 그다지 현실적인 기법이 못된다.

각 페이지의 모든 버전을 저장하기 위해 더 많은 공간이 필요하게 되며, 페이지들을 관리하고 그 중 올바른 것을 골라서 제공해주는 웹 서버를 프로그래밍하기 어려워진다.

광고 삽입과 같은 몇몇 트랜스코딩은 정적인 방법으로는 수행될 수 없다.

페이지 요청하는 사용자에게 광고 콘텐츠가 달려있기 때문이다.
