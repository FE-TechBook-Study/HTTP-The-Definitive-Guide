# 14장. 보안 HTTP

## 14.1 HTTP를 안전하게 만들기

- 웹은 안전한 방식의 HTTP를 필요로 한다.
- 보다 중요한 트랜잭션을 위해서는 HTTP는 디지털 암호화 기술을 결합해야 한다.
- 다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요하다.
  - 서버 인증: 클라이언트는 위조 서버가 아닌 진짜 서버와 이야기하고 있음을 알아야 함.
  - 클라이언트 인증: 서버는 진짜 사용자와 이야기하고 있음을 알아야 함.
  - 무결성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 함.
  - 암호화: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화해야 함.
  - 효율: 저렴한 클라이언트나 서버도 이용할 수 있도록 충분히 빠른 알고리즘
  - 편재성(Ubiquity): 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 함.
  - 관리상 확장성: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 함.
  - 적응성: 현재 알려진 최선의 보안 방법을 지원
  - 사회적 생존성: 사회의 문화적, 정치적 요구를 만족

### 14.1.1 HTTPS

- 가장 인기 잇음.
- 넷스케이스에서 개척하였으며 모든 주류 브라우저와 서버에서 지원
- HTTPS의 동작
  - HTTPS를 사용할 때 모든 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
  - HTTPS는 HTTP의 하부에 SSL(Secure Sockets layer) 혹은 그를 계승한 TLS(Transport Layer Security)를 이용한 보안 계층을 제공하으로써 동작한다.
  - 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에 웹 클라이언트와 서버가 프로토콜 처리 로직을 크게 변경할 필요는 없다.

## 14.2 디지털 암호학

- SSL과 HTTPS에서 이용되는 암호 인코딩 기법에 대한 배경 지식

### 14.2.1 비밀 코드의 기술과 가학

- 암호법은 단순히 메시지를 암호화하는 것뿐 아니라, 메시지의 변조를 방지하기 위해 사용
- 메시지나 트랜지션의 저자임을 증명하는 데도 사용될 수 있다.

### 14.2.2 암호(cipher)

- 암호법은 암호라 불리는 비밀 코드에 기반
- 암호란 메시지를 인코딩하는 어떤 특정 방법과 나중에 그 비밀 메시지를 디코딩하는 방법
- 인코딩되기 전의 원본 메시지는 텍스트 혹은 평문, 암호가 적용되어 코딩된 메시지는 암호문이라고 불린다.

### 14.2.4 암호 기계

- 암호는 사람이 직접 인코딩하고 디코딩하는 간단한 알고리즘으로 시작
- 기술이 진보하면서, 복잡한 암호로 빠르고 정확하게 인코딩/디코딩하는 기계륾 만들기 시작했다.

### 14.2.4 키가 있는 암호

- 코드 알고리즘과 기계가 노출될 수 있기 때문에 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다.
- 이러한 암호 매개변수를 키라고 부르며, 이 키 값 없이는 디코더가 동작하지 않는다.
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다.
- 오늘날 거의 대부분의 암호 알고리즘은 키를 사용

### 14.2.5 디지털 암호

디지털 계산의 도래로, 두 가지 주요한 발전이 있었다.

- 속도 및 기능에 대한 기계의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능
- 매우 큰 키를 지원하는 게 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다.

- 디지털 키는 그냥 숫자에 불과하며 인코딩과 디코딩 알고리즘에 대한 입력값이다.
- 코딩 알고리즘은 데이터 덩어리를 받아서 알고리즘과 키의 값에 근거하여 인코딩/디코딩하는 함수이다.

## 14.3 대칭키 암호법

- 많은 디지털 암호 알고리즘은 대칭키 암호라 불리는데, 그들이 인코딩할 때 사용하는 키가 디코딩 할 때와 같기 때문
- 대칭키 암호에서 발송자와 수신자 모두 통신을 위해 비밀키를 똑같이 공유할 필요가 있다.
- 발송자는 비밀 키를 메시지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용
- 수신자는 암호문을 받은 뒤 같은 비밀 키를 사용하여 평문을 디코딩하기 위해 사용
- 잘 알려진 대칭키 암호 알고리즘: DES, Triple-DES, RC2, RC4 등

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

열거 공격

- 무차별로 모든 키 값을 대입해보는 공격
- 가능한 키 값이 아주 많다면, 해커는 암호를 깨뜨릴 수 있는 값 하나를 찾기 위해 많은 시간을 들여야 할 것
- 가능한 키 값의 개수는 키가 몇 비트인지, 얼마나 많은 키가 유효한지에 달려있다. 대칭키 암호에서 보통 모든 키 값이 유효

키의 길이

- 평범한 대칭키 암호에서 40비트 키는 작고 중요하지 않은 업무에서 충분. 그러나 쉽게 깨질 가능성도 존재함.
- 128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주된다.
- 암호에 기반한 보안에 있어 키의 길이는 매우 중요하다.

### 14.3.2 공유키 발급하기

- 대칭키 암호의 단점: 발송자와 수신자 둘 다 공유키를 가져야 한다는 것

## 14.4 공개키 암호법

- 공개키 암호 방식은 두 개의 비대칭 키를 사용한다. 하나는 인코딩을 위해 다른 하나는 디코딩을 위한 것
- 인코딩은 공개되어 있다. 그래서 공개키 암호 방식
- 디코딩 키는 호스트만이 알고 있다.
- 모든 사람이 X에게 보내는 메시지를 같은 키로 인코딩은 가능, X를 제외한 누구도 그 메시지를 디코딩할 수 없다.
- 키의 분리는 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에 메시지를 디코딩하는 능력은 소유자에게만 부여한다.
- 공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.

### 14.4.1 RSA

공개키 비대칭 암호는 해커가 아래 내용을 알더라도, 비밀인 개인 키를 계산할 수 없다는 것을 확신

- 공개키(공개니까 누구나 알 수 있다)
- 가로채서 얻은 암호문의 일부(네트워크 스누핑)
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

이 모든 요구를 만족하는 가장 유명한 알고리즘은 MIT에서 발명되고 RSA 데이터 시큐리티에서 상용화된 RSA 알고리즘이다.

- 공개키, 평문의 일부, 인코딩하여 얻은 평문에 대한 암호문, RSA 구현의 소스코드까지 주어졌다 하더라도 디코딩을 위한 개인 키를 찾아내는 것은 매우매우 어렵

### 14.4.2 혼성 암호 체계와 세션 키

- 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.
- 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용, 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.

## 14.5 디지털 서명

- 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하는 데에 이용

### 14.5.1 서명은 암호 체크섬이다.

디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다. 두 가지 이점

- 서명은 메시지를 작성한 저자가 누구인지 알려준다. 저자의 극비 개인 키를 갖고 있기 때문에 오직 저자만이 이 체크섬을 계산할 수 있다.
- 서명은 메시지 위조를 방지한다. 악의적으로 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것

- 디지털 서명은 보통 비대칭 공개키에 의해 생성

## 14.6 디지털 인증서

디지털 인증서(certs)는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

### 14.6.1 인증서의 내부

디지털 인증서의 내부에는 '인증 기관'에 의해 디지털 서명된 정보의 집합이 담겨있다.

- 대상의 이름(사람, 서버, 조직 등)
- 유효 기간
- 인증서 발급자(누가 이 인증서를 보증하는가)
- 인증서 발급자의 디지털 서명
- 추가적으로, 대상의 공개키도 담고 있다.

### 14.6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저가 인증서를 받으면, 서명 기관을 검사한다.  
기관이 신뢰할만한 서명 기관이라면 브라우저는 그 공개키를 이미 알고 있을 것이고 서명을 검증할 수 있다.  
서명 기관이 모르는 곳이라면, 브라우저는 확신할 수 없으므로, 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다.

## 14.7 HTTPS의 세부사항

HTTPS는 HTTP에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것

### 14.7.1 HTTPS 개요

- HTTPS는 HTTP 메시지를 TCP로 보내기 전에 그것들을 암호화하는 보안 계층으로 보내서 이 보안 계층에 의해 전송된다.
- 오늘날, HTTPS 보안 계층은 SSL,TLS로 구현
- 이 모두를 의미하는 단어로 'SSL'을 관행적으로 사용

### 14.7.2 HTTPS 스킴

- HTTPS는 선택적으로, 웹서버에게 URL 스킴을 통해 알려준다.
- 일반적인 HTTP의 스킴 접두사: http
- HTTPS 프로톨에서 스킴 접두사: https

### 14.7.3 보안 전송 셋업

HTTPS에서의 전송 절차는 SSL 보안 계층 때문에 약간 복잡하다.

- 클라이언트는 먼저 웹 서버의 443포트로 연결
- TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화
- 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.
- 이 메시지는 TCP로 보내지기 전에 암호화된다.

### 14.7.4 SSL 핸드셰이크

클라이언트와 서버는 SSL 핸드셰이크로 다음과 같은 일을 한다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

### 14.7.5 서버 인증서

- 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
- 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그외의 정보를 보여주는 X.509 v3에서 파생된 인증서
- 사용자와 사용자의 클라이언트는 모든 게 믿을 만한 것인지 확인하기 위해 인증서를 검증할 수 있다.

### 14.7.6 사이트 인증서 검사

날짜 검사

- 인증서가 유효한지 확인하기 위해 인증서의 시작 및 종료일을 검사한다.

서명자 신뢰도 검사

- 모든 인증서는 서버를 보증하는 어떤 인증 기관(Certificate Authority, CA)에 의해 서명되어 있다.
- 브라우저는 신뢰할 만한 CA의 목록을 포함한 채로 배포된다. 브라우저는 인증서가 올바른 CA에서 받은건지 파악할 수 있다.

서명 검사

- 한번 서명 기관이 믿을만하다고 판단되면, 브라우저는 서명 기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.

사이트 신원 검사

- 서버가 누군가 다른 이의 인증서를 복사하거나 트래픽을 가로채는 것을 방지하기 위해 브라우저는 인증서의 도메인 이름이 서버의 도메인 이름과 비교하여 맞는지 검사한다.

### 14.7.7 가상 호스팅과 인증서

가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
