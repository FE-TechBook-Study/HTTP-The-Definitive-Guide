# 민지

# 14장

## **14.1 HTTP를 안전하게 만들기**

- 이전 장에서는 다이제스트 인증, 메시지 무결성을 제공하는 가벼운 방법에 대해 이야기했다. 보다 중요한 트랜잭션을 위해서는 `HTTP와 디지털 암호화 기술을 결합` 해야 한다.
  - 무결성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
  - 암호화: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
  - 효율: 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.

### **14.1.1 HTTPS**

- HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다. HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작한다.
- 이 보안 계층은 `안전 소켓 계층(Secure Sockets Layer, SSL)` 혹은 그를 계승한 `전송 계층 보안(Transport Layer Security, TLS)` 을 이용해서 구현된다. SSL과 TLS는 매우 비슷하다.
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다.

## **14.2 디지털 암호학**

- 대칭키: 인코딩과 디코딩에 **같은 키** 를 사용하는 알고리즘
- 비대칭키: 인코딩과 디코딩에 **디른 키** 를 사용하는 알고리즘
- 공개키 암호법: 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### **14.2.1 비밀 코드의 기술과 과학**

- 암호법(cryptography)은 메시지를 암호화하는 것뿐 아니라, 메시지의 변조를 방지하기 위해 사용할 수도 있다. 암호법은 암호라 불리는 비밀 코드에 기반한다.

### **14.2.2 암호(cipher)**

- 암호는 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.
- 인코딩 되기 전의 원본 메시지는 평문이라고 불린다.
- 암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불린다.

### **14.2.3 암호 기계**

- 간단한 암호는 쉽게 깨뜨리는 것이 가능하다.
- 기술이 진보하면서, 사람들은 보다 복잡한 암호로 인코딩하고 디코딩하는 기계를 만들기 시작했다.
- 단순히 글자를 회전하는 것이 아닌, 그 순서를 바꾸며 메시지를 자르고 토막냈다.

### **14.2.4 키가 있는 암호**

- 코드 알고리즘과 기계가 적(해커)에 손에 들어갈 수 있기 때문에, 누군가가 기계를 훔치더라도 올바른 **키 값** 이 없이는 디코더가 동작하지 않게 한다. 이러한 암호 매개변수를 키라고 부른다.
- 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작한다.

## **14.3 대칭키 암호법**

- 많은 디지털 암호 알고리즘은 대칭키 암호라 불리는데, 왜냐하면 그들이 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다(e = d).
- 대칭키 암호에서 발송자와 수신자 모두 통신을 위해 비밀 키 k를 똑같이 공유할 필요가 있다. 발송자는 공유된 비밀키로 암호화를 하고, 수신자는 암호문을 평문으로 복원할 때 비밀키를 사용한다.
- 잘 알려진 대칭키 암호 알고리즘으로는 DES, Triple-DES, RC2, RC4 등이 있다.

### **14.3.1 키 길이와 열거 공격(Enumeration Attack)**

- 비밀 키가 누설되면 안 된다는 것은 매우 중요하다. 대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다.

- 무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다. 아래 이미지는 DES 암호를 열거 공격으로 깨뜨리는데 시간이 얼마나 걸리는지를 보여주는 표이다.

| 공격 비용         | 40비트 키     | 56비트 키 | 64비트 키 | 80비트 키 | 128비트 키 |
| ----------------- | ------------- | --------- | --------- | --------- | ---------- |
| 100,000달러       | 2초           | 35시간    | 1년       | 7만년     | 10¹⁹년     |
| 1,000,000달러     | 200밀리초     | 3.5시간   | 37일      | 7,000년   | 10¹⁸년     |
| 10,000,000달러    | 20밀리초      | 21분      | 4일       | 700년     | 10¹⁷년     |
| 100,000,000달러   | 2밀리초       | 2분       | 9시간     | 70년      | 10¹⁶년     |
| 1,000,000,000달러 | 200마이크로초 | 13초      | 1시간     | 7년       | 10¹⁵년     |

### **14.3.2 공유키 발급하기**

- 대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.
- 대화 상대만큼이나 비밀 키가 필요하기 때문에 관리해야 하는 사람 입장에서 이것은 지옥이다.

## **14.4 공개키 암호법**

- 한쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는대신, 공개키 암호 방식은 `두개의 비대칭 키`를 사용
  - 하나는 호스트의 메시지를 `인코딩`하기 위한 것
  - 하나는 호스트의 메시지를 `디코딩`하기 위한 것
- 인코딩 키는 `모두를 위해 공개`되어 있다. (공개키 암호 방식이라는 이름이 붙은 이유)
  - 하지만 `호스트만이 개인 디코딩 키를 알고 있다`
- 노드 X는 자신의 인코딩 키 e^x 를 공개적으로 배포할 수 있다. 이제 메시지를 노드 X에게 사보내고자 하는 누구나 똑같고 잘 알려진 공개키를 사용할 수 있다
- 각 호스트마다 누구나 사용할 수 있는 인코딩 키가 할당되어 있기 떄문에, 공개키 암호 방식은 대칭 키의 쌍이 N^2 로 폭발적으로 증가하는 것을 피할 수 있다
- 모든 사람이 X에게 보내는 메시지를 같은 키로 인코딩 할 수 있지만, X를 제외한 누구도 그 메시지를 디코딩할 수 없다.
  - 오직 X만이 디코딩 개인 키 d^x를 갖고 있기 때문
- 키의 분리는 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여한다. 이는 노드가 서버로 안전하게 메시지를 발송하는 것을 더 쉽게 해주는데 왜냐하면 서버의 공개 키만 있으면 되기 때문이다.
- 공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다
- 표준화된 공개키 기술 묶음을 만드는 것의 중요성 때문에 거대한 공개 키 인프라(Public-Key Infrastructure, PKI) 표준화 작업이 25년 넘게 계속 진행 중인 상태

### **14.4.1 RSA**

- 공개키 비대칭 암호의 과제는 설혹 악당이 아래 내용을 알고 있다 해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이다
  - `공개키`(물론 공개니까 누구나 얻을 수 있다)
  - `가로채서 얻은 암호문의 일부`(네트워크를 스누핑해서 획득)
  - `메시지와 그것을 암호화한 암호문`(인코더에 임의의 텍스트를 넣고 실행해서 획득)
- 이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 MIT 에서 발명되고 이어서 RSA 데이터 시큐리티에서 상용화된 `RSA알고리즘`이다.
  - 공개키, 평문의 일부, 공개키로 평문을 인코딩하여 얻은 평문에 대한 암호문, 그리고 RSA구현의 소스 코드까지 주어졌다 하더라도 암호를 크래킹하여 해당하는 개인 키를 찾아내는 것은 컴퓨터 과학의 모든 분야에서 가장 어려운 문제 중 하나라고 알려진 큰 소수를 계산하는 문제만큼 어렵다고 한다.
  - 따라서 만약 큰 숫자를 소수들로 분해하는 빠른 방법을 찾아낸다면 스위스 은행 계좌를 뚫는 것뿐 아니라 튜링상도 받을 수 있다.

### **14.4.2 혼성 암호 체계와 세션 키**

- 비대칭 공개키 암호 방식은 `누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로` 훌륭하다.
- 두 노드가 안전하게 의사소통 하려고 할 때 개인 키에 대한 협상을 먼저 해야 할 필요가 없다.
- 그러나 공개키 암호 방식의 알고리즘은 `계산이 느린 경향`이 있다
- 실제로는 `대칭`과 `비대칭` 방식을 섞은 것이 쓰인다.
  - ex) 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.

## **14.5 디지털 서명**

### **14.5.1 서명은 암호 체크섬이다**

- 디지털 서명: 메시지에 붙어있는 특별한 암호 체크섬
- 이들은 두 가지 이점을 가진다.
  - 서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 서명처럼 동작한다
  - 서명은 메시지 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자느 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.
- 디지털 서명은 보통 비대칭 공개키에 의해 생성된다.
- 개인 키는 오직 소유자만이 알고 있기 때문에 저자의 개인 키는 일종의 ‘지문’처럼 사용된다.
- 노드 A는 가변 길이 메시지를 정제하여 고정된 길이의 요약(digest)으로 만든다.
- 노드 A는 그 요약에, 사용자의 개인 키를 매개변수로 하는 ‘서명’ 함수를 적용한다. 오직 그 사용자만이 개인 키를 알고 있기 때문에 올바른 서명 함수는 서명자가 소유자임을 보여준다. 우리가 서명 함수로 디코더 함수 D를 사용한 이유는 그 함수가 사용자의 개인 키에 관련되어 있기 때문이다.
- 한번 서명이 계산되면 노드A 는 그것을 메시지의 끝에 덧붙이고 메시지와 그에 대한 서명 둘 다를 노드 B에게 전송한다.
- 메시지를 받은 노드 B가 만약 그 메시지를 쓴 것이 정말로 노드 A이며 동시에 위조되지도 않았다는 것을 확인하길 원한다면 노드 B는 서명을 검사할 수 있다. 노드B는 개인 키로 알아보기 어렵게 변형된 서명에 공개키를 이용한 역함수를 적용한다. 만약 풀어낸 요약이 노드 B가 갖고 있는 버전의 요약과 일치하지 않는다면 메시지가 송신 중에 위조되었거나 아니면 발송자가 노드 A의 개인 키를 갖고 있지 않은 것이다.

## **14.6 디지털 인증서**

- 디지털 인증서: 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

### **14.6.1 인증서의 내부**

- 디지털 인증서에는 또한 공식적으로 ‘인증 기관’에 의해 디지털 서명된 정보의 집합이 담겨있다.
- 기본적인 디지털 인증서는 보통 다음과 같이 인쇄된 ID에도 흔히 들어가게 되는 기본적인 것들을 담고 있다.
  - `대상의 이름`(사람, 서버, 조직 등)
  - `유효 기간`
  - `인증서 발급자` (누가 이 인증서를 보증하는가)
  - `인증서 발급자의 디지털 서명`
- 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐 아니라 보통 대상의 공개키도 담고 있다.

## **14.7 HTTPS의 세부사항**

- HTTPS는 HTTP의 가장 유명한 보안 버전이다.
- HTTPS는 HTTP프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.

### **14.7.1 HTTPS 개요**

- HTTPS는 보안 전송 계층을 통해 전송되는 HTTP
- 암호화되지 않은 HTTP메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 HTTPS는 HTTP메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다.
- 오늘날 HTTPS의 보안 계층은, SSL 과 그것의 현대적 대체품인 TLS로 구현되었다.

**14.7.2 HTTPS 스킴**

- 오늘날 보안 HTTP는 선택적이다.
- 웹 서버로의 요청을 만들 때, 우리는 웹 서버에게 HTTP 의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다.
  - 이것은 URL의 스킴을 통해 이루어진다
- (웹브라우저 등의) 클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다.
  - 만약 URL이 http 스킴을 갖고 있다면 클라이언트는 서버에 80번(기본값)포트로 연결하고 평범한 HTTP 명령을 전송한다.
  - 만약 URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443번(기본값) 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 ‘핸드셰이크’를 하고 암호화된 HTTP 명령이 뒤를 잇는다.
- SSL 트래픽은 `바이너리 프로토콜`이기 때문에 HTTP와는 완전히 다르다, 그 트래픽은 다른 포트(SSL은 보통 443 포트를 통해 전달)로 전달된다.
  - 만약 SSL 과 HTTP 트래픽 모두가 80번 포트로 도착한다면 대부분의 웹브라우저는 바이너리 SSL 트래픽을 잘못된 HTTP 로 해석하고 커넥션을 닫을 것이다.
  - 보안 서비스가 HTTP쪽으로 좀 더 계층 통합이 되도록 하면 포트가 둘 이상 필요할 이유가 사라지겠지만 사실 이것이 그렇게 심각한 문제를 일으키지는 않는다.

### **14.7.3 보안 전송 셋업**

- 암호화되지 않은 HTTP에서 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고 요청 메시지를 보내고 응답 메시지를 받고 커넥션을 닫는다.
- HTTPS에서의 절차는 SSL 보안 계층 때문에 약간 더 복잡하다.
- HTTPS에서 클라이언트는 먼저 웹 서버의 443 포트로 연결한다.
- TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.
- 핸드셰이크가 완료되면 SSL 초기화는 완료되며 클라이언트는 요청메시지를 보안계층에 보낼 수 있다.

### **14.7.4 SSL 핸드셰이크**

- 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.
  - 프로토콜 버전 번호 교환
  - 양쪽이 알고 있는 암호 선택
  - 양쪽의 신원을 인증
  - 채널을 암호화하기 위한 임시 세션 키 생성
- 암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL 은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고받는다.

### **14.7.5 서버 인증서**

- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호인증을 지원한다.
- 그러나 오늘날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다.
- 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않다.
- 웹 서버는 클라이언트 인증서를 요구할 수 있지만 실제로는 좀처럼 일어나지 않는 일이다.
- 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
- 누군가가 웹 서버에 신용카드 정보를 보내는 것과 같은 보안 트랜잭션을 수행할 때, 그는 대화 중인 조직이 그와 대화하고 있다고 생각한 그 조직이 맞는지 알고 싶을 것이다. 잘 알려진 인증기관에 의해 서명된 서버 인증서는 그가 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.
- 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는 X.509 v3 에서 파생된 인증서이다.
- 사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을만한 것인지 확인하기 위해 인증서를 검증할 수 있다.

### **14.7.6 사이트 인증 검사**

- SSL자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만 최신 웹브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.
- 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹브라우저의 검사 기법의 기초를 구축했다.
- 알고리즘의 수행단계는 다음과 같다.

**날짜 검사**

- 브라우저는 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사한다. 만약 인증서가 만료되었거나 아직 활성화되지 않았다면 인증서 검사는 실패하고 브라우저는 에러를 보여준다.

**서명자 신뢰도 검사**

- 모든 인증서는 서버를 보증하는 어떤 인증 기관에 의해 서명되어 있다.
- 여러가지 수준의 인증서가 있는데 각각은 다른 수준의 배경 검증을 요구한다.
- Ex. 전자상거래 서버 인증서를 발급받고자 한다면 사업체로서의 법인에 대한 법적 증명을 제시해야 한다.

**서명 검사**

- 한번 서명 기관이 믿을만하다고 판단하면 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.

**사이트 신원 검사**

- 서버가 누군가 다른 이의 인증서를 복사하거나 그들의 트래픽을 가로채는 것을 방지하기 위해 대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.
- 서버 인증서에는 보통 단일 도메인 이름이 들어있지만 몇몇 CA는 서버 클러스터나 서버 팜을 위해 서버 이름의 목록이나 서버 이름들에 대한 와일드카드 표현이 들어있는 인증서를 만든다.

### **14.7.7 가상 호스팅과 인증서**

- 가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
- 몇몇 인기있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다.
- 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다.
