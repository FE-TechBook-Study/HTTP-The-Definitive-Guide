이 장에서는 디지털 암호화를 이용해 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 더 복잡하고 적극적인 기술을 제시한다.

# 1. HTTP를 안전하게 만들기

인증(기본 그리고 다이제스트 인증)과 메시지 무결성(요약 qop=”auth-int”)은 쓸만하지만, 대량 구매, 은행 업무, 혹은 보안 자료 접근을 위해서는 충분히 강력하지 않다.

보다 중요한 트랜잭션을 위해서는, HTTP와 디지털 암호화 기술을 결합해야 한다.

HTTP의 보안 버전은 효율적이고 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 한다.

사회와 정부의 요구사항에도 맞아야 한다.

이를 제공해 줄 수 있는 HTTP 보안 기술이 필요하다.

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성(Ubiquity) - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성  - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

## 1. HTTPS

HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다.

웹페이지에 HTTP가 아닌 HTTPS로 접근하고 있는 경우, URL이 http:// 대신 https://로 로 시작하는 것을 보고 그 사실을 알아챌 수 있다.

HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.

HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작한다.

![image.png](attachment:cde6d78f-a83f-43d8-ad78-6b27d5a25ff5:image.png)

어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요가 없다.

# 2. 디지털 암호학

- 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코등과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법: 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

## 2.1 비밀 코드의 기술과 과학

암호법은 수표에 손으로 쓴 서명이나 봉투의 양각된 왁스 봉인과 같이, 누군가가 정말로 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용될 수 있다.

## 2.2 암호 (cipher)

암호법은 암호라 불리는 비밀 코드에 기바난다.

암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.

인코딩되기 전의 원본 메시지는 흔히 톡스트 혹은 평문이라고 불린다.

암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불린다.

## 2.4 키가 있는 암호

디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 입력할 필요가 있다.

## 2.5 디지털 암호

디지털 계산의 도래로, 두 가지 주요한 발전이 있었다.

- 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
- 매우 큰 키를 지원하는 것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다.
- 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워진다.

# 3. 대칭키 암호법

인코딩할 때 사용하는 키와 디코딩할 때의 키가 같다.

## 3.1 키 길이와 열거 공격(Enumeration Attack)

비밀 키가 누설되면 안된다는 것은 매우 중요하다.

대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다.

무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다.

가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려있다.

대칭키 암호에서는, 보통 모든 키 값이 유효하다.

8비트 키라면 256가지 값이 가능하며, 40비트 키라면 약 1조가지가 가능하다.

128비트 키라면 어마무시하게..

평범한 대칭키 암호에서, 40비트 키는 작고 중요하지 않는 업무에는 충분하다. 그러나 초당 수십억 번의 계산이 가능한 오늘날의 빠른 워크스테이션에게는 쉽게 깨질 수 있다.

이에 반해 128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주된다.

암호에 기반한 보안에 있어 키의 길이란 이처럼 중요하다.

## 3.2 공유키 발급하기

대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.

만약 N개의 노드가 있고, 각 노드가 상대 N-1과 대화를 나누어야 한다면, 대략 총 N의 2제곱 개의 비밀 키가  필요하다. 관리해야하는 사람 입장에서는 지옥이다.

# 4. 공개키 암호법

한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.

하나는 호스트의 메시지를 인코딩하기 위한 것이며, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것이다.

인코딩 키는 모두를 위해 공개 되어 있다.

하지만 호스트만이 개인 디코딩 키를 알고 있다.

노드 X는 자신의 인코딩 키를 공개적으로 배포할 수 있다.

모든 사람이 X에게 보내는 메시지를 같은 키로 인코딩할 수 있지만, X를 제외한 누구도 그 메시지를 디코딩할 수 없다.

## 4.1 RSA

- 공개키
- 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 RS 알고리즘이다.

## 4.2 혼성 암호 체계와 세션 키

공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다.

실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.

예를 들어, 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.

# 5. 디지털 서명

암호는 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는 데에 이용될 수 있다.

## 5.1 서명은 암호 체크섬이다.

- 서명은 메시지를 작성한 저자가 누군지 알려준다.
    - 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오진 저자만이 이 체크섬을 계산할 수 있다.
    - 체크섬은 저자의 개인 서명처럼 동작한다.
- 서명은 메시지 위조를 방지한다.
    - 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더이상 그 메시지와 맞지 않게 될 것이다.
    - 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.

# 6. 디지털 인증서

## 6.1 인증서의 내부

디지털 인증서에는 공식적으로 ‘인증 기관’에 의해 디지털 서명된 정보의 집합이 담겨있다.

기본적으로 다음의 것들이 담겨져 있다.

- 대상의 이름(사람, 서버, 조직 등)
- 유효 기간
- 인증서 발급자(누가 이 인증서를 보증하는가)
- 인증서 발급자의 디지털 서명

## 6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.

만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.

서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저가 인증서를 받으면, 서명 기관을 검사한다.

만약 그 기관이 공공이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며(브라우저들은 여러 서명 가관의 인증서가 미리 설치된 채로 출하된다), 브라우저는 그 서명을 검증할 수 있다.

# 7. HTTPS의 세부사항

HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.

HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다. 

오늘날 보안계층은, SSL과 대체품인 TLS로 구현되어 있다.

이 모두를 의미하는 ‘SSL’을 사용하는 관행을 따른다.

![image.png](attachment:87af154b-97ef-4509-9d05-476fe4964cc4:image.png)

## 7.2 HTTPS 스킴

보안 HTTP는 선택적이다.

우리는 웹서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 URL의 스킴을 통해 말해줄 수 있다.

https://

클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다.

- 만약 URL이 http 스킴을 갖고 있다면, 클라이언트는 서버에 80(기본값) 포트로 연결하고 평범한 HTTP 명령을 전송한다.
- 만약 URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443(기본값) 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 핸드셰이크를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.

![image.png](attachment:58bde384-f415-4fe5-82d9-e44fef8648bb:image.png)

## 7.3 보안 전송 셋업

HTTP에서는 클라이언트가 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫는다.

HTTPS에서는 SSL 보안 계층 때문에 약간 더 복잡하다.

클라이언트는 웹 서버의 443 포트로 연결한다.

TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.

핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.

이 메시지는 TCP로 보내지기 전에 암호화된다. 

![image.png](attachment:7f9ad7ba-c7cb-4ed3-90b1-28ec7197b6ad:image.png)

## 7.4 SSL 핸드셰이크

암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.

핸드셰이크에서는 다음과 같은 일이 일어난다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고받는다.

![image.png](attachment:bc90c688-b3ec-4165-8195-9b0e8453fab7:image.png)

## 7.5 서버 인증서

SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다. 

오늘날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이진 않는다.

보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.

잘 알려진 인증기관에 의해 서명된 서버 인증서는, 그가 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.

## 7.6 사이트 인증서 검사

- 날짜 검사
    - 브라우저는 인증서 유효함 확인을 위해 인증서의 시작 및종료일 검사한다.
- 서명자 신뢰도 검사
- 서명 검사
    - 서명기관의 공개키를 서명에 적용하여 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.
- 사이트 신원 검사
    - 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.

# 8. 진짜 HTTPS 클라이언트

## 8.1 OpenSSL

OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다.

# 9. 프락시를 통한 보안 트래픽 터널링

클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다.

그럼 프락시는 요청을 어디로 보내야 하는지 알 수 없게 된다.

![image.png](attachment:23961feb-886e-489c-a478-f5dacae2dbd8:image.png)

HTTPS가 프락시와도 잘 동작할 수 있게 HTTPS SSL 터널링 프로토콜을 사용하여, 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.

클라이언트는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해준다.

CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며, 그것이 완료되면, 클라이언트와 서버 사이에서 데이터가 직접적으로 오갈 수 있게 해주는 터널을 만든다.

만약 커넥션을 수립하기 위한 핸드셰이크가 성공했다면, SSL 데이터 전송이 시작된다.

프락시는 CONNECT의 요청을 평가하여 그것이 유효하고 사용자가 그러한 커넥션을 요청할 수 있도록 허가를 받았는지 확인한다. 

만약 모든 것이 적법하다면 프락시는 목적지 서버로 연결하고 성공하면 200 Connection Established 응답을 클라이언트에게 보낸다.
