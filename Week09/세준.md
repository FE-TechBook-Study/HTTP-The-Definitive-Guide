# 14장 보안 HTTP

## 14.1 HTTP 보안의 필요 요소

보안 HTTP는 단순 암호화 이상의 여러 요구사항을 충족해야 한다.

- **서버 인증**: 사용자가 접속한 서버가 진짜인지 확인
- **클라이언트 인증**: 서버가 접속한 사용자의 신원을 확인
- **무결성**: 전송 중 데이터가 변조되지 않았음을 보장
- **암호화**: 도청으로부터 보호
- **효율**: 성능 저하 최소화
- **편재성**: 어디서나 적용 가능해야 함
- **확장성**: 관리 및 적용이 용이해야 함
- **사회적 생존성**: 사용자/기업이 신뢰하고 받아들일 수 있어야 함

💡 결론: **HTTP는 반드시 보안 계층과 결합되어야 한다.**

---

## 14.2 HTTPS

- **HTTPS = HTTP + 보안 계층(SSL/TLS)**
- URL이 `https://`로 시작
- 모든 HTTP 요청/응답이 네트워크 전송 전에 암호화됨
- **SSL(현재는 TLS)** 이 HTTP 하부 전송 계층에 추가되어 데이터 인코딩/디코딩 수행

즉, HTTPS는 **HTTP 메시지를 TLS 위에서 안전하게 주고받는 프로토콜**이다.

---

## 14.3 암호 기법 (Cryptography Essentials)

### 🔑 기본 개념

- **암호(Algorithm)**: 텍스트를 암호문으로 변환하는 수학적 절차
- **키(Key)**: 암호 동작을 제어하는 매개변수 (숫자 값)
- **대칭키 암호화**: 같은 키로 암호화/복호화 (빠르지만 키 유출에 취약)
- **공개키 암호화(비대칭키)**: 공개키로 암호화, 개인키로 복호화 (보안 강력, 속도 느림)
- **디지털 서명**: 메시지 위조·변조 방지를 위한 암호 체크섬
- **디지털 인증서**: 신뢰 기관이 보증한 신원 증명 문서

---

## 14.4 대칭키 암호화

- **동일 키**로 인코딩/디코딩
- 속도가 빠르고 효율적
- 단점: 키 분배가 어렵고, `유출되면 모든 데이터가 위험`
- 예시: **DES, Triple-DES, RC2, RC4**

---

## 14.5 공개키 암호화 (비대칭)

- 암호화 키와 복호화 키가 다름 (공개키 ↔ 개인키)
- 다수 클라이언트는 **서버의 공개키**로 암호화 → 서버만 개인키로 복호화 가능
- 장점: 키 분배가 쉽다, 보안성이 높다
- 단점: 연산이 느림
- 대표 알고리즘: **RSA**

👉 그래서 **실제 HTTPS에서는 하이브리드 방식** 사용:

1. 세션 키 교환 → 공개키 암호화 사용
2. 이후 데이터 전송 → 빠른 대칭키 암호화 사용

---

## 14.6 디지털 서명

- **개인키로 생성한 체크섬** → 공개키로 누구나 검증 가능
- 메시지 변조 방지 + 송신자 신원 보장
- 공격자가 메시지를 바꿔도 체크섬이 맞지 않음

---

## 14.7 디지털 인증서 (Certificate)

- 신뢰할 수 있는 **인증 기관(CA)** 이 발급
- 포함 정보:
  - 서버/조직 이름
  - 공개키
  - 유효기간
  - 발급자 정보 & 서명

### 서버 인증 과정

1. 브라우저가 HTTPS 요청 시 서버 인증서를 가져옴
2. 브라우저는 내장된 CA 리스트와 비교
3. 신뢰할 수 있는 CA라면 인증 성공
4. 불명확하거나 만료된 인증서라면 경고 발생

---

## 14.8 HTTPS 동작 과정

HTTPS는 기본적으로 **443 포트** 사용.

### 📍 암호화 되지 않은 HTTP

1. 클라이언트 → 서버 TCP 연결(80 포트)
2. 요청 송신 → 응답 수신
3. 연결 종료

### 📍 암호화된 HTTPS

1. 클라이언트 → 서버 TCP 연결(443 포트)
2. **SSL/TLS 핸드셰이크**: 암호 알고리즘, 키 교환, 인증서 검증
3. 세션 키 생성
4. 암호화된 요청/응답 송수신
5. SSL 종료 → TCP 종료

---

### 🔑 SSL/TLS 핸드셰이크 과정

1. 프로토콜 버전 교환
2. 사용할 암호화 알고리즘 선택
3. 서버 인증서 전달 & 검증
4. 세션 키 생성
5. 이후 모든 통신을 세션 키 기반 대칭 암호로 암호화

---

## 14.9 프락시와 HTTPS 터널링

- 프락시 서버는 일반적으로 HTTP 헤더를 보고 목적지를 판단
- 하지만 HTTPS는 암호화되어 헤더조차 읽을 수 없음

### 해결책: **CONNECT 메서드**

- 클라이언트가 프락시에 “이 호스트:포트와 안전 연결을 맺어달라” 요청
- 프락시는 단순히 **TCP 터널**만 열어줌 (내용은 알 수 없음)
- 이후 클라이언트 ↔ 서버 간 직접 암호화된 통신 진행

---

# ✅ 요약 정리

- HTTPS는 **HTTP + SSL/TLS**
- **대칭키 + 공개키 혼합**으로 성능과 보안을 모두 확보
- **디지털 서명 + 인증서**로 무결성과 신원 보장
- **SSL/TLS 핸드셰이크**를 통해 안전한 세션 키 교환
- **프락시 환경**에서는 CONNECT 기반 터널링으로 보안 유지**인증 + 암호화 + 무결성**을 제공하는 안전한 HTTP이다.
