# 상현

## 14.1 HTTP를 안전하게 만들기

HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응령이 좋아야 함
또한 아래를 제공할 수 있는 보안 기술이 필요

- 서버 및 클라이언트 인증: 위조된 서버 또는 클라이언트가 아닌 진짜와 이야기 하고 있는 지
- 무결성:  데이터가 위조되는 것으로부터 안전
- 암호화: 도청에 걱정 없이 서로 통신
- 효율: 성능이 낮은 클라이언트나 서버에서도 사용 가능할 정도로 좋은 알고리즘
- 편재성(Ubiquity): 거의 모든 클라이언트와 서버에서 지원
- 관리상 확장성: 누구든 어디서든 즉각적인 보안 통신 가능
- 적응성: 현재 알려진 최선의 보안 방법을 지원
- 사회적 생존성: 사회의 문화적, 정치적 요구를 만족

### 14.1.1 HTTPS

넷스케이프에서 개발

보안 계층이 추가되어 안전 소켓 계층(Secure Sockets Layer, SSL) 혹은 전송 보안 계층(Transport Layer Security, TLS)를 이용하여 요청과 응답이 네트워크로 보내지기 전에 암호화

![사진1](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F84677dd3-261f-428a-a689-8818ec53a824%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.12.15.png/size/w=1640?exp=1755526504&sig=4zFhhsOza_F7Ove_KZaY1HpqMYcy0jMFoG_r2vR0cQs&id=253438a5-b001-80e5-8fe1-eb7ee40c5e9e&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

## 14.2 디지털 암호화

디지털 암호 기초 요소:

- 암호: 암호화 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩 및 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩 및 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법: 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학

암호법은 수년간 존재해왔으며 해독 불가능하게 만들 수도 있으며 변조를 방지

### 14.2.2 암호(cipher)

암호: 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법

평문: 인코딩되기 전의 원본 메시지

암호문: 암호로 인코딩된 메시지

### 14.2.3 암호 기계

복잡한 암호를 생성 및 해독하기 위애 암호기계가 등장

### 14.2.4 키가 있는 암호

키(암호 매개변수)를 통해서 암호 기계가 동작하며 키에 따라서 평문이 각자 다르게 인코딩

### 14.2.5 디지털 암호

디지털 계산이 가능해지며:

- 기계 장치를 벗어나 더 복잡한 인코딩과 디코딩 알고리즘 가능
- 매우 큰 키를 지원해지고 많은 조합이 가능

![스크린샷 2025-08-18 오전 10.56.09.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F9a871545-e449-4081-a7e2-e8ac4cb547b6%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.56.09.png/size/w=1640?exp=1755526524&sig=tEU_z6lhXVevbpMjyTt6OFzbTcNxPxKjXVAbDlCPfAU&id=253438a5-b001-80a6-aa71-f696a8f1a52b&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

## 14.3 대칭키 암호법

하나의 키로 인코딩 및 디코딩하며 잘 알려진 방법은 DES, Triple-DES, RC2, RC4

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

시도 가능한 방법이 만다면 그만큼 시도하는데 시간이 길며 키의 길이는 시도 가능한 방법의 개수를 의미:

- 길이가 8비트라면 256가지의 값이 가능. 40비트라면 약 1조의 가능값

### 14.3.2 공유키 발급하기

각 대화의 상대방마다 공유키를 발급해야 하며 각 노드가 N개 존재한다면 대략 N^2개의 키가 필요

## 14.4 공개키 암호법

두 개의 비대칭 키를 사용하여 공개키는 보낼 시에 인코딩하며 비공개키는 수신 값을 디코딩하기 위해 사용

해당 서버의 공개키를 누구나 가지고 있으면 메세지 발송이 쉬움

### 14.4.1 RSA

공개키 기법 중 하나로 큰 소수를 소인수분해하기 어렵다는 수학방식을 기본으로 탄생한 암호체계

### 14.4.2 혼성 암호 체계와 세션 키

공개키 암호 방식의 계산은 느린 경항이 있기에 대칭과 비대칭 방식을 혼합해서 사용

- 노드들 사이의 안전한 의사소통을 수립할 때는 공개키를 사용하고
- 안전한 채널이 만들어지면 이후의 모든 데이터는 비공개키를 사용하여 소통

## 14.5 디지털 서명

암호 체계에서 암호화 및 해독화만 아니라 위조되지 않았음을 증명하는 디지털 서명(digital signing) 또한 필요

### 14.5.1 서명은 암호 체크섬이다

두 가지 이점:

- 메시지 작성자를 알 수 있음. 개인 비밀 키로 계산이 되기에 저자 확인 가능
- 메세지 위조 방지. 악의적인 공격자가 중간에 메시지를 수정했다면 체크섬 변경이 되고 올바른 체크섬을 생성하기에는 개인 비밀 키를 알 수 없기에 날조 어려움

디지털 서명은 비대칭 공개키로 생성이 되며, 갱

![스크린샷 2025-08-18 오후 12.12.55.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F2ee2fe4a-6d44-49f6-9eff-1ec9c4e51fdd%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.12.55.png/size/w=1640?exp=1755526584&sig=kqU_SlIiwDwXUBXFBPQzUlGDGPPbHYr4PakVeZ08oZo&id=253438a5-b001-80be-898d-d1ccdb8b7dd5&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- 서명은 개인키(비공개키)를 이용하여 암호화를 하고
- 수신자는 공개키를 이용하여 해독하여 메세지 위변조 확인

## 14.6 디지털 인증서

인터넷 신분증. 흔히 ‘certs’라고 불림

### 14.6.1 인증서의 내부

![스크린샷 2025-08-18 오후 2.03.26.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F9ea12152-3d6a-48f5-aa46-e0b6237afb75%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.03.26.png/size/w=1640?exp=1755526613&sig=s30Ryao4vTrA91iuBxhRoFkHIfaOhRnBpP74LWRdgmA&id=253438a5-b001-8034-b261-ff09ff848051&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

인증서 내부는 다음으로 구성:

- 대상의 이름(사람, 서버, 조직 등)
- 유효기간
- 인증서 발급자(누가 이 인증서를 보증하는가)
- 인증서 발급자의 디지털 서명
- + 공개키, 서명 알고리즘에 대한 정보 등등

### 14.6.2 X.509 v3 인증서

인증서마다 차이가 있지만 해당 정보를 X.509라는 표준화된 서식에 저장이 되며 서식에는 아래 값들이 저장됨:

| 필드 | 설명 |
| --- | --- |
| 버전 | 이 인증서가 따르는 X.509 인증서 버전의 번호. 요즘은 3버전 |
| 일렬번호 | 인증기관에 의해 생성된 고유한 정수 |
| 서명 알고리즘 ID | 서명을 위해 사용된 암호 알고리즘. (예: RSA 암호화를 이용한 MD2 요약) |
| 인증서 발급자 | 인증서를 발급하고 서명한 기관이 이름. X.500 포멧으로 기록 |
| 유효 기간 | 인증서가 유요한 기간. 시작일과 종료일 정의 |
| 대상의 이름 | 인증서에 기술된 사람이나 조직과 같은 엔터티. X.500 포맷으로 기록 |
| 대상의 공개 키 정보 | 인증 대상의 공개 키 |
| (선택적) 발급자의 고유 ID | 발급자의 이름이 겹치는 경우를 대비한 발급자의 고유한 식별자 |
| (선택적) 대상의 고유 ID | 대상의 이름이 겹치는 경우를 대비한 대상의 고유한 식별자 |
| 확장 | 선택적인 확장 필드의 집합(버전 3이상 지원). 중요한 지 아닌 지 표시. 중요한 확장은 반드시 이해가 되어야 하기에 이해하지 못하면 인증서를 거절
흔히 쓰이는 확장:
기본제약 - 대상과 인증기관의 관계
인증서 정책 - 인증서가 어떤 정책하에 승인되었는지
키 사용 - 공개키가 어떻게 사용될 수 있는지에 대한 제한 |
| 인증기관 서명 | 위의 모든 필드에 대한 인증기관의 디지털 서명 |

### 14.6.3 서버 인증을 위해 인증서 사용하기

최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져오며 없다면 보안 커넥션은 실패

서버 인증서는 아래를 포함하여 더 많은 정보:

- 웹 사이트의 이름과 호스트 명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저는 인증서를 받으면 서명 기관을 검사하며 신뢰 가능한 서명 기관이라는 정보는 보통 브라우저에 저장되어 있음
만약, 신뢰 여부를 확신할  수 없다면, 사용자에게 신뢰 여부 대화상자를 표시

## 14.7 HTTPS의 세부사항

### 14.7.1 HTTPS의 개요

HTTPS는 TCP/IP 계층에서 HTTP 요청과 응답을 보내기 전에 보안 계층을 먼저 걸쳐감.
SSL 혹은 TLS를 사용하며 현재는 현대적인 대체품인 TLS로 구현. 그러나 ‘SSL’이라고 통들어서 호칭

### 14.7.2 HTTPS 스킴

보안은 선택적 사항이며 웹 서버에 보안 프로토콜 버전을 알려주기 위해 URL의 스킴을 이용

- HTTP: `http://www.xxxx....` → 서버 80번(기본값) 포트 연결
- HTTPS: `https://www.xxx` → 바이너리 프로토콜이기에 서버 443(기본값) 프토 연결 → 3-way handshake 이후 HTTPS 요청 응답 수행

### 14.7.3 보안 전송 셋업

HTTPS로 인식이되고 서버의 443포트로 연결이 되면 SSL 보안 접속을 시도한다

### 14.7.4 SSL 핸드셰이크

![스크린샷 2025-08-18 오후 3.24.18.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fdc18565c-9079-47d1-ba96-abb7f867be1f%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.24.18.png/size/w=1640?exp=1755526631&sig=Af8zjuarJ5e473zgYl-otQcZyB4PLUy65fCtgsrbsqQ&id=253438a5-b001-80ea-ae81-f9444824eb9f&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

핸드셰이크에서는 다음이 일어난다:

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 셰션 키 생성

### 14.7.5 서버 인증서

서버는 클라이언트 인증서를 받고 클라리언트는 서버 인증서를 받지만, 대부분 개인 클라이언트 인증서를 갖고 있지 않기에 클라이언트 인증서 요구는 별로 없음

그러나 HTTPS에서는 서버 인증서가 항상 필요. 왜냐하면 클라이언트의 정보가 올바른 서버로 전달되고 있는지 확인 필요

서버 인증서 내부에는 다음이 포함되어 있으며 X.590 v3의 파생된 인증서

- 인증서 일렬번호, 유효기간, 조직 이름, DNS 호스트 명, 사이트 공개키, 인증서 발급자 이름 및 서명

### 14.7.6 사이트 인증서 검사

최신 웹브라우저들은 서버 인증서에 대한 기본적인 검사를 하고 더 철저히 검사하는 방법을 사용자에게 표시

웹 브라우저가 실행하는 웹 서버 인증서 검사 단계는:

- (아래 각 단계에서 각 통과되지 않으면 브라우저는 에러를 표시)
- 날짜 검사: 인증서의 유효기간을 확인
- 서명자 신뢰도 검사: 서버를 보증하는 어떤 인증 기관(Certificate Authority, CA)을 통해 신뢰도 확인
    - 브라우저에 보통 인증 가능한 기관의 리스트가 들어있음
    - 인증된 기관이 서명한 다른 사이트는 신뢰가 가능함(신뢰된 A라는 기관이 B의 인증서 서명. B가 C의 인증서에 서명되면 C또한 신뢰 가능한 사이트)
- 서명 검사: 서명 기관이 신뢰 가능하다면 서명기관의 공개키를 서명에 적용하여 체크섬과 비교하여 무결성 검증
- 사이트 신원 검사: 서버 인증서에는 도메인 이름이 포함되어 있으며 대화 중에 서버의 도메인 이름을 검사. 만약 서버 클러스터를 포함하는 인증서라면 와일드 카드를 포함하여 작성

### 14.7.7 가상 호스팅과 인증서

가상 호스팅된 하나의 서버에서 다양한 웹서비스를 운용 가능하고 한 개의 인증서만 지원하는 경우가 있을 때, 웹 페이지의 도메인들로 연결 시 인증서에 기재된 도메인으로 보안 트랜잭션을 리다이렉트

## 14.8 진짜 HTTPS 클라이언트

SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 오픈 라이브러리들

### 14.8.1 OpenSSL

SSLeay를 계승하한 오픈소스 라이브러리

### 14.8.2 간단한 HTTPS 클라이언트

OpenSSL를 이용한 C 코드 흐름도…

### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기

흐름도?

- SSL 콘텍스트 초기화
- 도메인의 IP를 획득
- 호스트 포트 443으로 TCP 연결
- SSL handshake 실행
- DES-CBC3-MD5 암호를 이용하여 SSL 연결
- 서버 인증서를 받음
- 암호화된 채널을 통해 HTTP 요청을 보내고 응답을 받음

## 14.9 프락시를 통한 보안 트래픽 터널링

HTTPS 요청은 보안처리가 되어서 내부 내용을 보기 어려움 그래서 프락시를 쓰는 쪽에서는 요청을 읽지 못해서 어디로 보내야 하는지 모름

이를 해결하기 위해 CONNECT라는 메서드를 먼저 활용하여 프락시에게 어느 포트로 보낼 지 지시를 하고 완료 된다면 HTTPS 연결 요청을 해당 도메인으로 전송
