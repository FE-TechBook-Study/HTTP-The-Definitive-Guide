# 상현

## (별도 검색) 프록시

[[웹 서버] Proxy 서버와 Forward, Reverse 프록시](https://jcdgods.tistory.com/322#none)

[[Proxy] Forward Proxy와 Reverse Proxy](https://xxeol.tistory.com/29)

프록시는 1)포워드 프록시와 2)리버스 프록시 2개로 나뉜다.

- 포워드 프록시는 캐싱, 클라이언트 IP 암호화, 서버 부함 감소 등을 한다
- 리버스 프록시는 로드 밸런싱, 캐싱, 웹 서버 숨김 처리(보안)을 한다

## 6.1 웹 중재자

프락시는 웹 서버이자 웹 클리언트기도 하다.
클라이언트의 요청을 받기 때문에 웹 서버이며, 받은 요청을 다시 서버로 보내야 하기 때문이다.

### 6.1.1 개인 프락시와 공유 프락시

**공용 프락시**

- 여러 클라이언트가 함께 사용하는 프락시 지칭
- 중앙 집중형 프락시로 관리하는 게 비용효율이 높고 쉬움
    - 캐시 관점에서 보면 공통된 요청들을 캐시 데이터로 반환 가능

**개인 프락시**

- 브라우저의 기능을 확장하거나 성능을 개선하거나 무료 ISP 서비스를 위한 광고 실행 가능

### 6.1.2 프락시 대 게이트웨이

프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션 연결
게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상 연결
그러나, 현재는 프락시가 게이트웨이의 역할을 많이 하기에 차이점이 모호

## 6.2 왜 프락시를 사용하는가?

프락시는 실용적이고 유용하며, 보안을 개선하고, 성능을 높여주며, 모든 HTTP 트래픽을 보고 수정할 수 있다.

### **어린이 필터**

- 어린이들에게 교육 컨텐츠만 접근 허용하며 성인 콘텐츠를 차단하는 필터링 프락시의 기능

### **문서 접근 제어자**

![스크린샷 2025-07-09 오전 10.21.54.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F4a0bd434-dfed-420a-821b-3614f288af11%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.21.54.png/size/w=1920?exp=1752135993&sig=oGPTl2ug3bYcLtHI2JauJn7Qfq3LC7yxtt6j-nt0h20&id=22b438a5-b001-80e1-add3-e8654c3cd50d&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- 다양한 서버에 대한 접근을 중앙 프락시 서버에서 접근 제어 설정
- 클라이언트1은 제약없이 뉴스 페이지 접근 가능
- 클라이언트2는 제약 없이 외부 인터넷 접근 가능
- 클라이언트3는 서버B에 접근 전 먼저 비밀번호 요구

### **보안 방화벽**

보안 강화를 위해 들어오고 나가는 프로토콜의 흐름을 통제하는 방향으로 사용

### **웹 캐시**

요청이 많은 문서의 사본을 관리하고 같은 요청들에 대해서 빠르게 제공하여 느리고 비싼 인터넷 커뮤니케이션을 감소

### (GPT) CDN과 캐시 프락시에 대해서 설명

| 항목 | 프락시 (Proxy) | CDN (CloudFront 등) |
| --- | --- | --- |
| 위치 | 클라이언트 앞 또는 서버 앞 | 전 세계 여러 위치의 엣지 |
| 주요 목적 | 보안, 필터링, 로드밸런싱 | 콘텐츠 전달 속도 최적화 |
| 캐싱 | 가능 | 핵심 기능 (엣지에서 캐싱) |
| 사용 예 | 내부망, API Gateway 등 | 정적 웹사이트, 동영상, API |
| 예시 | Squid, Nginx, Envoy 등 | AWS CloudFront, Akamai 등 |

또한, 동시에 둘다 사용이 가능하고 목적에 따라 위치(누가 더 upstream,업스트림,인지 판별)가 변경될 수 도 있다**보편적인 구조 (CDN이 업스트림인 경우)**

```
[클라이언트]
    ↓
[CloudFront (CDN)]
    ↓
[Reverse Proxy (예: Nginx, API Gateway)]
    ↓
[웹 애플리케이션 / 백엔드 서버]

✔️ 이런 경우:
- CloudFront는 전 세계 "캐시된 콘텐츠 제공" (정적 + 동적 캐싱)
- 캐시에 없을 경우 → 프락시 서버로 전달
- 프락시는 내부 보안 정책, 로드밸런싱, 인증 등을 처리
```

**반대 구조(프락시가 업스트림인 경우)**

```html
[클라이언트]
    ↓
[Forward Proxy (회사 내 프락시 등)]
    ↓
[CloudFront (CDN)]
    ↓
[원본 서버]

✔️ 이런 경우:
- 내부망에서 사용자 트래픽을 제어하기 위한 프락시
- 보안 정책, URL 필터링, 인증, 모니터링 등을 프락시에서 담당

📌 기업 네트워크나 보안 환경에서 자주 사용
```

### 대리 프락시(Surrogate)

웹 서버처럼 위장하여 요청에 대한 콘텐츠를 찾아내는 역할
공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용 가능하며 이 때는 “서버 가속기”라고 호칭

### 콘텐츠 라우터

![스크린샷 2025-07-09 오전 10.56.39.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F4b63e5c7-bb03-4e0b-a530-204d3121c5bc%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.56.39.png/size/w=1920?exp=1752136027&sig=poPCRBCPp5TYeMqM1_DlGYL04a0RW8a8sYrHDmetF4s&id=22b438a5-b001-8075-80f4-e2421e4608fb&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

트래픽 조건과 콘텐츠 종류에 따라 요청을 특정 웹 서버로 유도하는 역할
어느 서비스에서:

- 성능 향상 구독했다면, 가장 가까운 캐시로 전달
- 필터링을 구독했다면, 필터링 프락시로 요청 전달

### 트랜스코더

콘텐츠를 클라리언트에게 전달하기 전에 본문 포맷을 수정 가능

- 이미지 확장자를 변경하거나 색 강도를 수정
- 텍스트 파일을 압축
- 외국어 문서로 변환 가능

### 익명화 프락시(Anonymizer)

HTTP 메세지에 신원을 식별할 수 있는 특성들(IP 주소, From 및 Referer 헤더, 쿠키, URI 세션 아이다) 제거하여 개인 정보 보호와 익명성 보장 기여

## 6.3 프락시는 어디에 있는가?

### 6.3.1 프락시 서버 배치

![스크린샷 2025-07-09 오전 11.13.52.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F0ddc2e55-9c6b-4a22-b175-b2553fb3a0b7%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.13.52.png/size/w=1920?exp=1752136042&sig=i8bS3lurVZV-qGSDYBzQSV2OI-2dlbHdNO8VPW1tTAc&id=22b438a5-b001-800f-9019-d3846b6bf071&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

**출구(Egress) 프락시(6-11a)**

- 위치: 로컬 네트워크 출구에 위치
- 방화멱이나, 요청 효율화, 필터링 프락시에 적합한 위치

**접근(입수) 프락시(6-11b)**

- 위치: ISP 접근 지점에 위치
- 다운로드 속도 개선과 인터넷 대역폭 비용을 줄이기 위한 캐시 프락시에 적합

**대리 프락시(리버스 프락시)(6-11c)**

- 위치: 웹 서버들의 바로 앞에 위치
- 웹  서버로 향하는 모든 요청을 처리하며 보안 기능, 캐시 가능

**네트워크 교환 프락시(6-11d)**

- 위치: 네트워크  사이의 인터넷 피어링 교환 지점 위치
- 인터넷 교차로의 혼잡을 완하하고 트래픽 흐름을 감시하기 위해 사용

### 6.3.2 프락시 계층

프락시를 프락시로 연결하여 프락시 계층이라는 연쇄를 구성할 수 있으며 부모와 자식의 관계를 가짐
서버에 가까운 쪽을 부모, 클라이언트에 가까운 쪽을 자식으로 규정

```html
클라이언트 ↔️ 프락시1(프락시2의 자식) ↔️ 프락시2(프락시1의 부모 && 프락시3의 자식) ↔️ 프락시3(프락시2의 부모) ↔️ 웹 서버
```

프락시는 역할에 맞는 부모 프락시를 선택할 수 있고 이를 “동적 부모 선택”이라고 한다. 

```html
           캐시 프락시
              ↕️
클라이언트 ↔️ 접근 프락시 ↔️ 웹서버
              ↕️
           압축 프락시 ↔️ 웹서버
```

그 몇가지 예로:

- 부하균형: 부하 분산을 위해서 부모들의 작업량 수준에 근거하여 부모 선택
- 지리적 인접성에 근거한 라우팅: 지역을 담당하는 부모 선택
- 프로토콜/타입 라우팅: URI근거하여 부모나 원 서버로 라우팅

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가(HTTP 트래픽이 프락시로 향하는 법)

![스크린샷 2025-07-09 오전 11.40.27.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F84dbdb61-5776-44b0-90f4-fd3ce91cd8dc%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.40.27.png/size/w=1920?exp=1752136061&sig=emmCAD_l_oJbDWzMUzaOM2ZvtphwjHiGIRZi-oi9088&id=22b438a5-b001-80df-835e-e66ce90e31cd&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- (6-14a)클라이언트 수정: 브라우저에서 수동 혹은 자동 프락시 설정이 있어서 HTTP요청을 바로 프락시로 전송
- (6-14b)네트워크 수정: 스위칭 장비 + 라우팅 장비를 통하여 네트웨크에서 트래픽을 프락시로 전달
    - 인터셉트 프락시로 지칭 혹은 투명 프락시(클라이언트 모르게 연결)
- (6-14c)DNS 이름공간 수정: 대리 프락시와 같은 프락시들은 웹 서버의 이름과 IP 주소를 자신이 직접 사용할 수 있게 DNS 테이블을 수정
- (6-14d)웹 서버 수정: 웹서버로 수신하되 HTTP 리다이렉션(305)로 프락시로 연결

## 6.4 클라리언트 프락시 설정

> 위 6-14a의 확장? 클라이언트가 트래픽을 프락시로 어떻게 보내는지에 대한 설명
> 

수동 설정, 브라우저 기본 설정, 프락시 자동 설정(Proxy auto-configuration, PAC), WPAD 프락시 발견

### 6.4.1 클라이언트 프락시 설정: 수동

웹 클라이언트 설정에서 프락시를 수동으로 설정 가능

### 6.4.2 클라이언트 프락시 설정: PAC(Proxy auto-configuration) 파일

프락시 자동 설정(PAC)파일은 프락시 설정을 상황에 맞게 계산해주는 자바스크립트 프로그램
일반적으로 .pac 확장자를 가지며 MIME 타입은 “application/x-ns-proxy-autoconfig’

사용하려면 PAC 파일의 URI를 브라우저에 설정값 입력 필요.

각 PAC 파일에는 프락시를 계산해주는 `FindProxyForUrl(url,host)`라는 함수를 정의하고 반환값은 아래 표

| `FindProxyForUrl`반환값 | 설명 |
| --- | --- |
| DIRECT | 프락시 없이 연결이 직접 연결 |
| PROXY host:port | 지정한 프락시를 사용 |
| OSCKS host:port | 지정한 SOCKS 서버를 사용 |

### 6.4.3 클라이언트 프락시 설정: WPAD

웹 프락시 자동발견 프로토콜(WPAD)는 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘

실행순서:

- PAC URI를 찾기 위해 WPAD 사용
- 주어진 URI에서 PAC 파일 찾기
- 프락시 서버를 알아내기 위해서 PAC 파일 실행
- 알아낸 프락시 서버를 이용해서 요청 처리

WPAD는 올바른 PAC 파일을 찾아내기 위해 여러 가지 발견 기법을 사용하는데 성공할 때까지 각 기법을 하나씩 시도

- 동적 호스트 발결 규약(DHCP)
- 서비스 위치 규약(SLP)
- DNS 잘 알려진 호스트 명
- DNS SRC 레코드
- DNS TXT 레코드 안의 서비스 URI

## 6.5 프락시 요청의 미묘한 특징들

### 6.5.1 프락시 URI는 서버 URI와 다르다

```html
// 프락시로 보낼 때
GET http://www.xxxx.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3

// 원 서버로 보낼 때
GET /index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

원 서버는 자신의 호스트 명과 포트번호를 알고 있으므로 호스트와 포트번호+스킴이 없는 부분 URI만 전송
그러나 프락시가 나오면서 프락시는 목적지 서버와 컨넥션을 맺기 위해 호스트 이름과 스킴이 필요

**GPT랑 확인해본 결과 현재도 동일하게 유지하여 보냄**
[HTTP1.1 RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-5.3), [HTTP2.0 RFC 7540](https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3)

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

한 개의 물리적 서버 내부에서 가상 호스팅되어 있는 경우

- 요청 메시지가 완전한 URI를 갖도록 규정
- 가상으로 호스팅 되는 웹 서버는 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더 요구

이후 들어온 요청들은 docroot를 통해서 부분 URI앞에 폴더 경로가 붙여짐

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

클라이언트는 원서버 또는 프락시랑 대화하는 지 모른다. 
그래서 아래 상황에서만 부분 URI를 보낸다

- 원 서버의 호스트 명과 아이피를 사용하여 원 서버를 대신 대리 프락시일 경우
- 서버로 가는 트랙픽을 중간에 캐치하여 일부 액션을 취하는 인터셉트 프락시일 경우

### 6.5.4 프락시는 프락시 요청과 서버 요청 모두 다를 수 있다

프락시는 완전 URI를 제공하는 프락시 요청을 보낼 수도 부분 URI를 보내는 서버 요청도 보낼 수 있다.

- 완전 URI를 받으면 그것을 사용
- 부분 URI + Host 헤더가 있다면, Host헤더를 통해 원서버의 이름과 포트 번호 탐색
- 부분 URI만 있다면, 다음 방법으로 원 서버 탐색
    - 프락시가 대리 프락시라면, 프락시 내부에 원 서버 정보 탐색
    - 인터셉트 프락시의 트래픽을 받았다면 그 인터셉트 프락시의 원 IP주소와 포트번호 사용
    - 모두 실패 시, 에러 메시지 반환(Host 헤더 지원하도록 브라우저 업데이트 요청)

### 6.5.5 전송중 URI 변경

사소한 변경(HTTP의 명시적 포트 번호 80을 붙이는 일)으로 다운스트림에서 문제가 생길 수 있다.
그래서 프락시는 프로토콜에 엄격하도록 작동하기 보다 관대하게 설정되어 있도록 신경써야 한다.
유일한 예외는 빈 경로를 ‘/’로 교체하는 것 뿐.

**GPT로 확인한 관대한 행동과 아닌 행동**

**관대한 행동**

| 예시 | 설명 |
| --- | --- |
| `Host` 헤더가 빠졌는데도 처리함 | HTTP/1.1은 필수지만 예전 클라이언트를 위해 허용 |
| `http://example.com` 요청의 경로가 비어 있음 → 자동으로 `/`로 처리 | 아까 말한 예 |
| 헤더 필드 이름 대소문자 섞임도 허용 | `Content-type`, `content-Type`, `CONTENT-TYPE` 다 인정 |
| `Transfer-Encoding: chunked`인데 마지막 `0\r\n\r\n` 누락 → 오류 없이 종료 처리 | 일부 브라우저 버그 대응 |
| 명시적 포트 누락 → 암묵적으로 기본 포트로 해석 (`http → 80`, `https → 443`) | 명확한 목적지 파악 가능하면 허용 |

**관대하지 않은 행동**

| 예시 | 설명 |
| --- | --- |
| 클라이언트가 보내준 `Host` 값 무시하고 임의로 수정해서 원서버에 전달 | 보안 문제 야기 가능 (가상 호스팅 판단 실패) |
| 클라이언트가 `http://example.com/path` 보냈는데 `/path` 생략했다고 강제로 붙임 | 잘못된 URL 해석 가능 |
| UTF-8 인코딩 안 된 URI에 대해 임의로 디코딩/수정 | 경로 충돌 또는 보안 이슈 발생 |
| Accept 헤더 무시하고 항상 HTML로 응답 | 협상 실패 → REST API에서 클라이언트 오작동 |
| 요청에 알 수 없는 헤더 있다고 거절 | 확장성 저하 (미래 호환성 무너짐) |

### 6.5.6 URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)

브라우저는 입력받은 URI를 가지고 상응하는 IP 주소를 찾고, IP가 발견되면 연결에 성공할 때까지 시도.
그러나 발견되지 않은 다면 브라우저는 다음 ‘확장’을 시도

- 앞에 ‘www’와 뒤에 ‘.com’을 붙여봄
- 해석할 수 없는 URI를  서드파티 사이트로 넘김
- 호스트의 앞 부부분만 입력하면 자동으로 도메인 검색. ‘host7’ → ‘host7.oreilly.com’ 찾기

### 6.5.7 프락시 없는 URI 분석(URI Resolution)

![스크린샷 2025-07-10 오전 11.50.00.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fd8edbf98-9bcf-4b78-8407-d043823f3861%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.50.00.png/size/w=1920?exp=1752136095&sig=CdEVTr3oQ9sCMlkEmVnVa5rJpTNUst-J0UT1tAX_hWA&id=22c438a5-b001-80e9-b9fa-d029559fb0fc&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

프락시가 없으면 위와 같이

- 브라우저가 먼저 URI 확장해보고
- DNS 성공해서 주소와 포트를 알게되면
- 원 서버에 바로 연결

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

![스크린샷 2025-07-10 오전 11.59.05.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fc6b732da-d94e-45c7-be57-622dc6fcc093%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.59.05.png/size/w=1920?exp=1752136109&sig=ApYyU1JQqs-gIOn_z1QX03CFmHr0ED0gJTpYlJnni6M&id=22c438a5-b001-80ee-abe7-f91426350152&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

명시적인 프락시가 있으면 6.5.6의 단계와 같은 브라우저 확장 기능을 사용 안 한다.
그리고 해당 URI를 그대로 프락시로 넘겨버린다.
**GPT**로 확인해보니, 프락시가 있는 환경에서는 “모든 요청 해석”을 프락시가 책임을 가지고 있기에 그대로 넘겨준다고 한다.

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

![스크린샷 2025-07-10 오후 12.11.18.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fc1f24ca2-7df1-40eb-8f64-b13e23452b98%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.11.18.png/size/w=1920?exp=1752136122&sig=lOyG4oBvdaDxM21JkJUBHjoV2KHHSTtdFFtOR1KVNKk&id=22c438a5-b001-804f-96d3-f3fb32274de4&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

(GPT 해독….)

1. 1단계
    1. 너가 브라우저 주소창에 그냥 `"oreilly"`라고만 썼어.
    2. 도메인도 안 붙이고 `.com`도 없이 그냥 이름만!
2. 2단계
    1. 브라우저는 "oreilly? 이거 어디지?" 하면서 **DNS 서버**에 물어봐.
    2. 근데 그냥 `"oreilly"`는 DNS 서버가 몰라서 **"모르겠음"** 하고 응답해.
3. 3단계
    1. 브라우저는 "아! 혹시 이게 웹사이트 이름일지도?" 해서 자동으로 `www.oreilly.com`으로 바꿔서 다시 DNS에 묻는다.
    2. 이번엔 DNS가 알아보고, `"이거 IP 주소는 xxx.xxx.xxx.xxx 이야"` 하고 알려줘.
4. 4단계
    1. 클라이언트는 이제 `"오케이, 이 IP로 연결해볼까?"` 하고 연결을 시도하려 해
    2. 근데... 이 시점에! **인터셉트 프락시**가 중간에서 이 요청을 가로챈다
    3. 그래서 클라이언트는 실제 **원 서버에 직접 연결하지 않아**. 연결 성공한 줄 알지만, 사실은 **프락시에만 연결된 상태**야
5. 5단계
    1. 클라이언트는 `oreilly.com` IP로 연결을 시도함.
    2. 그런데 그 IP는 사실 **인터셉트 프락시**였고, 연결이 성공됨.
    3. 브라우저는 연결된 상대가 “oreilly.com”이라고 **착각하고** HTTP 요청을 보냄. → `GET / HTTP/1.1\r\nHost: oreilly.com`
    4. 이 요청은 사실 프락시가 받음.
    5. 프락시는 그제서야 진짜 **oreilly.com** 서버로 연결 시도 → 요청 전송 → 응답 받음.
    6. 받은 응답을 브라우저에 그대로 **전달**함.

## 6.6 메시지 추적

프락시가 자주 사용되면서 메시지의 흐름을 추적하고 문제점을 찾아내는 일이 필요

### 6.6.1 Via 헤더

메시지가 지나는 각 중간 노드의 정보를 나열하는 필드

`Via: 1.1 proxy-62.some.net, 1.0 cache.joes.com`
위를 보면 첫 번째는  HTTP 1.1을 사용하여 proxy를 거쳐갔고, 두 번째는 HTTP 1.0을 구현했고 `cache.joes.com`로 불리는 것을 알 수 있음

또한, 메시지 루프(loop)를 탐색할 때도 도움이 되는데, 프락시는 자신의 유니크한 문자열을 Via헤더에 넣고 이 문자열이 이미 Via에 존재하는 지 검사 필요

- **Via 문법**
    - 쉼표로 구분된 경유지(waypoint)의 목록
    - 형식 구문은 아래 이미지 참고
    
    ![스크린샷 2025-07-10 오후 2.49.58.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F083af40f-6879-4283-80dc-e28bfc8ae9a7%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.49.58.png/size/w=1920?exp=1752136146&sig=VDP6E2Vb6_nURO5UaGQs4SGt3W3LXOi9U5A_gxYZQ4Q&id=22c438a5-b001-80ea-8e37-d70c534f5406&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)
    
    - 최대 4개의 구성요소:
        - (선택, 기본은 HTTP) 프로토콜 이름
            - 중개자가 받은 프로토콜을 노출
            - HTTP라면 표현 필요X
        - (필수) 프로토콜 버전
            - 프로토콜의 버전을 노출하며 HTTP 1.0은 “1.0”과 같이 표기
        - (필수) 노드 이름
            - 중개자의 호스트와 포트번호
        - (선택) 노드 코멘트
            - 벤더, 버전 정보, 프락시에서 일어난 이벤트 진당 정보 포함 가능
- **Via 요청과 응답 경로**
    - 응답과 요청의 경로가 같기에 둘 다 Via 헤더를 가지고 있다면 순서가 서로 반대
    요청: A → B → C, 응답: C → B → A
- **Via와 게이트 웨이**
    - 프락시는 HTTP 프로토콜 이외의 프로토콜도 받을 수 있으며 아래 그림이 예시
        
        ![스크린샷 2025-07-10 오후 3.25.34.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F1223c8f2-596e-42cc-9d2b-f012c5c426f1%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.25.34.png/size/w=1920?exp=1752136174&sig=es4DA5mZ91NVqKk5N9-3TAJ90984trXGnHuwnM8kql0&id=22c438a5-b001-8027-8167-ddd4ca7c3766&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)
        
    - **Server 헤더와 Via 헤더**
        - Server 헤더는 원 서버의 정보를 포함하는 헤더이며 프락시를 통과할 때 수정X
    - **Via가 개인정보 보호와 보안에 미치는 영향**
        - Via에는 중개자들의 정보가 노출되므로 조직 내부망의 아키텍처 노출, 서버 네이밍, 사용 버전이 유출 가능성 존재
        - 유출을 막기 위해 가명으로 대체하거나 경유지 항목들 일부를 하나로 합칠 수 있음

### 6.6.2 TRACE 메서드

프락시가 늘어나면서 메시지 내용을 체크할 방법이 필요하며 TRACE 메서드를 통해서 프락시의 행동을 체크 가능

![스크린샷 2025-07-10 오후 4.07.46.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F4b0d5e01-f930-4001-8ca7-0a68dcb47fe0%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.07.46.png/size/w=1920?exp=1752136193&sig=AKNfsHqxRBvlWEtAp6Ml3XwiXCxzc0u8v6mNfnbTeTQ&id=22c438a5-b001-80d1-b267-e20c57a305dc&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

**Max-Forwards**

- TRACE나 OPTIONS는 hop의 개수를 상관 없이 모든 경로를 가는데 Max-Forwards를 통해 hop 개수를 제한 가능
- 무한 루프에 빠지지 않는지 연쇄 중간의 특정 프락시 서버들의 효과를 체크할 때 유용
- 프락시 자신이 0으로 받았다면 다음으로 넘기지 않고 바로 클라이언트로 응답
- 값은 다음에 전달할 때 마다 1씩 감소

## 6.7 프락시 인증

프락시는 제한된 사용자만 접근할 수 있게 작동 가능

![스크린샷 2025-07-10 오후 4.13.36.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fd7bd5e58-6592-44e1-8bbc-98c3de93d4f2%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.13.36.png/size/w=1920?exp=1752136209&sig=hkAIhLlByb1Pa4hHOdj4RCkZzFX8X5AtVY01h1Z-X-c&id=22c438a5-b001-8099-923e-c19e6b736a9e&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- 제한된 콘텐츠 요청이 오면 407 Proxy Authorization Required와 Poxy-Authenticate 헤더에 자격증명 방법을 클라이언트로 전달
- 클라이언트는 사용자 자격에 필요한 정보를 모아서 다시 Poxy-Authenticate 헤더에 넣어서 전달하고 유효하면 원 서버로 연결

## 6.8 프락시 상호운용성

다양한 벤더들이 개발하기에 서로 상호적인 측면이 중요

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

프락시 서버로 넘어오는 헤더 필드를 모두 이해를 못 해도 반드시 그대로 전달
만약 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 수서도 반드시 유지

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기 + 6.8.3 Allow 헤더

OPTIONS를 통해 서버의 능력을 먼저 알 수 있는데 프락시가 지정된 메서드나 Allow를 이해 못 해도 수정하지 않고 클라이언트에게 전달
