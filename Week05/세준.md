# 6장 프락시

## 1. 프락시란?

- **`정의`**
  - HTTP 프락시는 클라이언트와 서버 사이에 위치하여 요청과 응답을 중개하는 HTTP 애플리케이션
- **`특성`**
  - 프락시는 클라이언트로부터 요청을 받아 마치 서버처럼 응답하고, 실제 서버로는 클라이언트처럼 요청을 보냄. 즉, **서버와 클라이언트의 역할을 동시에 수행**
- **`주의사항`**
  - HTTP 클라이언트/서버 프로토콜을 모두 이해하고 준수해야 하며, **요청 라우팅, 응답 캐싱, 헤더 조작** 등 다양한 기능이 필요

---

## 2. 프락시의 유형

- **`개인 프락시`**
  - 한 명의 사용자를 위해 구성된 프락시 (보통 보안/속도 목적).
- **`공유 프락시`**
  - 여러 사용자가 동시에 사용하는 프락시 (회사, 학교, ISP 등에서 사용).
- **`게이트웨이`** **프락시와의 차이점**
  - 프락시는 동일 프로토콜 간 중계, 게이트웨이는 이기종 프로토콜 간 변환기 역할
  - 예: HTTP 요청을 받아 FTP나 POP으로 변환해서 백엔드 시스템에 전달.

---

## 3. 프락시 사용 목적

- **`보안 필터링`**
  - 특정 콘텐츠 차단(예: 청소년 유해 사이트 차단).
- **`문서 접근 제어`**
  - 부서별로 문서 접근을 중앙화된 정책으로 통제.
- **`방화벽 기능`**
  - 애플리케이션 계층에서 세밀하게 트래픽 제어 (예: 이메일 필터링).
- **`웹 캐싱`**
  - 자주 요청되는 리소스를 저장해 서버 부하 감소 및 응답 시간 개선.
- **`서버 가속기(대리 프락시)`**
  - 실제 서버 앞단에서 캐싱/로딩 최적화 기능 수행.
- **`콘텐츠 라우팅`**
  - 요청 URL이나 콘텐츠 유형에 따라 다른 백엔드로 라우팅.
- **`트랜스코딩`**
  - 포맷/언어/이미지 크기 등 변경 가능.
- **`익명화`**
  - HTTP 헤더(IP, Referer, User-Agent 등)를 제거 또는 가공해 개인 정보 보호.

---

## 4. 프락시의 배치 방식

- **`출구 프락시 (egress)`**
  - 조직 내부 → 외부 요청 제어 (보안, 요금 절감, 필터링).
- **`입구 프락시 (ingress)`**
  - ISP 진입 지점에 위치, 사용자 다수의 요청을 통제.
- **`대리 프락시 (reverse proxy)`**
  - 클라이언트 입장에서는 한 서버로 보이지만, 내부적으로 여러 서버로 분산.
- **`네트워크 교환 프락시`**
  - 인터넷 백본 사이의 트래픽 교차점에 배치되어 캐싱, 트래픽 최적화.

---

## 5. 프락시 계층 구조

- **`정적 계층`**
  - 고정된 부모-자식 프락시 관계.
- **`동적 계층`**
  - **부하 기반**
    - 부모 프락시의 현재 작업량에 따라 선택.
  - **지리적 기반**
    - 요청 위치에 가까운 프락시 선택.
  - **URI 기반**
    - 특정 경로나 도메인 패턴에 따라 프락시 지정.
  - **유료 사용자 기반**
    - 더 빠른 경로(대형 캐시, 압축 서버)로 유도.

---

## 6. 클라이언트 트래픽을 프락시로 전송하는 방법

- **`클라이언트 설정`**
  - 수동 또는 자동(PAC, WPAD)으로 프락시 지정.
- **`네트워크 장비`**
  - 스위치, 라우터에서 HTTP 트래픽 감지 후 리다이렉트.
- **`DNS 조작`**
  - 프락시로 향하는 도메인으로 강제 지정.
- **`웹 서버 리다이렉션`**
  - HTTP 3xx 리다이렉트로 요청 경로 변경.

---

## 7. 브라우저 프락시 설정

- **`수동 설정`**
  - 브라우저 내 프락시 주소/포트 수동 입력.
- **`PAC 파일`**
  - `FindProxyForURL(url, host)` 함수로 동적 선택 로직 작성 가능.
- **`WPAD`**
  - DNS, DHCP, SLP 등을 이용해 PAC 파일 위치를 자동 탐색.

---

## 8. 프락시 요청의 특징

- **`URI`**
  - 일반 서버는 `/path` 같은 부분 URI 사용.
  - 프락시는 `http://host/path` 같은 **절대 URI 사용** 필요.
- **`대리 프락시`**
  - 클라이언트가 프락시 존재를 모름 → **부분 URI만 전달됨**.
- **`URI 변형 문제`**
  - 포트 명시, 인코딩 변경 등 사소한 차이도 **호환성 이슈 유발** 가능.
- **`가상 호스팅`**
  - `Host` 헤더 없으면 올바른 서버 선택 불가.
- **`자동 URI 확장`**
  - 예: "oreilly" → [www.oreilly.com](http://www.oreilly.com/) 자동 확장.

---

## 9. Via 헤더

- **`정의`**
  - 요청/응답이 거친 모든 프락시/게이트웨이 정보를 담는 헤더.
- **`형식`**
  - `Via: 1.1 proxy.example.com, 1.0 cache.example.net`
- **`용도`**
  - 루프 방지
  - 디버깅
  - 프로토콜 능력 판단
- **`보안 이슈`**
  - 실 호스트명 대신 가명 사용 가능 (`devirus.proxy.net` 등).

---

## 10. TRACE 메서드

- **`용도`**
  - 요청이 지나온 프락시 경로와 메시지 변경 사항을 확인하기 위함.
- **`응답`**
  - 요청 내용을 본문에 `message/http` 형식으로 그대로 반환.
- **`주의`**
  - 보안상의 이유로 대부분의 서버/프락시에서는 비활성화됨.

---

## 11. Max-Forwards 헤더

- **`용도`**
  - 프락시 홉 수 제한. TRACE, OPTIONS 등 디버깅용 요청에서 사용.
  - 예시: `Max-Forwards: 3` → 3개 프락시까지만 전달 허용.

---

## 12. 프락시 인증

- **407 상태 코드**와 `Proxy-Authenticate` 헤더로 인증 요구.
- **`응답`**
  - 클라이언트는 `Proxy-Authorization` 헤더에 인증 정보 첨부.
- **`제약`**
  - 여러 프락시가 연쇄된 경우에는 인증 적용이 어려울 수 있음.

---

## 13. 상호운용성과 확장성

- **알 수 없는 헤더/메서드**: 프락시는 **수정하지 말고 그대로 전달**해야 함.
- **OPTIONS 메서드**:
  - 클라이언트가 서버/리소스의 기능을 미리 확인할 수 있는 메서드.
  - 응답 시 `Allow` 헤더에 지원하는 메서드 목록 포함.
