# 18장 웹 호스팅

## 18.1 호스팅 서비스

모든 회사가 물리적인 서버실을 만드는 것을 불가능 그래서 호스팅 서비스 등장

### 18.1.1 간단한 예: 전용 호스팅

한 곳의 ISP에서 각자 원하는 서버를 구매하여 각자 웹을 운영

## 18.2 가상 호스팅

컴퓨터 한 대를 여러 고객이 공유하게 해서 저렴한 웹 호스팅을 제공하는 것을 “공유 호스팅” 혹은 “가상 호스팅”

### 18.2.1 호스트 정보가 없는 가상 서버 요청

HTTP 1.0 명세는 공용 웹 서버가 호스팅하고 있는 가상 웹 사이트에 누가 접근하고 있는지 식별하는 기능을 제공하지 않음. 그래서 공유 호스팅 서버에 요청을 하게 된다면 서버는 어느 호스트에 접근하려고 하는지 모르는 문제 발생

![스크린샷 2025-08-29 오전 9.50.25.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F15b14be3-d513-4257-9504-ea05c49c2646%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.50.25.png/size/w=1920?exp=1756714626&sig=ZIOTpbxMSMmgjM-XhsMsddG8fDKW-zYum3Zhha5Ke4k&id=25e438a5-b001-8086-967a-c6909bf6d748&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

### 18.2.2 가상 호스팅 동작하게 하기

초기 명세에는 가상 호스팅을 고려하지 않았기에 문제를 수정하려고 완전한 URL도 포함해서 보내는 것으로 해결
그러나 명세 맞추어 업그레이드가 오래 걸릴 것이기에 먼저 문제를 해결하고자 네 가지 기술 개발

- URL 경로를 통한 가상 호스팅:
    - 서버가 어떤 사이트를 요청하는지 알 수 있게 URL에 특별한 경로 컴포넌트 추가
    - 같은 서버 안에서 다음과 같이 수신:
        - `GET /joe/index.html` `GET /mary/index.thml`
    - 좋은 해결책 아님
        - /joe와 /mary 접두어는 불필요하고 혼란
        - 기본 접근 방식이 동작 X. [joes-hardware.com](http://joes-hardware.com) 또는 [joes-hardware.com](http://joes-hardware.com)/index.html
- 포트번호를 통한 가상 호스팅:
    - 각 사이트에 다른 포트번호를 할당하여 분리된 웹 서버로 역할
    - 좋은 해결책 아님: 유저가 비표준 포트를 쓰지 않아도 리소를 접근을 워함
- IP 주소를 통한 가상 호스팅:
    - 각 사이트에 별도의 IP주소를 할당하고 이를 하나의 컴퓨터에 연결하여 운영
    - 위 보다 좋은 접근이지만 다음 문제 포함
        - 컴퓨터에 연결할 수 있는 IP개수 제한 존재
        - IP는 희소 상품이기에 웹에 연결할 만큼의 풀이 적음
        - 서버를 복제할 수록 복제된 서버에 IP주소를 부여해야 하므로 더 필요하게 되는 문제
- Host 헤더를 통한 가상 호스팅:
    - 사이트 이름을 알려주는 Host헤더 추가
    - HTTP 1.0을 확장한 HTTP 1.0+에 처음 소개되고 HTTP 1.1에서는 반드시 기재

### 18.2.3 HTTP 1.1 Host 헤더

- 문법과 사용 방법
    - `Host = “Host” “:”호스트[ “:”포트]`
    - 포트가 없으면 해당 스킴의 기본 포트 사용
    - URL에 IP주소가 있으면 Host헤더는 같은 주소 포함
    - URL에 호스트 명이 있으면 Host헤더는 같은 호스트 명 포함
    - URL에 호스트 명이 있으면 Host헤더는 URL이 가리키느 IP 주소 포함 X. 한 개의 IP에 여러 서비스를 연결하는 서비스에 문제 발생 가능
    - 특정 프락시 서버를 사용한다면, Host헤더에는 원 서버의 호스트 명과 포트를 기술
    - 모든 요청 메세지에는 Host헤더가 필수
    - HTTP 1.1 요청에 Host가 없다면 400 상태 코드로 응답
- Host 헤더 누락
    - 몇몇 낡은 브라우저는 Host헤더를 보내지 않을 때, 사용자를 기본 웹페이지로 보내거나 브라우저 업그레이드 제안하는 에러 페이지 반환
- Host 헤더 해석하기
    - 요청에 전체 URL이 기술되어 있다면 Host헤더값 무시하고 전체 URL 사용
    - 요청에 URL에 정보가 없고 Host헤더가 있다면 Host헤더 해석
    - 위 두 단계 모두 없다면 클라이언트에 400 Bad Request 응답 반환
- Host 헤더와 프락시
    - 프락시를 거쳐가는 구 브라우저는 Host헤더에 원 서버가 아닌 프락시 이름을 담는 오류가 있음

## 18.3 안정적인 웹 사이트 만들기

사이트 장애가 생기는 상황:

- 서버 다운, 트래픽 폭증, 네트워크 장애나 손실

### 18.3.1 미러링 된 서버 팜

서버 팜은 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합

마스터 원 서버의 정보를 미러링하여 만들어진 여러 서버들을 하나의 스위치에 연결하고, 모든 요청은 스위치로 가게 IP주소를 스위치의 주소로 설정
이 때, 클라이언트 요청이 특정 서버로 가는 두 가지 방법은:

- HTTP 리다이렉션: 콘텐츠는 마스터 서버의 IP를 가리키고, 마스터 서버는 요청 받는 즉시 복제 서버로 리다이렉트
- DNS 리다이렉션: 콘텐츠의 URL은 IP주소를 여러개 가질 수 있고, DNS가 클라이언트에게 IP를 선택하여 전달

### 18.3.2 콘텐츠 분산 네트워크(CDN)

CDN은 특정 콘텐츠의 분산을 목적으로 하는 단순 네트워크

### 18.3.3 CDN의 대리 캐시

대리 서버와 미러링 서버의 차이점은 수요에 따라 동작
대리 서버는 원 서버의 전체 콘텐츠를 복사X. 요청하는 것만 저장
원 서버는 대리 서버의 콘텐츠를 업데이트해줄 의무 없음

### 18.3.4 CDN의 프락시 캐시

기존 프락시 캐시처럼 요청 데이터를 저장만 하는 것이 아닌 네트워크를 가로채서 특정 액션을 취하는 행동 + 분산 가능

## 18.4 웹사이트 빠르게 만들기

앞선 내용들을 활용하여 네트워크를 분산시키고 콘텐츠를 사용자에게 더 가깝게 만들어 주면 콘텐츠 로딩 속도가 빨라짐

# 20장 리다이렉션과 부하 균형

## 20.1 왜 리다이렉트인가?

HTTP 애플리케이션은 언제나 다음 세 가지를 원함:

- 신뢰할 수 있는 HTTP 트랜잭션의 수행
- 지연 최소화
- 네트워크 대역폭 절약

위로 인하여 웹 콘텐츠는 흔히 여러 장소에 배포되고 이를 통하여 부하 균형을 할 수 있음

## 20.2 리다이렉트 할 곳

클라이언트 입장에서 서버, 프락시, 캐시, 게이트웨이는 모두 요청을 처리하기에 서버의 특성을 갖고 있기에 많은 리다이렉션을 지원하지만 특정 리다이렉션은 특정 종단만을 위해서 특별히 설계

웹 서버는 IP별로 요청을 다루고 프락시는 프로토콜별로 요청을 다룸

## 20.3 리다이렉션 프로토콜의 개요

메시지를 서버로 리다이렉트하기 위해 사용되는 리다이렉션 방법들:

- HTTP 리다이렉션, DNS 리다이렉션, 임의 캐스트 어드레싱, 아이피 맥(MAC) 포워딩, IP 주소 포워딩

메시지를 프락시 서버로 리다이렉트하기 위해 사용되는 방법들:

- 명시적인 브라우저 설정, 프락시 자동설정(Porxy auto-configuration, PAC), 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol, WPAD), 웹 캐시 조작 프로토콜(Web Cache Configuration Protocol, WCCP), 인터넷 캐시 프로토콜(Internet Cache Protocol, ICP), 캐시 배열 라우팅 프로토콜(Cache Array Routing Protocol, CARP), 하이퍼텍스트 캐싱 프로토콜(Hyper Text Cache Protocol, HTCP)

## 20.4 일반적인 리다이렉션 방법

### 20.4.1 HTTP 리다이렉션

HTTP 리다이렉션 장점으로는 리다이렉트 하는 서버가 클라이언트 아이피 주소를 앎

과정:

- 클라이언트가 서버에게 요청
- 서버는 302화 함께 Location에 변경된 위치를 응답
- 클라이언트는 Location에 담겨 있는 주소로 다시 요청

아래와 같은 단점으로 인해 다른 리다이렉션과 함께 조합하여 사용

- 어떤 서버로 리다이렉션하는지 결정하는 절차가 상당히 많은 자원 소요
- 페이지에 접근할 때마다 두 번의 왕복이 필요하기에 시간 소요
- 리다이렉션 서버가 고장나면 사이트도 고장

### 20.4.2 DNS 리다이렉션

DNS는 하나의 도메인에 여러 IP주소 연결이 가능하며 어느 주소를 반환할 것인지에 대한 방법은 단순한 것부터 복잡한 것까지 다양

- DNS 라운드 로빈
    - 서버에 대한 클라이언트 상대적인 위치나 현재 스트레스를 고려하지 않고 돌아가면서 각 서버에 연결
    - 그러나 한번 DNS조회 후 얻은 주소를 계속 사용하여 얻는 이점(조회 비용 절감 등)이 있지만, 이를 인지 못함
- 부하 균형 알고리즘
    - 가장 로드가 적은 웹 서버로 연결되기 목록 가장 위에 위치
- 근접 라우팅 알고리즘
    - 서버 팜이 지역적으로 있을 경우, 근처 지역으로 이동
- 결함 마스킹 알고리즘
    - 네트워크 상태를 모니터링하고 정전이가 기타 장애를 피해서 라우팅

### 20.4.3 임의 캐스트 어드레싱

여러 지리적으로 흩어진 웹 서버들은 정확히 같은 IP주소를 갖고 있고, 받은 요청은 클라이언트에서 가장 가까운 서버로 보내주기 위한 백본 라우터의 ‘최단거리’ 라우팅에 의존

아직 실험직인 기법이고 동작을 위해

- 서버는 반드시 라우터의 언어로 말해야하고
- 일어날 수 있는 주소 충돌 해결 가능

### 20.4.4 IP (맥)MAC 포워딩

MAC(Media Access Control, MAC)주소를 인지하여 어느 포트로 보낼 지 판별 가능
MAC 주소 포워딩은 점 대 점으로만 가능하기에 서버나 프락시는 스위치와 한 홉 거리에 위치

### 20.4.5 아이피 주소 포워딩

아이피 주소에 따라 라우팅
맥 포워딩보다 좋은 점은 한 홉 거리에만 있을 필요가 없음

귀환 경로를 제어할 수 있는 두 가지 방법:

- 패킷의 출발지 아이피 주소를 스위치 아이피 주소로 변환하여 응답을 스위치로 가게 함
    - 주소 양쪽을 번역해주는 아이피 전달 장치를 완전 NAT
- 만약 출발 패킷의 IP가 클라이언트 그대로 남아 있다면, 스위치를 거치지 않아야 하며 이를 반(half) NAT라고 함
    - 장점은 서버가 클라이언트 아이피 주소를 얻는다는 것, 단점은 클라이언트와 서버 사이의 네트워크 전체에 약간의 통제가 필요

### 20.4.6 네트워크 구성요소 제어 프로토콜

IP 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소(NE)이 웹 서버나 프락시 캐시와 같이 애플리케이션 계층 요청을 처리하는 서버 구성요서들(SE)과 대화해줄 수 있게 해주는 네트워크 구성요서 제어 프로토콜(Network Element Control Protocol, NECP)

……굳이?????

## 20.5 프락시 리다이렉션 방법

웹 브라우저와 같은 클라이언트들이 프락시로 설정하는 법은:

- 명시적인 브라우저 설정
- 동적인 자동 설정
- 자연스러운 가로채기

### 20.5.1 명시적 브라우저 설정

대부분의 브라우저에는 프락시 서버 접촉을 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 메뉴가 존재
그러나 사용자 모두 설정할 수 없기에 미리 설정되어 있는 브라우저를 다운 받도록 유도

두 가지 단점이 존재하는데:

- 프락시 사용하는 브라우저들은 프락시가 다운되더라도 원 서버와 접촉 허용을 안 하기에, 프락시가 다운되면 사용자 접속 문제 경험
- 네트워크 아키텍처를 변경했을 때, 예를 들어 더 많은 프락시를 추가하길 원할 때 브라우저 사용자들 프락시 설정을 변경

### 20.5.2 프락시 자동 설정

사용자가 명시하는 브라우저 명시적인 설정은 네트워크 아키텍처의 변화를 제한한다.
프락시 자동설정 프로토콜(Proxy Auto-configuration, PAC)이 이를 해결

브라우저들은 URL별로 접촉해야할 PAC 파일을 찾아서 지정된 서버를 찾음
([6장 프락시에서 해당 내용 나옴](https://github.com/FE-TechBook-Study/HTTP-The-Definitive-Guide/blob/main/Week05/%EC%83%81%ED%98%84.md#642-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%ED%94%84%EB%9D%BD%EC%8B%9C-%EC%84%A4%EC%A0%95-pacproxy-auto-configuration-%ED%8C%8C%EC%9D%BC))

![스크린샷 2025-08-29 오후 3.26.41.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F04fc87e2-3f65-4571-a96f-e26052a62a6b%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.26.41.png/size/w=1920?exp=1756714661&sig=Y2YXZ-UZt5Z7LTNP9Jn7YsJDH1XmxKK8QI1Af-HEeIA&id=25e438a5-b001-8082-9fa9-d0a2f3c98e39&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

오늘날 PAC은 미리 설정된 브라우저처럼 몇몇 주요 ISP들에 의해 사용

### 20.5.3 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

- **PAC의 자동발견**
    - WPAD는 HTTP 클라이언트가 PAC 파일의 위치를 알아내고 그 파일을 이용해서 적절한 프락시 서버의 이름을 알 수 있게 해줌
    WPAD 프로토콜을 구현한 HTTP 클라이언트는 다음 그림과 같이 수행
        
        ![스크린샷 2025-08-29 오후 3.38.34.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F655c3816-c596-4c26-b0df-df6660905a29%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.38.34.png/size/w=1920?exp=1756714682&sig=kMKOEW-1-b2kcBpHL_2ItCUioFW0gxJOQJcOWyjBqyA&id=25e438a5-b001-805f-9405-e10b43eafc3c&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)
        

- **WPAD 알고리즘**
    - WPAD 명세는 다음 기법을 순서대로 정의
        - DHCP(Dynamic Host Configuration Protocol, 동적 호스트 설정 프로토콜)
        - SLP(Service Location Protocol, 서비스 위치 프로토콜)
        - DNS에 잘 알려진 호스트 명
        - DNS의 SRV 레코드
        - TXT 레코드의 DNS 서비스 URL들
    - 위 다섯 가지 중에 WPAD 클라이언트에게는 오직 DHCP와 DNS에 잘 알려진 호스트 명 기법만이 요구
        
        > **GPT를 활용해서 찾은 바로는 요구보다는 2개는 필수 지원이고 나머지는 선택적이라고 해석하는 것 더 좋음  
[A client that implements WPAD must support at least the DHCP and DNS `A` record queries. Support for SLP is optional - Web Proxy Auto-Discovery, OREILLY](https://www.oreilly.com/library/view/web-caching/156592536X/ch04s04.html?utm_source=chatgpt.com)**
        > 
    - DNS를 조회할 때는 구체적에서 덜 구체적으로 가며 아래와 같이 볼 수 있음:
        - `QNAME = wpad.development.foo.com`에 대해서 DNS A, DNS SRV, DNS TXT 룩업 진행
        - `QNAME = wpad.foo.com`에 대해서 DNS A, DNS SRV, DNS TXT 룩업 진행
- **DHCP를 이용한 CURL 발견**
    - 이 메커니즘이 작동하려면 DHCP 서버는 반드시 CURL을 가지고 있어야 함
    클라이언트 OS의 API가 값을 못 찾았다면, DHCPINFORM 메시지를 DHCP 서버에게 보내 질의 하여 확인
    `https://server.domain/proxyconfig.pac`
- **DNS A 레코드 룩업**
    - 이 메커니즘이 동작하려면 알맞은 프락시 서버의 IP 주소들이 WPAD 클라이언트들이 질의할 수 있는 DNS 서버에 저장 필요
- **PAC 파일 가져오기**
    - 후보 CURL이 생성되면 CURL에 GET 요청을 하며 응답값을 요청
    이 때 자신이 다룰 수 있는 적절할 CFILE 포멧 정보가 담긴 Accept 헤더 포함 필요
- **언제 WPAD를 실행하는가**
    - 다음 중 하나의 상황에서 수행:
        - 웹 클라이언트가 시작될 때
        - 클라이언트 호스트의 IP 주소가 변경된 네트워크 스택으로부터 어떤 언급이 있을 때마다
    - 클라이언트는 자신 환경에서 어느 쪽인 타당한지 선택하여 사용 가능
    PAC 파일이 만료되었을 때 위 발견 사이클을 시도
- **WPAD 스푸핑(spoofing)**
    - wpad라는 글자를 붙여서 3차 도메인에 도달할 때까지 계속해서 서브도메인을 지움
        - wpad.a.b.micorsoft.com
        - wpad.b.micorsoft.com
        - wpad.micorsoft.com
- **타임아웃**
    - WPAD는 여러 단계를 진행하며 각 단계가 일정한 시간 내에 끝나는지 반드시 확인하기 위해서 가급적 10초 이내로 제한하는 것이 합리적
- **관리자를 위한 고려사항**
    - 클라이언트가 DHCP와 DNS에 잘 알려진 호스트 명 기법을 필수로 구현하기에 관리자 쪽에서도 동일하게 지원 필요
    - ……나머지는 진짜 굳이

## 20.6 캐시 리다이렉션 방법

### 20.6.1 WCCP 리다이렉션

프락시 캐시로 리다이렉트 할 수 있도록 하기 위해 캐시 조직 프로토콜(WCCP) 개발

- WCCP 리다이렉션 동작
    - WCCP를 사용할 수 있는 라우터와, 다른 캐시와 의사소통을 할 수 있는 캐시가 포함된 네트워크가 필요
    - 라우터들의 집합과 그들의 대상이 되는 캐시들이 WCCP 서버스 그룹을 구성. 서비스 그룹 설정은 어떤 트래픽이 어디로 어떻게 분산되는지, 서비스 그룹의 부하가 캐시들 사이에서 어떻게 분산되어야 하는 지 명시
    - 서비스 그룹이 HTTP 트래픽을 리다이렉션 하도록 설정되어 있다면 서비스 그룹 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보냄
    - HTTP 요청이 서비스 그룹의 라우터에 도착했을 때, 요청을 처리하기 위해 서비스 그룹의 캐시 중 하나를 선택
    - 라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화하거나 아이피 맥 포워딩을 하여 캐시로 보냄
    - 만약 캐시가 요청을 처리할 수 없다면, 패킷은 평범하게 포워딩되기 위해 라우터로 귀환
    - 서비스 그룹의 구성원들이 지속적으로 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시(정상작동 여부 메시지)를 교환
- WCCP2 메시지들….
- WCCP2 메시지 구성요소
    - 헤더와 구성요소로 구성
        - 헤더: 메시지의 종류(Here I Am, I See You, Assignment, Removal Query), WCCP 버전, 메시지의 실이(헤더 길이 미포함)
        - 구성요서: 구성요소의 종류와 길이를 서술하는 4비트 헤더
- 서비스 그룹, GRE 패킷 캡슐화, WCCP 부하 균형

## 20.7 인터넷 캐시 프로토콜(ICP)

ICP는 자신이 찾지 못한 캐시를 형제 캐시들에게 조회를 하게 해줌. 일종의 캐시 클러스터링 프로토콜
또한, 최종 ICP 질의를 통해서 요청 메시지의 최종 목적지를 결정할 수 있다는 점에서 리다이렉션 프로토콜이라고 볼 수 있음

객체 프로토콜이다. 근처의 캐시 모두에게 특정 URL을 가지고 있는지 물어보면 있다면 “HIT”, 없다면 “MISS”라고 짧은 메시지로 대답
”HIT”로 대답한 캐시에는 그 객체를 가지고 있는 이웃 캐시에 HTTP 커넥션 오픈 가능

또한, 다순하고 가벼움.
파싱하기 쉽도록 네트워크 바이트 순서에 따라 32비트 크리고 맞추어진 구조체.
효율을 위해 UDP 다이어그램으로 전송되지만, 신뢰 불가능하면 손실 가능

ICP 메시시의 각 부분은:

- OP 코드, 버전, 메시지 길이, 요청 번호, 옵션, 옵션 데이터, 발송자 호스트 주소, 페이로드

더 자세한 정보는 RFC 2186과 2187 참조

## 20.8 캐시 배열 라우팅 프로토콜

프락시 서버가 과부를 방지하기 위해 요청을 분산하는 방법으로 캐시 배열 라우팅 프로토콜(CARP)를 MS와 Netscpae가 표준화

CARP는 ICP의 대안.
ICP는 쓸데없는 복제본도 갖고 있을 수 있는 중복된 엔트리를 허용하는 독립적인 캐시
또한, ICP가 계층적으로 구성되어 있다면, 비적중은 아래와 같이 부모에세 상향 전파

![스크린샷 2025-09-01 오후 3.36.23.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F5fef0c64-3a0e-465b-baaa-a8811200d836%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.36.23.png/size/w=1920?exp=1756714701&sig=GB7VCR1tqiBV1dCurkaNLlWOGHdZgSU9qKnwUFcic3A&id=261438a5-b001-80d9-9b04-ce3812381ac1&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

반대로, CARP는 하나의 큰 서버처럼 동작을 하며 각 구성요서 서버는 전체 캐시된 문서의 일부만 갖고 있음
웹 객체의 URL에 해시 함수를 적용함으로써, 한 번의 검색으로 그 객체의 위치 결정 가능
즉, 주의 모든 이웃에게 보낼 필요가 없기에, 메시지 트랜잭션은 적고, 프락시 서버 추가도 비교적 용이

![스크린샷 2025-09-01 오후 3.42.12.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F783d89ab-46ab-44c6-91d0-9333aba2cc12%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.42.12.png/size/w=1920?exp=1756714720&sig=qPCt-3g8MkugPZgJ2I8DA_TbIRs4V5a8Yas_xgjqy6U&id=261438a5-b001-8048-9b62-d3b4519c8165&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

그러나, 한 개의 프락시가 사용 불가능하면 해시 함수 수정이 필요. 또한 고장이 잦을 수록 비용이 증가.
또한, CARP는 새로운 프로토콜이기에 ICP만 지원하는 기존의 서버는 지원 어려움

CARP 리다이렉션 방법:

- 참여하는 프락시 서버의 테이블을 유지. 서버 활성 여부를 위해 주기적으로 폴링
- 각 참여 프락시 서버들에 대해 해시 함수를 계산. 해시 함수가 반환하는 값은 이 프락시가 처리할 수 있는 부하의 양을 계산
- 요청된 웹 객체의 URL에 근거한 숫자값을 반환하는 분리된 해시 함수를 정의
- URL에 해시 함수와 프락시 서버의 해시 함수의 합계로 배열 획득. 이 값들에 대한 최대값이 사용할 프락시 서버 결정

## 20.9 하이퍼텍스트 캐싱 프로토콜

기존 ICP (Internet Cache Protocol)의 한계(단순 URL조회만 가능하여 더 복잡한 검색 불가능)를 개선하기 위해 나옴.
캐시된 문서에 대한 캐시 정책을 서로 변경가능

메시지는 아래와 같은 구조:

![스크린샷 2025-09-01 오후 4.58.22.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F7f3bd23a-3195-4049-8762-1effedbaf700%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.58.22.png/size/w=1920?exp=1756714735&sig=-TDYDcsh3zbzcZV6FJ0dB3qtnqHY7Xo7DV4targpFPM&id=261438a5-b001-8040-9566-f94eee045734&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

### 20.9.1 HTCP 인증

인증 부분은 선택적 구성요소는 아래:

![스크린샷 2025-09-01 오후 5.00.06.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F31d4a19c-20a5-433f-9e33-4589cb159dc2%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.00.06.png/size/w=1920?exp=1756714748&sig=8rjY0cCeJfihFh-Lk-KHafzuiqfEGuxMpUsYci9lOR8&id=261438a5-b001-8099-87ae-f4464384892d&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

### 20.9.2 캐싱 정책 설정

SET 메시지에 다음 헤더들을 통해서 캐시된 문서에 대한 정책 변경 가능

![스크린샷 2025-09-01 오후 5.01.15.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F9353f167-d910-41c9-84b6-301a00a687d8%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.01.15.png/size/w=1920?exp=1756714771&sig=ZCrLVNFkafOe7UHBmFWWxrbw7RpWv3QgR2jr_139o_U&id=261438a5-b001-8099-afcb-fed3ae6118a8&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)
