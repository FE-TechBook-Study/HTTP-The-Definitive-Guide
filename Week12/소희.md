콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라 한다.

콘텐츠를 저장해서 제공하고 관련 로그에 접근하거나 그것을 관리하는 데 서버가 필요하다. 

필요한 하드웨어와 소프트웨어를 직접 관리하기 어렵다면, 호스팅 서비스나 호스팅 업체가 필요할 것이다.

호스팅 업체는 서버와 웹 사이트 관리 프로그램을 대여해주고 다양한 등급의 보안, 리포트, 사용 편의를 제공한다. 

# 2. 가상 호스팅

많은 웹 호스팅 업자는 컴퓨터 한 대를 여러 고객이 공유하게 해서 저렴한 웹 호스팅 서비스를 제공한다.

이를 공유 호스팅 혹은 가상 호스팅이라 부른다. 

각 웹사이트는 다른 서버에서 호스팅하는 것처럼 보이겠지만, 사실은 물리적으로 같은 서버에서 호스팅되는 것이다.

## 2.1 호스트 정보가 없는 가상 서버 요청

HTTP/1.0 명세는 공용 웹 서버가 호스팅하고 있는 가상 웹 사이트에 누가 접근하고 있는 식별하는 기능을 제공하지 않는다.

요청 메시지에 URL의경로 컴포넌트만 전송한다.

https://www.naver.com/index.html 을 요청하면, 브라우저는 https://www.naver.com 에 연결하지만, HTTP/1.0 요청은 호스트 명에 대한 별다른 언급 없이 “GET /index.html” 이라는 요청을한다.

서버가 여러 개의 사이트를 가상 호스팅하고 있으면, 사용자가 어떤 가상 웹 사이트로 접근하려고 하는 것인지 아는 데 필요한 정보가 충분하지 않다.

![image.png](attachment:bc63dd0e-64d5-46be-9847-b033a70219d3:image.png)

웹 서버는 사용자가 어떤 웹 사이트로 접근하려고 하는지 아는데 필요한 정보가 충분하지 않다.

두 요청이 (서로 다른 웹 사이트에) 완전히 다른 문서를 요청을 하더라도, 요청 자체는 똑같이 생겼다.

문제는 웹 사이트 호스트 정보가 요청에서 제거된다는 것이다.

![image.png](attachment:3da5bc75-0c60-4df0-8232-e083c7c5d021:image.png)

HTTP 리버스 프락시와 인터셉트 프락시 또한 어떤 사이트를 요청하는지에 관한 정보가 필요하다.

## 2.2 가상 호스팅 동작하게 하기

호스트 정보를 HTTP 요청 명세에 넣지 않은 것은, 각 웹 서버가 정확히 한 웹사이트만 호스팅할 것이라고 잘못 예측한 HTTP 명세의 실수였다. 

HTTP  설계자들은 공유 서버인 가상 호스팅을 고려하지 않았다.

그래서 URL에 있는 호스트명 정보는 필요 없는 것으로 여겨 명세에서 제외하고 단순히 경로 컴포넌트만 전송하도록 설계했다.

**URL 경로를 통한 가상 호스팅**

서버가 어떤 사이트를 요청하는 것인지 알 수 있게 URL에 특별한경로 컴포넌트를 추가한다.

- 죠의 가게 https://joe-naver.com/joe/index.html
    - GET /joe/index.html 은 죠의 가게에 대한 요청
- 메리의 가게 https://mary-naver.com/mary/index.html
    - GET /mary/index.html 은 메리의 가게에 대한 요청

좋은 해결책은 아니다.

/joe, /mary 접두어는 불필요하고 혼란스럽다. 이미 호스트명에 이름도 기재되어 있다.

일반적으로 홈페이지로 갈 때 사용하는 https://joe-naver.com나 https://joe-naver.com/index.html 같은 URL은 동작하지 않는다.

일반적으로 URL 기반의 가상 호스팅은 좋지 않은 방법이라 거의 사용하지 않는다.

**포트번호를 통한 가상 호스팅**

각 사이트에 다른 포트번호를 할당하여, 분리된 웹 서버의 인스턴스가요청을 처리한다.

웹 서버에 각각 다른 포트번호를 할당할 수 있다.

80 포트 대신 죠는 82, 메리는 83으로 할 수 있다.

하지만 사용자는 URL에 비표준 포트를 쓰지 않고서도 리소스를 찾기 원하므로 동일한 문제가 발생한다.

**IP 주소를 통한 가상 호스팅**

각 가상 사이트에 별도의 IP 주소를 할당하고 모든 IP 주소를 장비 하나에 연결한다. 웹 서버는 IP 주소로 사이트 이름을 식별한다. 

각 가상 웹 사이트에 유일한 IP 주소를 한 개 이상 부여한다.

모든 가상 서버의 IP 주소는 같은 공용 서버에 연결되어 있다. 

서버는 HTTP 커넥션의 목적지 IP 주소를 보고 클라이언트가 어떤 웹사이트에 연결하려고 하는지 알 수 있다. 

호스팅 업자가 209.172.34.3을 www.joes-naver.com에, 209.172.34.4를 www.mary-antiques.com에 할당하고,두 IP 주소를 같은 물리 서버 장비에 연결해놨다고 해보자. 

웹 서버는 그림과 같이 어떤 가상 사이트에 요청한 것인지식별하려고 목적지 IP 주소를 사용한다.

![image.png](attachment:db3e92cc-b244-437c-9d98-00f6f9f20317:image.png)

가상 IP 호스팅은 잘 동작하지만, 규모가 아주 큰 호스팅 업자에게는 약간 어려운 문제를 안겨준다.

- 일반적으로 컴퓨터 시스템이 연결할 수 있는 장비의 IP의 개수에는 제한이있다.
    - 호스팅 업자는 수백 혹은 수천 개의 가상 사이트를 포함하는 공용 서버를 제공해야 하는데, 이는 큰 문제다.
- IP 주소는 희소 상품이다. 가상 사이트를 많이 가지고 있는 호스팅 업자는 호스팅하는 모든 웹 사이트에할당할 가상 IP 주소를 충분히 얻지 못할 수도 있다.
- IP 주소가 부족한 문제는 호스팅 업자가 용량을 늘리려고 서버를 복제하면서 더 심각해진다. 부하 균형의 구조상, 각 복제된 서버에 IP 주소를 부여해야 하므로 IP 주소는 복제 서버의 개수만큼 더 필요하게 된다.

위와 같은 IP 주소 부족 문제가 생길수 있음에도 불구하고 널리 쓰이는방식이다. 

**Host 헤더를 통한 가상 호스팅**

많은 웹 호스팅 업자들은 HTTP 설계자에게 이 문제를 해결해달라는 압력을 너헜다. HTTP/1.0의 개선 버전과 HTTP/1.1의 공식 버전은 사이트의 이름을 알려주는 Host 요청 헤더를 정의했다. 웹 서버는 Host 헤더로 가상 사이트를 식별할 수 있다.

IP 주소의 낭비와 가상 IP의 제한 문제를 피하려면, 가상 사이트들이 같은 IP를 사용하더라도 각 사이트가 어디에 속해 있는지 알 수 있어야 한다.

그러나 브라우저 대부분이 URL의 경로 컴포넌트만 서버에 전달하므로, 중요한 가상 호스트 명 정보는 받지 못한다.

이 문제를 해결하려고, 브라우저와 서버 개발자들은 서버가 원 호스트 명을 받아 볼 수 있게 HTTP를 확장했다.

모든 요청에 호스트명(그리고 포트)을 Host 확장 헤더에 기술해서 전달한다.

![image.png](attachment:02350121-dc3f-4370-a07b-f6a52abe0e60:image.png)

HTTP 메시지의 데이터는 여정 중에 많은 프로토콜에 의해 통제된다.

HTTP 고려하는 것은 오직 여정의 출발지(송신자)와 목적지(수신자)뿐이지만, 미러링된 서버, 웹 프락시, 캐시가 함께 하는 웹의 세계에서 HTTP 메시지의 목적지는 항상 단순하지만은 않다.

이 장은 리다이렉션 기술(HTTP 메시지의 최종 목적지를 결정하는 네트워크 도구, 기법, 프로토콜)에 대한 장이다.

리다이렉션 기술은 보통 메시지가 프락시, 캐시, 서버 팜의 특정 웹 서버 중 어디에서 끝나는지 판별하기 위해 사용한다.

라다이렉션 기술은 클라이언트의 메시지를 명시적으로 요청하지 않은 곳으로 보낼수 있다.

- HTTP 리다이렉션
- DNS 리다이렉션
- 임의 캐스트 라우팅
- 정책 라우팅
- 아이피 맥 포워딩
- 아이피 주소 포워딩
- 웹 캐시 조직 포로토콜(WCCP)
- 인터캐시 커뮤니케이션 프로토콜(ICP)
- 하이퍼텍스트 캐싱 프로토콜(HTCP)
- 네트워크 요소 제어 프로토콜(NECP)
- 캐시 배열 라우팅 프로토콜(CARP)
- 웹 프락시 자동발견 프로토콜(WPAD)

## 1. 왜 리다이렉트인가?

HTTP 애플리케이션은 언제나 다음 세가지를원하므로, 리다이렉션은 피할 수 없다.

- 신뢰할수 있는 HTTP트랜잭션의 수행
- 지연 최소화
- 네트워크 대역폭 절약

이러한 이유들 때문에, 웹 콘텐츠는 흔히 여러 장소에 배포된다.

이렇게 하면 한 곳에서 실패한 경우 다른 곳을 이용할수 있으므로 신뢰성이 개선된다.

또한 클라이언트가 가까운 리소스에 접근할 수 있게 되어 콘텐츠를더 빨리 받게 되므로 응답시간도 줄여준다.

뿐만 아니라, 목적지 서버가 분산되므로 네트워크 혼잡도 줄어든다.

리다이렉션이란 최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합이라고 생각할 수 있다.

리다이렉션의 구현에는 부하 균형의 과제가 포함되는데, 둘은 서로 공존하기 때문이다.

대부분의 리다이렉션 장치들은 몇 가지 방식의 부하 균형을 포함한다.

즉, 들어오는 메시지의 부하를 서버들의 집합에게 분산할 수 있다.

반대의 경우도 마찬가지로 어떤 방식의 부하 균형이든 리다이렉션을 포함하게 되는데, 왜냐하면 들어오는 메시지는 반드시 어떤 식으로든 부하를 공유하는 서버들 중 하나에게 전달되어야 하기 때문이다. 

## 2. 리다이렉션 할 곳

서버, 프락시, 캐시, 게이트웨이는 클라이언트가 그들에게 HTTP 요청을 보내고 그들이 그것을 처리한다는 점에서, 클라이언트에게 있어 모두 서버라고 할 수 있다.

모두 공통적으로 서버의 특성을 갖고 있기 때문에, 많은 리다이렉션 기법이 그들 모두에서 동작한다.

그러나 어떤 리다이렉션 기술들은 특정 종류의 종단만을 위해 특별히 설계되어 일반적인 적용이 불가능하다.

웹 서버는 IP 별로 요청을 다룬다. 똑같이 복제된 서버들로 요청을 분산한다는 것은 같은 URL에 대해 여러 곳에서온 요청들을 각각 최적의 웹 서버로 보내겠다느 것을 의미한다(클라이언트에 가장 가까운 것이나 부하가 가장 적은 것, 혹은 그 외의 이유로 최적인 것).

서버로의 리다이렉트란 휘발유를 찾는 모든 운전기사를 가장 가까운 주유소로 보내주는 것과 같다.

프락시는 프로토콜별로 요청을 다룬다. 이상적으로,프락시 이웃의 모든 HTTP  트래픽은 프락시를 거쳐야 한다. 

예를 들어, 클라이언트 근처에 프락시 캐시가 있다면, 모든 요청이 프락시 캐시로 흘러 들어가는 것이 이상적이다.

왜냐하면 캐시는 자주 찾는 문서를 저장하여 클라이언트에게 직접 제공하기 때문에원 서버로의 더 오래 걸리고 비용이 드는 통신을 피할 수 있기 때문이다. 프락시로의 리다이렉트는 주 진입로의 트래픽을 근처에 있는 지름길로 빨아들이는 것과 같다.

## 3. 리다이렉션 프로토콜의 개요

리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것이다.

HTTP 메시지가 인터넷을 통해 나아가는 방향은 그 메시지가 오고, 거쳐가고, 향하는 HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.

예를 들어,

- 브라우저 애플리케이션의 사용자는 브라우저가 클라이언트 메시지를 프락시 서버로 보내도록 설정할 수 있다.
- DNS 분석자(DNS resolver)는 메시지의 주소를 지정할 때 사용될 아이피 주소를 선택한다. 이 아이피 주소는 클라이언트의 지리적 위치에 따라 달라질 수 있다.
- 메시지는 주소가 지정된 여러 개의 패킷으로 나뉘어 네트워크를 통과한다. 스위치와 라우터들은 패킷의 TCP/IP 주소를 검증하고 그에 근거하여 패킷을 어떻게 라우팅할 것인지 결정한다.
- 웹 서버는 HTTP 리다이렉트를 이용해 요청이 다른 웹 서버로 가도록 할 수 있다.

브라우저 설정, DNS, TCP/IP 라우팅, 그리고 HTTP는 모두 메시지를 리다이렉트하는 매커니즘을 제공한다.

- 추가 설명
    - **브라우저 설정**: 프록시 서버를 지정해서 트래픽을 그쪽으로 보냄
    - **DNS**: 도메인 이름을 다른 IP로 바꿔서 리다이렉션
    - **TCP/IP 라우팅**: 운영체제 레벨에서 패킷 경로를 바꿈
    - **HTTP**: 서버가 `302 Found` 같은 응답을 주며 클라이언트를 다른 URL로 보냄

DNS 리다이렉션을 비롯한 대부분의 기법들이 트래픽을 보내려는 곳이 어떤 서버냐에 상관없이 사용될 수 있는 것에 반해 브라우저 설정과 같은 방법은 프락시로 향하는 리다이렉트 트래픽에 대해서만 사용할 수 있다는 점에 주의하라. 

- 추가 설명
    
    ### 🔹 "DNS 리다이렉션을 비롯한 대부분의 기법들"
    
    → DNS, 라우팅, HTTP 리다이렉션 등은 **어떤 서버든지** 목적지를 바꿀 수 있어요. (즉, 일반적인 목적지 IP 자체를 바꿈)
    
    ### 🔹 "브라우저 설정과 같은 방법은"
    
    → 예: 브라우저에서 프록시 서버를 설정해 놓은 경우
    
    ### 🔹 "프락시로 향하는 리다이렉트 트래픽에 대해서만 사용된다"
    
    → 브라우저에 프록시를 설정하면 **모든 트래픽이 그 프록시를 거치게 되지만**, 이건 **브라우저 트래픽에만 적용**되고, **프록시 서버로만 리다이렉트**할 수 있다는 제한이 있어요.
    
    운영체제 전체의 네트워크 트래픽에는 영향을 주지 않아요.
    
    ---
    
    ### 🔍 쉽게 예를 들어 설명
    
    ### ✅ DNS 리다이렉션
    
    - `example.com` → 원래는 `1.2.3.4`
    - DNS 리다이렉션을 하면 `example.com`이 `5.6.7.8`로 바뀜
    - 웹 브라우저든 앱이든, 어떤 프로그램이든 **example.com으로 가려는 모든 트래픽이 바뀐 IP로 감**
    
    ### ❌ 브라우저 프록시 설정
    
    - Chrome에 프록시 `proxy.mycompany.com`을 설정
    - 이 설정은 **브라우저에서만 적용**되고, 브라우저는 모든 요청을 프록시에 보내게 됨
    - 다른 앱(예: 게임, Zoom, 터미널)은 영향을 받지 않음
    - 또한, 프록시로만 보내야 하므로 IP 자체를 변경하는 용도로 쓰기엔 제약이 있음

### 메시지를 프락시 서버로 리다이렉트하기 위해 사용되는 리다이렉션 방법

![image.png](attachment:ab90d7f1-39f1-4c2d-a3a0-39875f47e964:image.png)

## 4. 일반적인 리다이렉션 방법

### 4.1 HTTP 리다이렉션

요청을 처리하는 서버(리다이렉팅 서버)는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트한다.

리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 안다는 것이 다른 형태의 리다이렉션 대비 장점이다.

이론적으로 좀 더 정보에 근거해 선택할 수 있다.

![image.png](attachment:fdab277a-e8bc-4b24-b4db-ab626ad31371:image.png)

위와 같이 요청시, 서버는 302 상태 코드와 함께 리다이렉트 메시지를 돌려보내주었다. 

![image.png](attachment:f34e90f8-3cc8-415b-81b1-c45e7cd8bb67:image.png)

이제 그럼 브라우저는 호스트를 161.56.228.45로 하여 리다이렉트 URL을 사용한 다음과 같은 요청을 다시 보낸다.

![image.png](attachment:4aa37b8b-ef64-49c9-9e5c-a0ba0d14c8a9:image.png)

![image.png](attachment:c7ec3f24-aa5c-45ec-919a-9b523fe8145b:image.png)

HTTP 리다이렉션은 서버로 향하는 요청의 방향을 변경할 수 있지만, 다음과 같은 단점들이 존재한다.

- 어떤 서버로 리다이렉트할지 결정하려면 원 서버는 상당히 많은 처리를 해야 한다. 때로는 거의 페이지 자체를 제공할 때 필요한 것과 거의 같은 양의 처리가 필요하다.
- 페이지에 접근할 때마다 두 번의 왕복이 필요하기 때문에, 사용자가더 오래 기다리게 된다.
- 리다이렉트 서버가 고장나면, 사이트도 고장난다.

이러한 약점 때문에, HTTP 리다이렉션은 보통 몇몇 다른 리다이렉션 기법과 함께 조합하여 사용된다. 

### 4.2 DNS 리다이렉션

클라이언트가 죠의 하드웨어 웹 사이트에 접근하려고 시도할 때마다, 도메인 이름 www.joes-harware.com은 반드시 아이피 주소로 분석되어야 한다. 

DNS 분석자는 클라이언트의 운영체제일 수도 있고, 클라이언트의 네트워크에 있는 DNS 서버이거나 혹은 더 원격에 있는 DNS 서버일 수도 있다.

DNS는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용하며, DNS 분석자는 여러 아이피 주소를 반환하도록 설정되거나 프로그래밍될 수 있다.

분석자가 어떤 아이피 주소를 반환할 것인가를 결정하는 방법은 단순한 것(라운드 로빈)부터 복잡한 것(여러 서버의 로드를 검사해서 로드가 가장 적은 서버의 아이피 주소를 반환하는 것)까지 다양하다.

![image.png](attachment:367377f9-ba0f-4bba-b6e0-0ed070a0ddd5:image.png)

그림에서는 죠는 www.joes-hardware.com을 위해 4대의 서버를 운용한다.

DNS 서버는 www.joes-hardware.com에 대해 네 개의 아이피 주소 중에서 어떤 것을 돌려줄지 결정해야 한다. 

가장 쉬운 DNS 결정 알고리즘은 단순한 라운드 로빈이다. 

**DNS 라운드 로빈**

- 가장 단순하고 흔한 리다이렉션 기법이다.
- 웹 서버 팜 전체에 대한 부하 균형을 유지하기 위해 DNS 호스트명 분석 기능을 사용한다. 서버에 대한 클라이언트의 상대적인 위치나 서버의 현재 스트레스를 고려하지 않는다.

**다중 주소와 라운드 로빈 주소 순환**

대부분의 DNS 클라이언트는 그냥 다중 주소 집합의 첫 번째 주소를 사용한다.

부하 균형을 위해, 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다.

이 주소 순환을 DNS 라운드 로빈이라 부르기도 한다.

예를 들어 www.cnn.com에 대해 세 번 연속으로 DNS 룩업을 하면 다음 그림과 같이 IP 주소들의 목록을 세 번 순환한 결과를 얻게 된다.

![image.png](attachment:8f6ddd1b-4c0b-4e3b-82d1-71e265b8ee76:image.png)

- 첫 번째 DNS 룩업의 첫 번째 주소는 207.25.71.5이다.
- 두 번째 DNS 룩업의 첫 번째 주소는 207.25.71.6이다.
- 세 번째 DNS 룩업의 첫 번째 주소는 207.25.71.7이다.

**부하 균형을 위한 DNS 라운드 로빈**

대부분의 DNS 클라이언트는 그냥 첫 번째 주소를 사용하기 때문에, DNS 순환은 서버들 간의 부하 균형을 유지해준다.

만약 DNS가 주소를 순환시키지 않는다면, 대부분의 클라이언트가 목록의 첫 번째 서버를 선택할 것이고, 그 서버가 대부분의 부하를 받게 될 것이다.

![image.png](attachment:bd75b26d-f1ae-4ad4-94b0-2ef200864585:image.png)

**DNS 캐싱의 효과**

서버에 대한 각 DNS 룩업은 서버 주소를 다른 순서로 가져오기 때문에, DNS 주소 순환은 부하를 순환시킨다.

그러나 이 부하 균형은 완벽하지 않다.

DNS 룩업의 결과는 애플리케이션, 운영체제, 몇몇 기초적인 자식 DNS 서버에 의해 기억되어 재사용될 수 있기 때문이다.

호스트 하나에 대해 한 번의 DNS 룩업을 수행한 뒤, 그 주소를 몇 번이고 다시 사용한다. 그렇게 하면 DNS 룩업의 비용을 줄이고, 같은 클라이언트와 계속 대화하는 것을 선호하는 서버들도 있기 때문이다.

이러한 이유로 DNS 라운드 로빈은 일반적으로 하나의 클라이언트로 인한 부하를 제대로 분산하지 못한다. 

클라이언트는 보통 같은 서버에 꽤 오랫동안 매어 있게 될 것이다.

### 4.3 임의 캐스팅 어드레싱

### 4.4 아이피 맥 포워딩

### 4.5 아이피 주소 포워딩

아이피 주소 포워딩에서, 스위치나 다른 레이어 4를 이해하는 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 목적지 맥 주소가 아니라 목적지 아이피 주소의 변경에 따라 라우팅한다.

맥 포워딩보다 좋은 점 하나는 목적지 서버가 한 홉 거리에 있을 필요가 없다는 것이다.

그저 스위치에서 업스트림의 위치를 판별할 수만 있으면 일반적인 레이어-3 종단간(end-to-end) 인터넷 라우팅이 패킷을 올바른 위치로 보내준다. 

이러한 종류의 전달은 네트워크 주소 변환(Network Address Translation, NAT)이라고도 불린다.

![image.png](attachment:88a4cd86-c5d4-4612-9417-d165345b3beb:image.png)

- 패킷의 출발지 아이피 주소를 쉬이치의 아이피 주소로 바꾼다.
이 방법은, 스위치와 서버 사이의 네트워크 설정이 어떤가와는 관계 없이, 응답 패킷을 스위치로 가게 한다. 이 목적지와 출발지 아이피 주소 양쪽을 번역해주는 아이피 전달 장치를 완전 NAT라고 한다.
- 아래 그림은 TCP/IP 데이터그램에서의 완전 NAT의 효과를 보여준다. 그 결과, 인증이나 결제를 위해 필요할 수도 있는 클라이언트 아이피 주소를 웹 서버가 알 수 없게 된다.
    
    ![image.png](attachment:708ae7d5-b1f0-45ff-acea-ffe1183e57aa:image.png)
    
- 만약 출발지 아이피 주소가 그 클라이언트의 아이피 주소로 계속 남아있다면, (하드웨어의 관점에서) 서버에서 클라이언트로 바로 가는(스위치를 거치지 않고) 경로가 존재하지 않아야 한다. 
이는 때때로 반 NAT라고 불린다.
장점은 서버가 클라이언트 아이피 주소를 얻는다는 것이며, 단점은 클라이언트와 서버 사이의 네트워크 전체에 약간의 통제가  필요하다는 것이다.

## 5. 프락시 리다이렉션 방법

콘텐츠에 접근할 때 프락시를 통할 필요가 있는 경우도 있으며(아마 보안상의 이유로), 클라이언트가 이용하면 유익한 프락시 캐시가 네트워크에 있을 수도 있다.(캐시된 콘텐츠를 받는 것이 원 서버에 직접 가는 것보다 아마 훨씬 빠를 것이기 때문이다.)

웹브라우저와 같은 클라이언트들이 어떻게 프락시로 가는 길을 아는가?

세 가지 방법이 있다.

명시적인 브라우저 설정, 동적인 자동 설정, 자연스러운 가로채기.

프락시는 결과적으로 클라이언트의 요청을 다른 프락시로 리다이렉트할 수 있다.

예를 들어, 요청 받은 콘텐츠를 갖고 있지 않은 프락시 캐시는 클라이언트를 다른 캐시로 리다이렉트하는 것을 택할 것이다. 이는 클라이언트가 리소스를 요청한 곳과는 다른 곳에서 응답이 오도록 하게 되는 것이므로, 우리는 또한 피어 프락시 캐시 리다이렉션을 위해 사용되는 프로토콜인 인터넷 캐시 프로토콜(ICP), 캐시 배열 라우팅 프로토콜(CARP), 하이퍼텍스트 캐싱 프로토콜(HTCP)에 대해 논의할 것이다.

### 5.1 명시적 브라우저 설정

대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 폴다운 메뉴가 존재한다.

사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉한다. 

명시적 브라우저 설정은 두 가지 중요한 단점이 있다.

1. 프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않더라도 원 서버와 접촉하지 않는다. 만약 프락시가 다운되거나 브라우저가 잘못 설정되었다면, 사용자는 접속 문제를 경험할 것이다.
2. 네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종 사용자에게 전파하는 것이 어렵다. 
    
    만약 서비스 제공자가 더 많은 프락시를 추가하길 원하거나 몇 개를 서비스에서 제거하길 원한다면, 브라우저 사용자들은 그들의 프락시 설정을 변경해야만 할 것이다. 
    

### 5.2 프락시 자동 설정

특정 프락시에 접촉하기 위한 브라우저의 명시적인 설정은 네트워크 아키텍처의 변화를 제한하는데, 그 이유는 브라우저에 개입하여 설정을 변경하는 주체가 사용자이기 때문이다.

올바른 프락시 서버에 접촉하기 위해 브라우저가 동적으로 자신을 설정할 수 있게 하는 자동 설정 방법은 이 문제를 해결한다.

이 방법은 프락시 자동 설정(Proxy Auto-configuration, PAC) 프로토콜이라고 불린다.

PAC 에 깔려있는 기본 아이디어는, 브라우저들이 URL 별로 접촉해야 할 프락시를 지정한 PAC 파일이라 불리는 특별한 파일을 찾도록 하는 것이다.

브라우저는 반드시 PAC 파일을 얻기 위해 지정된 서버에 접촉핟로고 설정되어야 한다. 그런 뒤에 브라우저는 재시작 때마다 PAC  파일을 가져온다. 

브라우저는 요청된 URL 마다 PAC 파일의 자바스크립트 파일을 호출한다.

반환된 값은 브라우저가 어디서 이 URL을 요청해야 하는지 지정한 문자열이다.

접촉할 프락시들의 목록이거나, 브라우저가 어떤 프락시든 우회해서 원 서버로 바로 가야함을 의미하는 문자열 ‘DIRECT’ 일 수도 있다.

브라우저는 함수를 호출하고 반환된값이 알려주는 곳으로 접속한다.

![image.png](attachment:3c19656e-c6b6-4c5d-a66a-f9b4a9894066:image.png)

자바스크립트 프로그램은 브라우저에게, DNS 주소나 서브넷, 요일이나 시각과 같은 호스트 명과 관련된 여러 매개변수에 근거하여 프락시를 선택하도록 요구할 수 있다.

프락시의 위치가 변경된 경우 이를 반영하기 위해 PAC 파일이 서버에서 업데이트되기 때문에 PAC는 브라우저가 자동으로 네트워크 아키텍처 안에서의 변경에 맞는 올바른 프락시에 접촉할 수 있도록 할 수 있다.

### 5.3 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

웹 프락시 자동발견 프로토콜(WPAD)은 최종 사용자가 수동으로 프락시 설정을 할 필요도, 투명한 트래픽 인터셉트에 의존할 필요도 없이 웹브라우저가 근처의 프라깃를 찾아내어 사용할 수 있게 해주는 방법을 제공하는 것을 목적으로 하고 있다.

웹 프락시 자동발견을 위해 프로토콜을 정하는 일반적인 문제는 선택할 수 있는 발견 프로토콜이 여러 가지 존재한다는 것과 프락시 사용에 대한 설정이 브라우저들마다 차이가 있다는 것 때문에 복잡해진다.

**PAC 파일 자동 발견**

WPAD는 HTTP 클라이언트가 PAC 파일의 위치를 알아내고 그 파일을 이용해서 적절한 프락시 서버의 이름을 알아낼 수 있게 해준다.

WPAD는 직접적으로 프락시 서버의 이름을 알아내지는 않는데, 그렇게 하면 PAC 파일에 의해 제공되는 추가적인 기능들(부하 균형, 서버들의 배열로 요청 라우팅, 프락시 서버를 보조하기 위한 자동화된 장애 시의 대체 작동 등)이 활용될 수 없기 때문이다.

그림과 같이, WPAD 프로토콜은 설정 URL(CURL)이라고도 알려진 PAC 파일 URL을 발견한다. 이 PAC 파일은 적절한 프락시 서버의 주소를 반환하는 자바스크립트 프로그램을 실행한다.

![image.png](attachment:edf07ae5-60eb-4f9b-97cd-58e8661ddb26:image.png)

WPAD 프로토콜을 구현한 HTTP 클라이언트는 다음의 일을 한다.

- WPAD를 이용해 PAC 파일 CURL을 찾는다.
- URL에 해당하는 PAC 파일(설정파일 혹은 CFILE이라고도 알려진)을 가져온다.
- 프락시 서버를 알아내기 위해 그 PAC 파일을 실행한다.
- PAC 파일이 반환한 프락시 서버에게 HTTP 요청을 보낸다.

## 6. 캐시 리다이렉션 방법

## 7. 인터넷 캐시 프로토콜

인터넷 캐시 프로토콜(ICP)는 캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있도록 해준다.

캐시가 HTTP 메시지에서 요청한 콘텐츠를 갖고 있지 않다면, 캐시는 근처의 형제 캐시 중 그 콘텐츠를 갖고 있는 것이 있는지 찾아보고 만약 있다면 원 서버에 질의하는 것보다 비용이 더 들지 않을 것을 기대하며 그 캐시에서 콘텐츠를 가져온다. 

ICP는 일종의 캐시 클러스터링 프로토콜이라고 할 수 있다.

한 차례 이상의 ICP 질의를 통해 HTTP 요청 메시지의 최종 목적지를 결정할 수 있다는 점에서 볼 때 이 프로토콜은 리다이렉션 프로토콜이다. 

ICP는 객체 발견 프로토콜이다. 캐시는 이 프로토콜을 사용해 근처의 캐시 모두에게 특정 URL을 갖고 있는지 한번에 물어본다.

근처의 캐시들은 그 URL을 갖고 있다면 ‘HIT’, 아니라면 ‘MISS’라고 짧은 메시지로 답한다.

그러면 물어본 캐시는 그 객체(URL)을 갖고 있는 이웃 캐시에 대한 HTTP 커넥션을 열 수 있다.

## 8. 캐시 배열 라우팅 프로토콜

프락시 서버는 사용자 개개인으로부터의 요청을 가로채어 요청한 웹 객체의 캐시된 사본을 제공함으로써 인터넷으로 향하는 트래픽을 대폭 줄여준다. 

그러나 사용자의 증가에 따라, 대량의 트래픽은 프락시 서버 자체에 과도한 부하를 줄 수 있다.

이 문제에 대한 해결책 중 하나는 부하를 분산하기 위해 사용하는 프락시 서버를 여러 대로 늘리는 것이다.

캐시 배열 라우팅 프로토콜(CARP)은, 프락시 서버의 배열이 클라이언트의 시점에서는 마치 하나의 논리적인 캐시처럼 보이도록 관리해주는 표준이다.

CARP는 ICP의 대안이다.

둘 다 관리자가 여러 대의 프락시 서버를 사용하여 성능을 개선할 수 있게 해준다.

ICP에서 캐시 비적중이 발생하면, 프락시 서버는 웹 객체의 가용성을 판단하기 위해 이웃 캐시들에게 ICP 메시지 포맷을 사용해서 질의를 보낸다. 

이웃의 캐시들은 ‘HIT’ 이나 ‘MISS’로 응답하고 요청한 프락시 서버는 이 응답을 이용해서 객체를 받아올 가장 적절한 위치를 선택한다.

만약 ICP 프락시 서버들이 계층적으로 구성되어 있다면, 비적중은 부모에게 상향 전파된다. 

![image.png](attachment:20e8bcd5-e979-4d67-9a37-617fd6384259:image.png)

ICP 프로토콜로 서로 연결된 프락시 서버들 각각은 콘텐츠의 쓸데없는 복제본도 갖고 있는, 다시 말해 프락시 서버들 전체에 걸친 웹 객체에 대한 중복된 엔트리가 허용되는 독립적인 캐시임에 주목하라.

대조적으로, CARP를 이용해서 독자적으로 동작하는 서버들의 무리는, 각 구성요소 서버가 전체 캐시된 문서의 일부만 갖고 있는 하나의 큰 서버처럼 동작한다.

웹 객체의 URL에 해시 함수를 적용함으로써, CARP는 웹 객체를 특정 프락시 서버에 매핑한다.

하나의 웹 객체는 하나의 프락시 서버에만 속하기 때문에, 프락시 서버 각각을 폴링하지 않고도 한 번의 검색으로 그 객체의 위치를 결정할 수 있다. 

![image.png](attachment:8560e102-2e98-43cb-9799-7bc18f57c26f:image.png)

그림은, 클라이언트와 프락시 서버 사이의 중개자로서 부하를 여러 프락시 서버로 분산하는 캐싱 프락시를 보여주고 있지만, 클라이언트들 스스로가 이 기능을 제공하는 것도 가능하다.

CARP에서 프락시 서버 분석이 결정론적이라는 것은 질의를 모든 이웃에게 보낼 필요는 없다는 뜻이고, 이는 캐시가 주고받아야 하는 메시지가 더 적음을 의미한다. 

더 많은 프락시 서버가 설정에 추가됨에 따라, 그 집단 캐시 시스템은 상당히 괜찮게 확장될 것이다.

그러나, CARP는 프락시 서버 중 하나가 사용할 수 없게 되면, 이 사실을 반영하기 위해 해시 함수가 수정되어야 하고, 프락시 서버 전체에 퍼져 있는 콘텐츠들도 다시 배치하지 않을 수 없다는 단점이 있다.

프락시 서버의 고장이 잦다면 이로 인한 비용은 상당히 비쌀 수 있다. 반면 ICP 프락시 서버들에는 콘텐츠가 중복되어 존재하므로 다시 배치할 필요가 없다. 또한, CARP는 새로운 프로토콜이므로 ICP 프로토콜만을 수행하는 기존 프락시 서버는 CARP 무리에 쉽게 포함될 수 없을 것이라는 점이 또 하나의 문제점이다. 

요약하면, CARP 프로토콜은 협력을 하지만 분산된 캐시가 되는 ICP와는 달리 프락시 서버 그룹을 하나의 캐시 집단으로 보이게 해준다. 결정론적인 요청 분석 경로는 한 홉 안에 있는 특정 웹 객체의 거처를 찾아낸다. 이것은 ICP에서 프락시 서버의 그룹 안에 있는 웹 객체를 찾아내기 위해 자주 생성되는 프락시 간 트래픽을 제거한다.

CARP는 또한 중복된 웹 캐시에 대한 사본의 중복을 피하게 되는데, 이로 인해 캐시 시스템이 집합적으로 웹 객체를 더 많이 보관할 수 있다는 점이 있는 반면, 어느 하나의 프락시가 실패하더라도 상당량의 캐시 콘텐츠를 재배치해야 한다는 단점도 있다.

## 9. 하이퍼텍스트 캐싱 프로토콜

ICP는 프락시 캐시가 형제들에게 문서의 존재 여부에 대해 질의하도록 해주는 프로토콜이다. 그러나 ICP 는 HTTP/0.9를 염두에 두고 설계되었기 때문에 캐시가 리소스의 존재 여부를 질의할 때 URL 만을 보내도록 하고 있다.

HTTP 버전 1.0과 1.1은 URL과 더불어 문서 매칭에 대한 판단을 내릴 때 사용될 수 있는 많은 요청 헤더들을 도입했기 때문에, 단순히 요청의 URL만을 보내는 것은 정확한 응답을 가져오지 못하는 결과를 가져올 수 있다.

하이퍼텍스트 캐싱 프로토콜(Hyper Text Caching Protocol, HTCP)은 형제들이 URL과 모든 요청 및 응답 헤더를 사용하여 서로에게 문서의 존재 여부에 대한 질의를 할 수 있도록 해줌으로써 적중이 아님에도 적중으로 잘못 처리될 확률을 줄인다. 

더 나아가, HTCP는 형제 캐시들이 서로의 캐시 안에 있는 선택된 문서의 추가 및 삭제를 모니터링하고 요청할 수 있게, 그리고 서로의 캐시된 문서에 대한 캐싱 정책을 변경할 수 있게 해준다.

HTCP 메시지 구조

- 헤더: 메시지의 길이와 버전 포함
- 데이터: OP 코드를 포함한 데이터의 길이로 시작하여, 응답 코드, 몇몇 태그들과 아이디들이 이어지며 실제 데이터로 끝남.

![image.png](attachment:1495d184-f45e-4415-b5f3-89557ec8e211:image.png)

### 9.2 캐싱 정책 설정

SET 메시지는 캐시가 캐시된 문서에 대한 정책 변경을 요청할 수 있게 해준다.

SET 메시지에서 사용될 수 있는 이 헤더들은 다음 표에 서술되어 있다.

![image.png](attachment:5e3f68a3-b7f6-4ad1-b830-c9931913a829:image.png)

![image.png](attachment:95de3df5-649c-4aa5-bc7c-cf7e733a0b9c:image.png)
