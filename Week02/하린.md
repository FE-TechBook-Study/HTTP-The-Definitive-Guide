# 3장. HTTP 메시지

## 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.  
이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.

- 인바운드 : 메시지가 원 서버로 향하는 것
- 아웃바운드 : 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP 메시지는 요청/응답에 관계없이 모든 메시지는 다운스트림으로 흐른다. 메시지의 발송자는 수신자의 업스트림이다.

## 3.2 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록으로 시작줄, 헤더 블록, 본문 세 부분으로 이루어진다.

시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다. 각 줄은 캐리지 리턴(CR, "\r")과 개행 문자(LF, "\n")로 구성된 두 글자의 줄바꿈 문자열로 끝난다. 이 문자열은 "CRLF"라고 쓴다.  
헤더의 목록은 빈줄로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.
본문은 선택적인 데이터로 텍스트나 이진 데이터를 포함할 수도 있고 비어있을 수도 있다.  
헤더나 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄로 끝나야한다.

### 3.2.1 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.  
응답 메시지는 웹 서버에 어떤 동작을 요구한다. 응답 메시지는 요청의 결과를 클라에게 돌려준다. 둘 다 기본적으로 구조가 같다.

**요청 메시지 형식**

```text
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>

ex) GET /test/hi-there.txt HTTP 1.1
    _______________________________
    Accept: text/*
    Host: www.joes-hardware.com

    _______________________________
```

**응답 메시지 형식**

```text
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>

ex) HTTP/1.0 200 OK
    _______________________________
    Content-type: text/plain
    Content-length: 19

    _______________________________
    Hi! I'm a message!
```

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작한다.  
요청 메시지는 무엇을 해야하는지, 응답 메시지는 무슨일이 일어났는지 말해준다.

#### 요청줄

서버에서 어떤 동작이 일어나야 하는지 설명해주는 **메서드**와 그 동작에 대한 대상을 지칭하는 요청 **URL**이 들어있다.  
클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 **HTTP 버전**도 포함한다.

#### 응답줄

수행 결과에 대한 상태 정보와 결과 데이터를 클라에게 돌려준다.  
응답 메시지에서 쓰인 **HTTP의 버전, 숫자로된 상태 코드, 사유 구절**이 들어있다.

#### 메서드

요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.

| 메서드  | 설명                                                    | 메시지 본문이 있는가? |
| ------- | ------------------------------------------------------- | --------------------- |
| GET     | 서버에서 어떤 문서를 가져온다.                          | 없음                  |
| HEAD    | 서버에서 어떤 문서에 대해 헤더만 가져온다.              | 없음                  |
| POST    | 서버가 처리해야 할 데이터를 보낸다.                     | 있음                  |
| PUT     | 서버에 요청 메시지의 본문을 저장한다.                   | 있음                  |
| TRACE   | 메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적한다. | 없음                  |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | 없음                  |
| DELETE  | 서버에서 문서를 제거한다.                               | 없음                  |

#### 상태코드

클라에게 무엇이 일어났는지 말해준다. 응답의 시작줄에 위치.  
상태 코드들은 세 자리 숫자로 된 코드값을 기준으로 묶인다.
| 전체 범위 | 정의된 범위 | 분류 |
|-----------|-------------|----|
| 100-199 | 100-101 | 정보 |
| 200-299 | 200-206 | 성공 |
| 300-399 | 300-305 | 리다이렉션 |
| 400-499 | 400-415 | 클라이언트 에러 |
| 500-599 | 500-505 | 서버 에러 |

#### 사유 구절

응답 시작줄의 마지막 구성요소. 상태 코드에 대한 글로된 설명을 제공한다.

#### 버전 번호

HTTP/x.y 형식으로 요청과 응답 메세지 양쪽 모두에 기술된다. HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.  
버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다. HTTP/1.1로 된 응답을 받았을 때 이는 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있음을 의미한다.

버전의 각 숫자는 분리된 숫자로 다루어진다. 어느 쪽이 더 큰지 버전을 비교할 때 각 숫자는 따로따로 비교해야 한다. 예를 들어 HTTP/2.22 는 HTTP/2.3 보다 크다

### 3.2.3 헤더

시작줄 다음에 오는 HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적으로 이름/값 쌍의 목록이다.  
헤더는 간단한 문법을 가진다. 이름, 쉼표, 공백(없어도 됨), 필드 값, CRLF가 순서대로 온다.

### 3.2.4 엔터티 본문

본문은 HTTP 메시지의 화물이라고 할 수 있다. 이미지, 비디오, HTML 문서, 소프트웨어 어플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

## 3.3 메서드

### 3.3.1 안전한 메서드

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다. GET, HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD를 사용하는 HTTP 요청의 결과로 **서버에 어떤 작용도 없음**을 의미한다.  
안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다. (ex. 경로 alert)

### 3.3.2 GET

서버에게 리소스를 달라고 요청하기 위해 쓰인다.

### 3.3.3 HEAD

GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. 클라이언트가 리소스를 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)를 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인
- 헤더를 확인하여 리소스가 변경되었는지 검사

서버 개발자들은 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

### 3.3.4 PUT

서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계되었다. HTML 폼을 지원하기 위해 흔히 사용된다.

### 3.3.6 TRACE

클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.  
TRACE 요청은 목적지 서버에서 loopback 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 그렇다면 어떻게 변경되었는지 확인할 수 있다.

### 3.3.7 OPTIONS

웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

### 3.3.8 DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

## 3.4 상태 코드

상태 코드는 크게 다섯 가지로 나뉜다.

### 3.4.1 100-199: 정보성 상태 코드

| 코드 | 상태                | 설명                                                                              |
| ---- | ------------------- | --------------------------------------------------------------------------------- |
| 100  | Continue            | 클라이언트가 서버로 요청을 계속 보내도 된다는 의미                                |
| 101  | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸겠다는 의미 |

### 100 Continue 상세 설명

100 Continue는 HTTP/1.1에서 클라이언트와 서버 간의 효율적인 통신을 위해 도입된 메커니즘입니다.

**작동 방식:**

1. 클라이언트가 큰 요청 본문을 보내기 전에 서버가 요청을 받을 수 있는지 확인하고 싶을 때 사용
2. 클라이언트는 `Expect: 100-continue` 헤더를 포함한 요청을 보냄
3. 서버가 요청을 처리할 수 있다면 `100 Continue` 응답을 보냄
4. 클라이언트는 이 응답을 받은 후 실제 요청 본문을 전송

**사용 시나리오:**

- 대용량 파일 업로드 시 서버의 용량이나 권한을 미리 확인
- 네트워크 대역폭을 절약하고 불필요한 데이터 전송 방지
- 서버가 요청을 거부할 가능성이 있는 경우 사전 검증

**예시:**

```http
POST /upload HTTP/1.1
Host: example.com
Content-Length: 1024000
Expect: 100-continue

(서버 응답: HTTP/1.1 100 Continue)
(클라이언트가 실제 데이터 전송)
```

### 3.4.2 200-299: 성공 상태 코드

| 코드 | 상태                          | 설명                                                                           |
| ---- | ----------------------------- | ------------------------------------------------------------------------------ |
| 200  | OK                            | 요청이 정상적으로 처리됨                                                       |
| 201  | Created                       | 새로 생성된 리소스가 만들어짐 (주로 POST 요청에 대한 응답)                     |
| 202  | Accepted                      | 요청이 받아들여졌지만 아직 처리가 완료되지 않음                                |
| 203  | Non-Authoritative Information | 엔티티 헤더 정보가 원래 서버가 아닌 로컬이나 제3자로부터 받은 정보             |
| 204  | No Content                    | 서버가 요청을 성공적으로 처리했지만 엔티티 본문을 포함하지 않음                |
| 205  | Reset Content                 | 서버가 요청을 성공적으로 처리했지만 클라이언트에게 화면을 새로 고침하라고 알림 |
| 206  | Partial Content               | 클라이언트에서 범위 요청을 했을 때 서버가 부분적으로 GET 요청을 받았음         |

### 3.4.3 300-399: 리다이렉션 상태 코드

| 코드 | 상태               | 설명                                                                        |
| ---- | ------------------ | --------------------------------------------------------------------------- |
| 300  | Multiple Choices   | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청했을 때 그 목록을 반환 |
| 301  | Moved Permanently  | 요청한 URL이 영구적으로 새로운 곳으로 이동됨                                |
| 302  | Found              | 요청한 리소스가 일시적으로 다른 URL에 있음                                  |
| 303  | See Other          | 클라이언트에서 리소스를 다른 URL에서 가져와야 한다고 알려줄 때 사용         |
| 304  | Not Modified       | 클라이언트가 보낸 조건부 요청에서 리소스가 수정되지 않았음                  |
| 305  | Use Proxy          | 리소스에 반드시 프록시를 통해서 접근해야 함                                 |
| 307  | Temporary Redirect | 302와 비슷하지만 요청 메서드를 변경하지 않고 임시 리다이렉트                |

### 3xx 리다이렉션 상세 설명

리다이렉션은 웹에서 URL 변경, 로드 밸런싱, 캐싱 등을 위해 사용되는 중요한 메커니즘입니다.

#### 301 vs 302 vs 307의 차이점

**301 Moved Permanently (영구 이동):**

- URL이 영구적으로 변경됨
- 검색 엔진이 새 URL로 인덱스를 업데이트
- 브라우저가 북마크를 업데이트할 수 있음
- 캐시가 가능하여 이후 요청 시 직접 새 URL로 이동

**302 Found (임시 이동):**

- URL이 일시적으로만 변경됨
- 원래 URL이 나중에 다시 사용될 예정
- 검색 엔진이 원래 URL을 유지
- HTTP/1.0에서는 POST → GET으로 메서드가 바뀔 수 있음

**307 Temporary Redirect (임시 리다이렉트):**

- 302와 비슷하지만 HTTP/1.1에서 명확히 정의됨
- 요청 메서드와 본문을 반드시 그대로 유지
- POST 요청이면 새 URL에서도 POST로 처리

#### 304 Not Modified

304는 조건부 요청(Conditional Request)의 결과입니다:

1. **클라이언트가 캐시된 리소스와 함께 조건부 헤더를 보냄:**

   - `If-Modified-Since`: 특정 날짜 이후 수정되었는지 확인
   - `If-None-Match`: ETag 값과 비교하여 변경되었는지 확인

2. **서버가 리소스를 확인:**

   - 리소스가 변경되지 않았다면 304 응답
   - 리소스가 변경되었다면 200과 함께 새 리소스 전송

3. **클라이언트 동작:**
   - 304를 받으면 캐시된 리소스를 사용
   - 네트워크 대역폭과 서버 부하 절약

**예시:**

```http
GET /image.jpg HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT

HTTP/1.1 304 Not Modified
(본문 없음, 클라이언트는 캐시된 image.jpg 사용)
```

### 3.4.4 400-499: 클라이언트 오류 상태 코드

| 코드 | 상태                            | 설명                                                           |
| ---- | ------------------------------- | -------------------------------------------------------------- |
| 400  | Bad Request                     | 클라이언트의 잘못된 요청                                       |
| 401  | Unauthorized                    | 리소스 접근 전 인증이 필요함                                   |
| 402  | Payment Required                | 결제가 필요함 (현재 미사용, 미래를 위해 예약)                  |
| 403  | Forbidden                       | 요청이 서버에 의해 거부됨 (권한 없음)                          |
| 404  | Not Found                       | 요청한 리소스를 찾을 수 없음                                   |
| 405  | Method Not Allowed              | 요청한 URL에 대해 지원하지 않는 메서드                         |
| 406  | Not Acceptable                  | 클라이언트가 수용 가능한 응답을 서버가 생성할 수 없음          |
| 407  | Proxy Authentication Required   | 프록시 인증이 필요함                                           |
| 408  | Request Timeout                 | 요청 시간 초과                                                 |
| 409  | Conflict                        | 요청이 리소스와 충돌을 일으킴                                  |
| 410  | Gone                            | 리소스가 영구적으로 사라짐 (404와 달리 과거에 존재했음을 의미) |
| 411  | Length Required                 | Content-Length 헤더가 필요함                                   |
| 412  | Precondition Failed             | 조건부 요청의 조건이 실패함                                    |
| 413  | Request Entity Too Large        | 요청 엔티티가 너무 큼                                          |
| 414  | Request URI Too Long            | 요청 URI가 너무 김                                             |
| 415  | Unsupported Media Type          | 지원하지 않는 미디어 타입                                      |
| 416  | Requested Range Not Satisfiable | 요청한 범위를 만족시킬 수 없음                                 |
| 417  | Expectation Failed              | Expect 요청 헤더의 기대를 만족시킬 수 없음                     |

### 3.4.5 500-599: 서버 에러 상태 코드

| 코드 | 상태                       | 설명                                       |
| ---- | -------------------------- | ------------------------------------------ |
| 500  | Internal Server Error      | 서버 내부 오류                             |
| 501  | Not Implemented            | 서버가 요청 메서드를 지원하지 않음         |
| 502  | Bad Gateway                | 게이트웨이나 프록시에서 잘못된 응답을 받음 |
| 503  | Service Unavailable        | 서비스를 일시적으로 사용할 수 없음         |
| 504  | Gateway Timeout            | 게이트웨이나 프록시에서 시간 초과          |
| 505  | HTTP Version Not Supported | 지원하지 않는 HTTP 버전                    |

## 3.5 헤더

헤더와 메서드는 클라와 서버가 무엇을 하는지 결정하기 위해 사용된다.

- 일반 헤더 : 클라이언트와 서버 양쪽 모두가 사용
  - 예시: Date: Tue, 3 Oct 1974 02:16:00 GMT
- 요청 헤더 : 요청 메시지를 위한 헤더. 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공
  - 예시: User-Agent, Accept, Authorization
- 응답 헤더 : 클라이언트에게 정보를 제공하기 위한 헤더
  - 예시: Server, Location, Set-Cookie
- 엔터티 헤더: 엔터티 본문에 대한 헤더
  - 예시: Content-Type, Content-Length, Content-Encoding

### 3.5.1 일반 헤더 (General Headers)

| 헤더                     | 설명                                                                     |
| ------------------------ | ------------------------------------------------------------------------ |
| Connection               | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 지정할 수 있게 해줌     |
| Date                     | 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공함                   |
| MIME-Version             | 발송자가 사용한 MIME의 버전을 알려줌                                     |
| Trailer-chunked transfer | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열함     |
| Transfer-Encoding        | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 알려줌 |
| Upgrade                  | 발송자가 '업그레이드'하길 원하는 새 버전이나 프로토콜을 알려줌           |
| Via                      | 이 메시지가 어떤 중개자(프록시, 게이트웨이)를 거쳐 왔는지 보여줌         |

#### 일반 캐시 헤더

| 헤더          | 설명                                                             |
| ------------- | ---------------------------------------------------------------- |
| Cache-Control | 메시지와 함께 캐시 지시자를 전달                                 |
| Paragma       | 메시지와 함께 캐시 지시자를 전달하는 또 다른 방법. 캐시에 국한 x |

### 3.5.2 요청 헤더 (Request Headers)

요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나 클라이언트의 선호나 능력에 대한 정보를 준다.

#### 기본 요청 정보 헤더

| 헤더       | 설명                                                          |
| ---------- | ------------------------------------------------------------- |
| Client-IP  | 클라이언트가 실행된 컴퓨터의 IP를 제공함                      |
| From       | 클라이언트 사용자의 메일 주소를 제공함                        |
| Host       | 요청의 대상이 되는 서버의 호스트명과 포트를 줌                |
| Referer    | 현재의 요청 URI가 들어있었던 문서의 URL을 제공함              |
| UA-Color   | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보를 제공함   |
| UA-CPU     | 클라이언트 CPU의 종류나 제조사를 알려줌                       |
| UA-Disp    | 클라이언트의 디스플레이(화면) 능력에 대한 정보를 제공함       |
| UA-OS      | 클라이언트 기기에서 동작 중인 운영체제의 이름과 버전을 알려줌 |
| UA-Pixels  | 클라이언트 기기 디스플레이에 대한 픽셀 정보를 제공함          |
| User-Agent | 요청을 보낸 애플리케이션의 이름을 서버에게 알려줌             |

#### Accept 관련 헤더

Accept 관련 헤더들은 클라이언트가 서버에게 자신이 어떤 것을 원하는지 알려주는 역할

| 헤더            | 설명                                                |
| --------------- | --------------------------------------------------- |
| Accept          | 서버에게 서버가 보내도 되는 미디어 종류를 알려줌    |
| Accept-Charset  | 서버에게 서버가 보내도 되는 문자집합을 알려줌       |
| Accept-Encoding | 서버에게 서버가 보내도 되는 인코딩을 알려줌         |
| Accept-Language | 서버에게 서버가 보내도 되는 언어를 알려줌           |
| TE              | 서버에게 서버가 보내도 되는 확장 전송 코딩을 알려줌 |

**Accept 헤더 예시:**

```http
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
Accept-Language: ko-KR, ko;q=0.9, en-US;q=0.8, en;q=0.7
Accept-Encoding: gzip, deflate, br
```

#### 조건부 요청 헤더

조건부 요청 헤더는 캐싱과 효율적인 리소스 관리를 위해 사용됩니다.

| 헤더                | 설명                                                                           |
| ------------------- | ------------------------------------------------------------------------------ |
| Expect              | 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해줌                   |
| If-Match            | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하는 경우에만 문서를 가져옴      |
| If-Modified-Since   | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한함                    |
| If-None-Match       | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하지 않는 경우에만 문서를 가져옴 |
| If-Range            | 문서의 특정 범위에 대한 요청을 할 수 있게 해줌                                 |
| If-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되지 않은 경우에만 요청을 제한함               |
| Range               | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청함                |

**조건부 요청 예시:**

```http
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Range: bytes=200-1023
```

#### 요청 보안 헤더

| 헤더          | 설명                                                                                                           |
| ------------- | -------------------------------------------------------------------------------------------------------------- |
| Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있음                                            |
| Cookie        | 클라이언트가 서버에게 토큰을 전달할 때 사용함. 진짜 보안 헤더는 아니지만, 보안에 영향을 줄 수 있는 것은 확실함 |
| Cookie2       | 요청자가 지원하는 쿠키의 버전을 알리는 데 사용함                                                               |

**인증 헤더 예시:**

```http
Authorization: Basic dXNlcjpwYXNzd29yZA==
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Cookie: sessionid=abc123; csrftoken=xyz789
```

#### 프록시 요청 헤더

| 헤더                | 설명                                                                                 |
| ------------------- | ------------------------------------------------------------------------------------ |
| Max-Forwards        | 요청이 원 서버로 향하는 과정에서 다른 프록시나 게이트웨이로 전달될 수 있는 최대 횟수 |
| Proxy-Authorization | Authorization과 같으나 프록시에서 인증을 할 때 쓰임                                  |
| Proxy-Connection    | Connection과 같으나 프록시에서 연결을 맺을 때 쓰임                                   |

### 3.5.3 응답 헤더 (Response Headers)

응답 헤더는 클라이언트에게 부가 정보를 제공한다. 누가 응답을 보내고 있는지, 응답자의 능력 등등

#### 기본 응답 정보 헤더

| 헤더        | 설명                                                                         |
| ----------- | ---------------------------------------------------------------------------- |
| Age         | 응답이 얼마나 오래되었는지                                                   |
| Public      | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록                        |
| Retry-After | 현재 리소스가 사용 불가능한 상태일 때, 언제 기능이 회복되는지 날짜 혹은 시간 |
| Server      | 서버 애플리케이션의 이름과 버전                                              |
| Title       | HTML 문서에서 주어진 것과 같은 제목                                          |
| Warning     | 사유 구절에 있는 것보다 더 자세한 경고 메시지                                |

**응답 헤더 예시:**

```http
Server: Apache/2.4.41 (Ubuntu)
Age: 3600
Retry-After: 120
```

#### 협상 헤더

| 헤더          | 설명                                                                        |
| ------------- | --------------------------------------------------------------------------- |
| Accept-Ranges | 서버가 자원에 대해 받아들일 수 있는 범위의 형태                             |
| Vary          | 서버가 확인해 보아야 하고 그렇기 때문에 응답이 달라질 수 있는 헤더들의 목록 |

**협상 헤더 예시:**

```http
Accept-Ranges: bytes
Vary: Accept-Encoding, User-Agent
```

#### 응답 보안 헤더

| 헤더               | 설명                                                                                                                |
| ------------------ | ------------------------------------------------------------------------------------------------------------------- |
| Proxy-Authenticate | 프록시에서 클라이언트로 보낸 인증요구의 목록                                                                        |
| Set-Cookie         | 진짜 보안 헤더는 아니지만, 보안에 영향을 줄 수 있음. 서버가 클라이언트를 인증할 수 있는 토큰을 설정하기 위해 사용함 |
| Set-Cookie2        | Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키. RFC 2965 Version 1의 쿠키를 설정할 때 사용                            |
| WWW-Authenticate   | 서버에서 클라이언트로 보낸 인증요구의 목록                                                                          |

**보안 응답 헤더 예시:**

```http
Set-Cookie: sessionid=abc123; Path=/; HttpOnly; Secure
WWW-Authenticate: Basic realm="Protected Area"
```

### 3.5.4 엔티티 헤더 (Entity Headers)

요청과 응답 양쪽 모두 나타날 수 있다.  
엔터티와 그 내용물에 대한, 개체의 타입부터 싲가해서 주어진 리소스에 대해 요청할 수 있는 유효한 메서드들까지 광범위한 정보를 제공한다.

#### 엔티티 정보 헤더

| 헤더     | 설명                                                                                                                              |
| -------- | --------------------------------------------------------------------------------------------------------------------------------- |
| Allow    | 이 엔티티에 대해 수행될 수 있는 요청 메서드들을 나열함                                                                            |
| Location | 클라이언트에게 엔티티가 실제로 어디에 위치하고 있는지 알려줌. 수신자에게 리소스에 대한 (아마도 새로운) 위치나 URL의 정보를 제공함 |

#### 콘텐츠 헤더

콘텐츠 헤더는 엔티티의 콘텐츠에 대한 구체적인 정보를 제공

| 헤더             | 설명                                                           |
| ---------------- | -------------------------------------------------------------- |
| Content-Base     | 본문에서 사용된 상대 URL을 절대시키기 위한 기준 URL            |
| Content-Encoding | 본문에 적용된 어떤 인코딩                                      |
| Content-Language | 본문을 이해하는데 가장 적절한 자연어                           |
| Content-Length   | 본문의 길이나 크기                                             |
| Content-Location | 리소스가 실제로 어디에 위치하는지                              |
| Content-MD5      | 본문의 MD5 체크섬(checksum)                                    |
| Content-Range    | 전체 리소스에서 이 엔티티가 해당하는 범위를 바이트 단위로 표현 |
| Content-Type     | 이 본문이 어떤 종류의 객체인지                                 |

**콘텐츠 헤더 예시:**

```http
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
Content-Encoding: gzip
Content-Language: ko-KR
```

#### 엔티티 캐싱 헤더

일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지 제공한다면, 엔터티 캐싱 헤더는 엔터니 캐싱에 대한 정보를 제공한다.

| 헤더          | 설명                                                             |
| ------------- | ---------------------------------------------------------------- |
| ETag          | 이 엔티티에 대한 엔티티 태그                                     |
| Expires       | 이 엔티티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
| Last-Modified | 가장 최근 이 엔티티가 변경된 일시                                |

**캐싱 헤더 예시:**

```http
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Expires: Thu, 01 Dec 1994 16:00:00 GMT
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```
