## 메시지의 흐름

### 1. 메세지는 서버 뱡향을 인바운드로 하여 송신

- HTTP에서는 메시지가 서버로 가는 쪽을 인바운드, 서버에서 클라이언트에게 오는 쪽을 아웃바운드라고 표현
- 클라이언트 → 서버 : **인바운드**
- 서버 → 클라이언트 : **아웃바운드** ![스크린샷 2025-06-23 오후 2.49.16.png](attachment:733a5fda-53f5-4778-af6d-979eea445915:스크린샷_2025-06-23_오후_2.49.16.png)

### 2. 다운스트림으로 흐르는 메시지

- 요청 응답 상관 없이 모든 메시지는다운 스트림으로 흐른다.
- 메시지의 발송자는 수신자의 업스트림이다. (이거 상대적)
- 보편적으로는 클라 → 서버 (업스트림), 서버→ 클라 (다운스트림) , 책에서는 단방향으로 흐른다는 걸 표현한듯 ![스크린샷 2025-06-23 오후 2.49.24.png](attachment:0e3330a0-6ac3-46c5-9454-fa139fe0d838:스크린샷_2025-06-23_오후_2.49.24.png)

## 메시지 구조

- 메시지는 시작줄, 헤더, 본문으로 구성된다.
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다.
- 분리는 `CRLF`라는 특별한 문자열로 구분된다.
- 메시지 본문은 시작줄, 헤더와 달리 원시 데이터가 들어갈 수 있음
  - HTML, JSON (텍스트)
  - IMAGE, PDF, VIDEO (바이너리)
  - 혹은 비어있거나
- 헤더의 Content-Length는 본문의 길이를 의미
  - `Content-Length: 348` = 348바이트

> **CRLF = `\r\n`**

- `\r`
  - 캐리지 리턴
  - 옛날 타자기의 줄 맨 앞으로 이동을 의미
- `\n`
  - 라인피드
  - 다음 줄로 이동을 의미
- 두 특수 문자를 합쳐서 진짜 줄바꿈으로 사용
- 레거시 중에는 `\n`만 쓰고나 `\r`만 쓰는 경우가 있음

> **왜 헤더, 시작줄에는 아스키만 사용되는가?**

- HTTP의 헤더와 시작줄은 모두 텍스트 기반 프로토콜로 설계됨
- 즉, 영어(아스키)만 사용 → 호환성과 단순성 때문

### 1. 메시지 문법

`요청 메시지`

```jsx
<메서드> <요청 URL> <버전>
<헤더>

<본문>
```

![스크린샷 2025-06-23 오후 3.38.27.png](attachment:223986e3-e467-4af5-a298-8b80bb790c72:스크린샷_2025-06-23_오후_3.38.27.png)

`응답메시지`

```jsx
<버전> <상태 코드> <사유 구절>
<헤더>

<본문>
```

![스크린샷 2025-06-23 오후 3.38.33.png](attachment:11a2bfa3-5c3a-4585-aa60-8c88bdcea2f6:스크린샷_2025-06-23_오후_3.38.33.png)

## 시작줄

- 모든 HTTP 메시지는 시작줄로 시작한다.
- 요청 메시지의 시작줄은 무엇을 해야하는지 알려준다.
- 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

### 1. 요청줄

- 서버에게 리소스에 대해 무언가를 해달라고 부탁하는 역할이다.
- 메서드, 요청 URL, HTTP 버전 포함

### 2. 응답줄

- HTTP 버전, 상태코드, 사유 구절 포함

### 3. 메서드

- 서버에게 무엇을 해야 하는지 말해주는 역할

| 메서드 | 한 줄 설명 | 주 용도 | 바디 포함 여부 |
| --- | --- | --- | --- |
| **GET** | 리소스 가져와줘 | 조회 | ❌ (보통 없음) |
| **POST** | 새 데이터 보내줄게 | 생성 / 처리 요청 | ✅ |
| **PUT** | 리소스 전체를 덮어써 | 전체 수정 | ✅ |
| **PATCH** | 리소스 일부만 바꿔줘 | 부분 수정 | ✅ |
| **DELETE** | 리소스 삭제해줘 | 삭제 | ✅ (보통 안씀) |
| **HEAD** | GET처럼 헤더만 줘 | 존재 확인 / 메타정보 | ❌ |
| **OPTIONS** | 뭘 지원하는지 알려줘 | CORS 사전 요청 등 | ✅ (보통 비워둠) |
| **TRACE** | 내 요청 그대로 되돌려줘 | 진단/디버깅용 | ❌ |
| **CONNECT** | 터널 만들어줘 | 프록시 터널링 (HTTPS) | ✅ |

- `HEAD`
  - `GET`처럼 동작하지만, 본문 없이 헤더만 반환
  - 파일 크기나 타입 같은 메타데이터 확인
  - 리소스 존재 여부와 리소스 변경 여부 확인 (etag)
- `OPTIONS`

  - "이 URL 또는 이 서버가 어떤 **HTTP 메서드와 헤더**를 허용하냐?" 물어봄
  - CORS 사전 요청 예시

    ```jsx
    // CORS 사전 요청
    OPTIONS /api/user HTTP/1.1
    Host: example.com
    Origin: https://frontend.example.com
    Access-Control-Request-Method: PUT
    Access-Control-Request-Headers: Authorization, Content-Type

    // 서버 응답
    HTTP/1.1 204 No Content
    Access-Control-Allow-Origin: https://frontend.example.com
    Access-Control-Allow-Methods: GET, POST, PUT
    Access-Control-Allow-Headers: Authorization, Content-Type

    ```

- `TRACE`

  - 내 요청을 그대로 돌려줘~ 하는 요청
  - 네트워크에서 요청을 추적 → 디버깅용도로 사용
  - 보통 프록시나 게이트웨이 거치면서 메시지가 어떻게 변경되었는지 확인
  - 보통 보안상 문제로 비활성화하거나 `405 Method Not Allowed`로 막음

  ```jsx
  // 요청
  TRACE /test HTTP/1.1
  Host: example.com
  User-Agent: TestClient/1.0

  // 응답
  HTTP/1.1 200 OK
  Content-Type: message/http // http message

  TRACE /test HTTP/1.1
  Host: example.com
  User-Agent: TestClient/1.0 // 이게 변했을 수도 있음
  ```

- `CONNECT`

  - 클라이언트가 서버로 TCP 터널을 열어달라고 요청
  - 주로 프록시 서버가 HTTPS 트래픽을 중계할 때 사용

  ```jsx
  // 요청
  GET /api/status HTTP/1.1
  Host: example.com
  Connection: close

  // 응답
  HTTP/1.1 200 OK
  Content-Type: application/json
  Connection: close

  { "status": "ok" }
  ```

  - 보통 `keep-alive`가 디폴트지만 `close`를 사용해야할 경우 사용됨
    - 서버 리소스가 부족해서 연결 오래 유지 못할 때
    - 프록시나 게이트웨이가 일정 시간 지나면 연결 끊고 싶을 때
    - 클라이언트가 요청 하나만 보낼 거 확실할 때

## HTTP 상태코드

- `100번대`
  - HTTP 100번대 상태 코드는 **"정보(Informational)" 응답**을 나타내며,
  - 클라이언트가 요청을 계속 진행해도 된다는 **임시 응답이다.** | 상태 코드 | 의미 | 설명 | | --- | --- | --- | | **100 Continue** | 계속 진행 | 클라이언트가 `Expect: 100-continue` 헤더를 보낸 경우, 서버가 요청 헤더를 수신했고, 본문도 보내도 된다는 뜻. 대용량 요청 본문 업로드 전에 유용. | | **101 Switching Protocols** | 프로토콜 전환 | 클라이언트가 `Upgrade` 헤더로 프로토콜 변경 요청했고, 서버가 그걸 수락. 예: HTTP/1.1 → WebSocket | | **102 Processing** (WebDAV) | 처리 중 | 요청은 수락되었고 처리 중이나, 아직 응답을 보낼 준비가 되지 않았음을 의미 (RFC 2518). 긴 작업에서 유용. | | **103 Early Hints** | 사전 힌트 | 본 응답 전에 일부 헤더를 미리 제공해 클라이언트가 preload 등의 작업을 빠르게 시작할 수 있도록 도움 (예: 링크 프리로드). |
- `200번대`
  ### 200
  - 그냥 성공
  ### 201
  - 리소스 생성
  - 보통 헤더`location`에 리소스 정보 넣어줌.
  ### 202
  - 요청이 접수되었으나 처리가 완료되지 않음
  - 배치 처리 / 리포트 생성 등
  ### 204
  - 요청은 성공했지만 응답 보낼 데이터가 없는 경우
  - 저장 / 좋아요 / 로그아웃 등
- `300번대` 요청을 완료하기 위해 유저의 추가적인 조치 필요한 경우
  ### 리다이렉션
  웹 브라우저는 `3xx` 응답의 결과에 `Location` 헤더가 있으면, Location 위치로 자동으로 이동한다. 다만 일반 브라우저 요청(전체 페이지 이동. 새로고침)이 아닌 AJAX, Fetch 요청은 수동으로 이동시켜야한다. 추가적으로 fetch 같은 경우는 기본적인 설정으로 리다이렉션이 활성화 되어있다. (페이지 이동 아님)
  ### 301 (영구 리다이렉션)
  - 리소스 URI 영구적으로 이동
  - 원래 URL 사용하면 안됨. SEO에서도 변경 인지
  - 리다이렉트시 요청 메서드가 `GET`으로 변하고, 본문이 제거될 수 있음.
  ### 308 (영구 리다이렉션)
  - 301과 기능은 같음
  - 리다이렉트시 요청 메서드와 본문 유지
  ### 302 (일시적인 리다이렉션)
  - 리소스의 URI가 일시적으로 변경
  - 검색 엔진 등에서 URL 변경하면 안됨
  - 리다이렉트시 요청 메서드가 `GET`으로 변하고, 본문이 제거될 수 있음.
  ### 307 (일시적인 리다이렉션)
  - 302와 기능은 같음
  - 리다이렉트시 요청 메서드와 본문 유지. 요청 메서드를 변경하면 절대 안됨.
  ### 303 (일시적인 리다이렉션)
  - 302와 기능은 같음
  - 리다이렉트시 요청 메서드가 `GET`으로 변경
  ### 304
  - 캐시 목적으로 사용
  - 클라이언트에게 리소스가 수정되지 않았음을 알려줌.
  - 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시 리다이렉트)
  - 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로
  - 조건분 GET, HEAD 요청시 사용
- `400번대`
  ### 400
  - 클라 잘못
  ### 401
  - 인증되지 않음.
  - `WWW-Authenticate` 헤더와 함께 인증 방법을 설명
  ### 403
  - 서버가 요청을 이해했지만 승인을 거부
  - 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우 (짜바리가 어드민 서비스 접근)
- `500번대`
  - 케빈,든 호출
  - 재시도하면 성공할 수도?
  ### 503 서비스 이용 불가
  - 서버가 일시적인 과부하 또는 잠시 요청 처리불가
  - `Retry-After` 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음

### ETag

- 서버가 리소스의 버전 정보를 클라이언트에게 제공하는 HTTP 헤더

```jsx
ETag: "abc123"  ← 이게 리소스 버전 식별자
```

- 클라이언트는 다시 요청할 때 `If-None-Match` 조건부 요청 헤더로 ETag를 보냄

```jsx
If-None-Match: "abc123"
```

- 서버는 다음 중 하나로 응답

  - 리소스 변경되지 않았다면 → 클라 캐시 데이터 재사용

  ```jsx
  HTTP/1.1 304 Not Modified
  ```

  - 리소스 변경되었으면

  ```jsx
  HTTP/1.1 200 OK
  ETag: "xyz789"

  새로운 응답 본문 전달
  ```
