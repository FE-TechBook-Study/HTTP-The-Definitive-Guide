# 민지

# 3장

# **3장 HTTP 메시지**

## **3.1 메시지의 흐름**

- HTTP 메세지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.
- 이 데이터의 블록들은 메세지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.

### **3.1.1 메세지는 원 서버 방향을 인바운드로 하여 송신된다.**

- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 인바운드 : 메세지가 원 서버로 향하는 것
- 아웃바운드 : 모든 처리가 끝난 뒤에 메세지가 사용자 에이전트로 돌아오는 것

---

### **3.1.2 다운스트림으로 흐르는 메세지**

- 요청 메세지, 응답 메세지에 관계없이 모든 메세지는 다운스트림으로 흐른다.
- 메세지의 발송자는 수신자의 업스트림이다.

## **3.2 메세지의 각 부분**

- 메세지는 시작줄, 헤더 블록, 본문 세 부분으로 이루어진다.
- 시작줄은 이것이 어떤 메세지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있으며 본문은 아예 없을 수도 있다.
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다. 각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)로 구성된 두 글자의 줄바꿈 문자열로 끝난다. 이 줄바꿈 문자열은 ‘CRIF’라고 쓴다.

### **3.2.1 메세지 문법**

```
요청 메세지 형식

<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>

-------------------------

응답 메세지 형식

<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```

- 메서드
  - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
  - GET, POST, HEAD와 같이 한 단어로 되어있다.
- 요청 URL
  - 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성 요소
- 버전
  - 이 메세지에서 사용 중인 HTTP 버전
  - `HTTP/<메이저>.<마이너>`
- 상태 코드
  - 요청 중에 무엇이 일어났는지 설명하는 세자리 숫자
  - 첫번재 자릿수는 상태의 일반적인 분류를 나타낸다.
- 사유 구절
  - 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
  - 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재한다.
- 헤더들
  - 이름, 콜론, 선택적인 공백, 값, CRIF가 순서대로 나타나는 0개 이상의 헤더들
  - 이 헤더의 목록은 빈 줄로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.
- 엔터티 본문
  - 임의의 데이터 블록을 포함한다.
  - 모든 메세지가 엔터티 본문을 갖는 것은 아니다.

### **3.2.2 시작줄**

- 모든 HTTP 메세지는 시작줄로 시작한다.
- 요청 메세지의 시작줄은 무엇을 해야 하는지 말해주며, 응답 메세지의 시작줄은 무슨일이 일어났는지 말해준다.

- 요청줄
  - 요청 메세지의 요청줄에는 서버에게 어떤 동작이 일어나야 하는지 설명해주는 **메서드**와 그 동작에 대한 대상을 지칭하는 **요청 URL**이 들어있다.
  - 또한 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다.
  - 이 모든 필드는 공백으로 구분된다.
  - `GET /test/hi-there.txt HTTP/1.1`
- 응답줄
  - 응답 메세지의 응답줄에는 응답 메세지에서 쓰인 HTTP의 **버전**, 숫자로 된 **상태 코드**, 수행 상태에 대해 설명해주는 텍스트로 된 **사유 구절**이 들어있다.
  - 이 모든 필드는 공백으로 구분된다.
  - `HTTP/1.0 200 OK`
- 메서드
  - 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야하는지 말해준다.
  - HTTP 명세는 공통 요청 메서드의 집합을 정의한다.
  | 메서드  | 설명                                                    | 메세지 본문 여부 |
  | ------- | ------------------------------------------------------- | ---------------- |
  | GET     | 서버에서 어떤 문서를 가져온다.                          | X                |
  | HEAD    | 서버에서 어떤 문서에 대한 헤더만 가져온다.              | X                |
  | POST    | 서버가 처리해야 할 데이터를 보낸다.                     | O                |
  | PUT     | 서버에 요청 메세지의 본문을 저장한다                    | O                |
  | TRACE   | 메세지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | X                |
  | OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | X                |
  | DELETE  | 서버에서 문서를 제거한다.                               | X                |
- HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수도 있다. 이러한 추가 메서드를 확장 메서드라고 부른다.

- 상태 코드

  - 응답의 시작줄에 위치하며, 클라이언트에게 무엇이 일어났는지 말해준다.
  - 상태 코드들은 세자리 숫자로 된 코드값을 기준으로 묶인다.
  - 200~299 : 성공
  - 300~399 : 리소스가 옮겨졌음
  - 400~499 : 클라이언트가 잘못된 요청을 했음
  - 500~599 : 서버에서 뭔가 실패했음

- 사유 구절

  - 응답 시작줄의 마지막 구성요소로, 상태 코드에 대한 글로 된 설명을 제공한다.
  - HTTP명세는 사유 구절에 대한 엄격한 규칙을 제공하지 않는다.

- 버전 번호
  - 버전 번호는 `HTTP/x.y` 형식으로 요청과 응답 메세지 양쪽 모두에 기술된다.
  - 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.
  - 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 버전을 가리킨다.

---

### **3.2.3 헤더**

- HTTP 헤더 필드는 요청과 응답 메세지에 추가 정보를 더한다.
- 헤더는 기본적으로 이름/값 쌍의 목록이다.
- HTTP 헤더 명세는 여러 헤더 필드를 정의하며, 자유롭게 자신만의 헤더를 만들어낼 수 있다.
  - 일반 헤더 : 요청과 응답 양쪽에 모두 나타날 수 있음
  - 요청 헤더 : 요청에 대한 부가 정보를 나타냄
  - 응답 헤더 : 응답에 대한 부가 정보를 나타냄
  - Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
  - 확장 헤더 : 명세에 정의되지 않은 새로운 헤더

### **3.2.4 엔터티 본문**

- HTTP 메세지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 데이터를 실어나를 수 있다.

### **3.2.5 버전 0.9 메세지**

- HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다.
- HTTP/0.9 메세지도 요청과 응답으로 이루어져 있지만, 요청은 그저 메서드와 요청 URL만 존재하며, 응답은 오직 엔터티로만 되어있다. 버전 정보도 없고, 상태 코드나 사유 구절도 없으며, 헤더도 포함되어 있지않다.

---

## **3.3 메서드**

### **3.3.1 안전한 메서드**

- \*\*\*\*GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET, HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다. (HTTP 요청의 결과로 인해 서버에서 일어나는 일이 아무것도 없다는 의미)
- 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다.
- 안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

### **3.3.2 GET**

- 가장 흔히 쓰이는 메서드
- 주로 서버에 리소스를 달라고 요청하기 위해 쓰인다.
- HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구한다.

### **3.3.3 HEAD**

- HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려주며, 엔터티 본문은 결코 반환되지 않는다.
- HEAD를 사용하면,
  - 리소스를 가져오지 않고도 무엇인가를 알아낼 수 있다. (ex. 타입)
  - 응답의 상태 코드를 통해, 개체가 존재하는 지 확인할 수 있다.
  - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
- 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야한다.
- HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야한다.

### **3.3.4 PUT**

- PUT메서드는 서버에 문서를 쓴다.
- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.
- PUT은 콘텐츠를 변경할 수 있게 하므로, 수행하기 전 비밀번호를 입력해서 로그인을 하도록 요구할 것이다.

### 3.3.5 POST

- POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. 실제로 HTML 폼을 지원하기 위해 흔히 사용된다.

### 3.3.6 TRACE

- TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는 지 알려준다.
- TRACE 요청은 목적지 서버에서 루프백 진단을 시작한다.
- 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메세지를 본문에 넣어 TRACE 응답을 되돌려준다.
- 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메세지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.
- TRACE 메서드는 주로 **진단을 위해 사용**된다. ex) 요청이 의도한 요청/응답 연쇄를 거쳐가는 지 검사
- 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는 지 확인진단을 위해 사용할때는 괜찮지만, 중간 애플리케이션이 여러 다른 종류의 요청들을 일괄되게 다룬다고 가정하는 문제가 있다.
- 많은 HTTP 애플리케이션은 메서드에 따라 다르게 동작한다. → 프락시는 POST요청을 바로 서버로 통과시키는 반면 GET 요청은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송한다.TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다. TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.

### **3.3.7 OPTIONS**

- OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

### **3.3.8 DELETE**

- DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

### **3.3.9 확장 메서드**

- HTTP/1.1 명세에 정의되지 않은 메서드
- HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.
- 대표적인 예
  - LOCK
  - MKCOL
  - COPY
  - MOVE

## 3.4 상태 코드

- HTTP 상태 코드는 크게 다섯 가지로 나뉜다.

### **3.4.1 100-199 : 정보성 상태 코드**

- 정보성 상태 코드는 HTTP/1.1에서 도입되었다.
- 요청을 받았으며, 계속 처리 중임을 의미한다. 일반적으로 클라이언트가 추가 작업을 해야한다.

| 상태 코드 | 사유 구절           | 의미                                                |
| --------- | ------------------- | --------------------------------------------------- |
| 100       | Continue            | 요청의 첫 부분을 잘 받았고, 나머지를 계속 보내도 됨 |
| 101       | Switching Protocols | 프로토콜 변경 요청을 수락함 (예: HTTP → WebSocket)  |

### **3.4.2 200-299 : 성공 상태 코드**

- 요청이 정상적으로 처리되었음을 의미

| 상태 코드                                                                                               | 사유 구절                     | 의미                                                                   |
| ------------------------------------------------------------------------------------------------------- | ----------------------------- | ---------------------------------------------------------------------- |
| 200                                                                                                     | OK                            | 요청 성공. 가장 일반적인 응답                                          |
| 201                                                                                                     | Created                       | 새로운 리소스가 성공적으로 생성됨 (POST, PUT 요청 등)                  |
| 202                                                                                                     | Accepter                      | 요청을 수락했지만 아직 처리되지는 않음                                 |
| 203                                                                                                     | Non-Authoritative Information | 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. |
| 중개자의 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보를 검증하니 못한 경우 이런 일이 발생한다. |
| 204                                                                                                     | No Content                    | 응답할 본문이 없음. 성공이지만 데이터 없음                             |
| 205                                                                                                     | Reset Content                 | 주로 브라우저를 위해 사용되는 또 하나의 코드                           |
| 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.                             |
| 206                                                                                                     | Partial Content               | 부분 혹은 범위 요청이 성공했다.                                        |

### 3.4.3 300-399: 리다이렉션 상태 코드

- 클라이언트가 다른 URL로 요청을 다시 해야한다.

| 상태 코드 | 이름                              | 설명                                                                                                                                                                                                                                                         |
| --------- | --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **300**   | Multiple Choices                  | 요청한 리소스에 대해 **여러 가지 응답 가능성**이 있을 때 사용합니다. 예: 동일한 리소스가 서로 다른 포맷(JSON, XML 등)으로 존재할 때. 대부분의 브라우저는 자동 처리하지 않습니다.                                                                             |
| **301**   | Moved Permanently                 | 요청한 리소스가 **영구적으로 다른 URL로 이동**되었음을 의미합니다. 클라이언트는 이후 이 새로운 URL로 요청해야 하며, **검색 엔진도 이 URL을 새 기준으로 인식**합니다.                                                                                         |
| **302**   | Found _(기존: Moved Temporarily)_ | 리소스가 **임시적으로 다른 URL로 이동**되었음을 의미합니다. **기존 URL을 계속 사용해야 하며**, 현재는 해당 위치에서만 제공됩니다. 실제로는 **POST 요청 후 GET 응답으로 바뀌는 경우**에 자주 사용되며, 혼란을 줄 수 있어 303, 307로 대체되는 경우가 많습니다. |
| **303**   | See Other                         | 클라이언트가 **다른 URL로 GET 요청을 다시 보내야** 할 때 사용합니다. **POST 이후 리디렉션 시 적절한 코드**입니다. RESTful API에서 많이 사용됩니다.                                                                                                           |
| **304**   | Not Modified                      | 클라이언트의 캐시된 리소스가 여전히 유효하므로 **새로운 데이터를 전송할 필요가 없을 때** 사용합니다. `If-Modified-Since`, `ETag` 등의 조건부 요청에 대한 응답입니다.                                                                                         |
| **305**   | Use Proxy                         | 클라이언트가 **프록시 서버를 통해서만 접근해야 한다는 의미**입니다. 현재는 **보안상의 이유로 사용이 권장되지 않으며**, 브라우저도 대부분 지원하지 않습니다. _(RFC 7231에서 폐지됨)_                                                                          |

### 3.4.4 400-499: 클라이언트 에러 상태 코드

| 상태 코드 | 이름                   | 설명                                                                                                                                               |
| --------- | ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **400**   | Bad Request            | 요청 문법이 잘못되었거나, 필요한 파라미터가 누락되는 등 요청 자체가 유효하지 않음.                                                                 |
| **401**   | Unauthorized           | 인증되지 않음. Authorization 헤더 등이 없거나, 토큰이 유효하지 않을 때 발생. 로그인 요구.                                                          |
| **403**   | Forbidden              | 서버가 요청을 이해했지만 **권한이 없어 거부**됨. 인증 여부와 무관.                                                                                 |
| **404**   | Not Found              | 요청한 URL 또는 리소스를 서버에서 찾을 수 없음.                                                                                                    |
| **405**   | Method Not Allowed     | 해당 리소스는 존재하지만, 사용한 HTTP 메서드(GET, POST 등)는 지원하지 않음.                                                                        |
| **406**   | Not Acceptable         | 요청한 리소스는 존재하지만, 클라이언트가 원하는 응답 형태(Content-Type 등)로 제공할 수 없음.                                                       |
| **408**   | Request Timeout        | 클라이언트가 요청을 너무 늦게 보내 서버가 타임아웃 처리함.                                                                                         |
| **409**   | Conflict               | 요청이 현재 서버 상태와 충돌됨. 예: 중복 데이터, 버전 충돌 등.                                                                                     |
| **410**   | Gone                   | 요청한 리소스가 **영구적으로 삭제**되어 더 이상 존재하지 않음. 404와는 다름.                                                                       |
| **413**   | Payload Too Large      | 요청한 데이터(파일 등)가 서버가 처리할 수 있는 크기보다 큼.                                                                                        |
| **414**   | URI Too Long           | 요청한 URL 자체가 너무 길어서 서버가 처리할 수 없음.                                                                                               |
| **415**   | Unsupported Media Type | 서버가 요청에 포함된 Content-Type을 지원하지 않음. 예: JSON이 아닌 이상한 포맷 등.                                                                 |
| **422**   | Unprocessable Entity   | 서버는 문법적으로는 올바른 요청을 받았지만 의미적으로 처리할 수 없음. 주로 **유효성 검사 실패** 시 발생 (예: JSON 구조는 맞지만 필드 값이 잘못됨). |
| **429**   | Too Many Requests      | 짧은 시간 동안 너무 많은 요청을 보냄. 서버가 rate limiting 중일 때 주로 사용됨.                                                                    |

### 3.4.5 500-599: 서버 에러 상태 코드

| 상태 코드 | 이름                            | 설명                                                                                                    |
| --------- | ------------------------------- | ------------------------------------------------------------------------------------------------------- |
| **500**   | Internal Server Error           | **일반적인 서버 오류**. 명확한 원인을 알 수 없지만 서버 내부에서 예외가 발생했을 때 사용됨.             |
| **501**   | Not Implemented                 | 클라이언트의 요청 메서드나 기능이 **서버에 구현되어 있지 않음**. 예: 서버가 PATCH를 지원하지 않는 경우. |
| **502**   | Bad Gateway                     | 게이트웨이 또는 프록시 서버가 받은 응답이 **잘못되었거나 유효하지 않음**.                               |
| **503**   | Service Unavailable             | 서버가 **일시적으로 사용 불가** (예: 과부하, 유지보수 중 등). Retry-After 헤더로 재시도 시점 명시 가능. |
| **504**   | Gateway Timeout                 | 게이트웨이/프록시 서버가 **지정된 시간 내에 응답을 받지 못함**. 즉, 백엔드 서버 타임아웃.               |
| **505**   | HTTP Version Not Supported      | 서버가 요청에서 사용한 HTTP 프로토콜 버전을 **지원하지 않음**.                                          |
| **507**   | Insufficient Storage            | 서버가 요청을 저장할 충분한 공간을 가지고 있지 않음 (WebDAV 관련).                                      |
| **508**   | Loop Detected                   | 서버 내부에서 무한 루프가 감지됨 (WebDAV 관련).                                                         |
| **510**   | Not Extended                    | 요청에 필요한 확장 정보가 누락됨. 클라이언트가 더 많은 정보를 보내야 함.                                |
| **511**   | Network Authentication Required | 네트워크에 접근하기 위해 인증이 필요함. 주로 **공공 Wi-Fi 로그인 페이지 리디렉션** 등에 사용됨.         |

## **3.5 헤더**

- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.
- 헤더에는 특정 종류의 메세지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더, 응답과 요청 메세지 양쪽 모두에서 정보를 제공하는 헤더가 있다.

### **3.5.1 일반 헤더**

- 일반 헤더는 메세지에 대한 아주 기본적인 정보를 제공하며, 클라이언트와 서버 양쪽 모두가 사용한다.
- 클라이언트, 서버, 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.
- ex) Date 헤더
  - 서버와 클라이언트를 가리지 않고 메세지가 만들어진 일시를 지칭하기 위해 사용하는 일반 목적 헤더
  - `Date: Tue, 3 Oct 1974 02:16:00 GMT`

| 헤더                     | 설명                                                                        |
| ------------------------ | --------------------------------------------------------------------------- |
| Connection               | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다.       |
| Date                     | 메세지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다.                   |
| MIME-Version             | 발송자가 사용한 MIME 버전을 알려준다.                                       |
| Trailer chunked transfer | 인코딩으로 인코딩된 메세지의 끝 부분에 위치한 헤더들의 목록을 나열한다.     |
| Transfer-Encoding        | 수신자에게 안전한 전송을 위해 메세지에 어떤 인코딩이 적용되었는지 말해준다. |
| Upgrade                  | 발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 알려준다.             |
| Via                      | 이 메세지가 어떤 중개자를 거쳐 왔는지 보여준다.                             |

- 일반 캐시 헤더
  - HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했다.
  | 헤더          | 설명                                                                  |
  | ------------- | --------------------------------------------------------------------- |
  | Cache-Control | 메세지와 함께 캐시 지시자를 전달하기 위해 사용한다.                   |
  | Pragma        | 메세지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않는다. |

### **3.5.2 요청 헤더**

- 요청 헤더는 요청 메세지에서만 의미를 갖는 헤더이다.
- 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.
- ex) Accept 헤더
  - 서버에세 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미
  - `Accept:  **/**`

| 헤더       | 설명                                                               |
| ---------- | ------------------------------------------------------------------ |
| Client-IP  | 클라이언트가 실행된 컴퓨터의 IP를 제공한다.                        |
| From       | 클라이언트 사용자의 메일 주소를 제공한다.                          |
| Host       | 요청의 대상이 되는 서버의 호스트 명과 포트를 준다.                 |
| Referer    | 현재의 요청 URI가 들어있었던 문서의 URL을 제공한다.                |
| UA-Color   | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보를 제공한다.     |
| UA-CPU     | 클라이언트 CPU의 종류나 제조사를 알려준다.                         |
| UA-Disp    | 클라이언트의 디스플레이 능력에 대한 정보를 제공한다.               |
| UA-OS      | 클라이언트 기기에서 동작 중인 운영체제의 이름이나 버전을 알려준다. |
| UA-Pixels  | 클라이언트 기기 디스플레이에 대한 픽셀 정보를 제공한다.            |
| User-Agent | 요청을 보낸 애플리케이션의 이름을 서버에게 말해준다.               |

- Accept 관련 헤더
  - 클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호나 능력을 알려줄 수 있다. 즉, 클라이언트가 무엇을 원하고 무엇을 할 수 있는지, 원치 않는 것은 무엇인지 알려줄 수 있다.
  - Accept 관련 헤더들은 서버와 클라이언트 양 쪽 모두에게 유익하다. 클라이언트는 원하는 것을 얻을 수 있으며, 서버는 클라이언트가 필요하지 않은 정보를 전송하는 데 시간과 대역폭을 낭비하지 않을 수 있다.
  | 헤더            | 설명                                                   |
  | --------------- | ------------------------------------------------------ |
  | Accept          | 서버에게 서버가 보내도 되는 미디어 종류를 말해준다.    |
  | Accept-Charset  | 서버에게 서버가 보내도 되는 문자집합을 말해준다.       |
  | Accept-Encoding | 서버에게 서버가 보내도 되는 인코딩을 말해준다.         |
  | Accept-Language | 서버에게 서버가 보내도 되는 언어를 말해준다.           |
  | TE              | 서버에게 서버가 보내도 되는 확장 전송 코딩을 말해준다. |
- 조건부 요청 헤더
  - 조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다.
  | 헤더                | 설명                                                                              |
  | ------------------- | --------------------------------------------------------------------------------- |
  | Expect              | 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다.                   |
  | If-Match            | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져온다.      |
  | If-Modified-Since   | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한한다.                    |
  | If-None-Match       | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져온다. |
  | If-Range            | 문서의 특정 범위에 대한 요청을 할 수 있게 해준다.                                 |
  | If-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다.                         |
  | Range               | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청한다.                |
- 요청 보안 헤더
  - HTTP는 기본적으로 인증을 위한 간단한 메커니즘을 제공한다.
  - 이는 클라이언트가 서버에 요청을 보내기 전에 자신의 신원을 증명할 수 있도록 하여, 인증된 사용자만 특정 자원에 접근하도록 하기 위한 목적이다.
  | 헤더          | 요청                                                                 |
  | ------------- | -------------------------------------------------------------------- |
  | Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다. |
  | Cookie        | 클라이언트가 서버에게 토큰을 전달할 때 사용한다.                     |
  | Cookie2       | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용한다.                  |
- 프락시 요청 헤더
  - 프락시가 점점 흔해지면서, 기능을 돕기 위해 몇몇 헤더들이 정의되어 왔다.
  | 헤더                            | 설명                                                                                   |
  | ------------------------------- | -------------------------------------------------------------------------------------- |
  | Max-Forwards                    | - 요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수 |
  | - TRACE 메서드와 함께 사용된다. |
  | Proxy-Authorization             | - Authorization과 같으나 프락시에서 인증을 할 때 쓰인다.                               |
  | Proxy-Connection                | - Connection과 같으나 프락시에서 연결을 맺을 때 쓰인다.                                |

### **3.5.3 응답 헤더**

- 응답 헤더는 클라이언트에게 부가 정보를 제공한다.
- 누가 응답을 보내고 있는지, 응답자의 능력은 어떻게 되는지, 응답에 대한 특별한 설명도 제공할 수 있다.
- ex) Server 헤더
  - 클라이언트에게 그가 Tiki-Hut 서버 1.0 버전과 대화하고 있음을 말해준다.
  - `Server: Tiki-Hut /1.0`

| 헤더        | 설명                                                                    |
| ----------- | ----------------------------------------------------------------------- |
| Age         | 응답이 얼마나 오래되었는지                                              |
| Public      | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록                   |
| Retry-After | 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시각 |
| Server      | 서버 애플리케이션의 이름과 버전                                         |
| Title       | HTML문서에서 주어진 것와 같은 제목                                      |
| Warning     | 사유 구절에 있는 것보다 더 자세한 경고 메세지                           |

### **3.5.4 엔터티 헤더**

- 엔터티 헤더란 엔터티 본문에 대한 헤더를 말한다.
- 일반적으로 엔터티 헤더는 메세지의 수신자에게 자신이 다루고 있는 것이 무엇인지 말해준다.
- ex) Content-Type 헤더
  - 애플리케이션에게 데이터가 iso-latin-1 문자집합으로 된 HTML 문서임을 알려준다.
  - `Content-Type: text/html; charset-iso-latin-1`

| 헤더     | 설명                                                             |
| -------- | ---------------------------------------------------------------- |
| Allow    | 이 엔터티에 대해 수행할 수 있는 요청 메서드들을 나열한다.        |
| Location | 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는 지 말해준다. |

- 콘텐츠 헤더
  - 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.
  - 콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들이다.
  | 헤더             | 설명                                                           |
  | ---------------- | -------------------------------------------------------------- |
  | Content-Base     | 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL              |
  | Content-Encoding | 본문에 적용된 어떤 인코딩                                      |
  | Content-Language | 본문을 이해하는데 가장 적절한 자연어                           |
  | Content-Length   | 본문의 길이나 크기                                             |
  | Content-Location | 리소스가 실제로 어디에 위치하는지                              |
  | Content-MD5      | 본문의 MD5 체크섬                                              |
  | Content-Range    | 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현 |
  | Content-Type     | 이 본문이 어떤 종류의 객체인지                                 |
- 엔터티 캐싱 헤더
  - 엔터티 캐싱에 대한 정보를 제공한다.
  - 예를 들면, 리소스에 대해 캐시된 사본이 아직 유효한지에 대한 정보와, 캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 더 잘 추정하기 위한 단서 같은 것이다.
  | 헤더          | 종류                                                             |
  | ------------- | ---------------------------------------------------------------- |
  | ETag          | 이 엔터티에 대한 엔터티 태그                                     |
  | Expires       | 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
  | Last-Modified | 가장 최근 이 엔터티가 변경된 일시                                |

\*\*\*\*일반 헤더요청 헤더응답 헤더엔티티 헤더확장 헤더
