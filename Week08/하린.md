# 11장. 클라이언트 식별과 쿠키

## 11.1 개별 접촉

- HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜
- 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

#### 개인화된 서비스들

- 개별 인사: 사용자에게 특화된 환영 메시지나 페이지 내용
- 사용자 맞춤 추천: 고객의 취향에 맞는 제품 추천
- 저장된 사용자 정보: 온라인 쇼핑 사이트에서 사용자의 주소와 신용카드 정보등을 저장
- 세션 추적
  - HTTP 트랜잭션은 연결 자체에 대한 상태가 없으며 매 요청 및 응답은 일회성이고 독립적으로 일어난다.
  - 사용자가 사이트와 상호작용하려면 웹 사이트는 HTTP 트랜잭션을 식별할 방법이 필요하다.

이 장에서는 HTTP가 사용자를 식별하는 데 사용하는 기술들을 논의한다.

- 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
- 클라이언트 IP 주소 추적으로 알아낸 IP주소로 사용자 식별
- 사용자 로그인 인증을 통한 식별
- URL에 식별자를 포함하는 기술인 뚱뚱한(fat) URL
- 식별 정보를 지속해서 유지하는 쿠키

## 11.2 HTTP 헤더

#### 사용자에 대한 정보를 전달하는 HTTP 헤더

- From
  - 헤더 타입: 요청
  - 설명: 사용자의 이메일 주소
  - 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송할 수 있어서 From 헤더를 보내는 브라우저는 많지 않다.
- User-Agent
  - 헤더 타입: 요청
  - 설명: 사용자의 브라우저의 이름과 버전 정보, 운영체제 등을 포함
  - 크로스 브라우징에는 유용하나, 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다.
- Referer
  - 헤더 타입: 요청
  - 설명: 사용자를 현재 페이지로 유입하게 한 URL
  - 이 헤더 자체로 사용자를 식별할 수는 없지만, 이전에 어떤 페이지를 방문했었는지 알려주어 사용자의 웹 사용 행태나 취향을 잘 파악할 수 있다.
- Authorization
  - 헤더 타입: 요청
  - 설명: 사용자의 이름과 비밀번호(뒤에서 다룸)
- Client-ip
  - 헤더 타입: 확장(요청)
  - 설명: 클라이언트의 IP 주소(뒤에서 다룸)
- X-Forwarded-For
  - 헤더 타입: 확장(요청)
  - 설명: 클라이언트의 IP 주소(뒤에서 다룸)
- Cookie
  - 헤더 타입: 확장(요청)
  - 설명: 서버가 생성한 ID 라벨(뒤에서 다룸)

## 11.3 클라이언트 IP 주소

- 초기에는 사용자 식별에 클라이언트 IP 주소를 사용하려고 했다.

  - 사용자가 확실한 IP 주소를 갖고, 주소가 바뀌지 않고, 웹 서버가 요청마다 IP를 알 수 있다면 문제없이 동작함.

- 클라이언트 IP 주소는 보통 헤더에 없지만 웹 서버는 HTTP 요청 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다.
- 그러나, 약점이 존재한다.
  - 클라이언트 IP 주소는 사용자가 아닌 사용하는 컴퓨터를 가리키므로, 여러 사용자가 같은 컴퓨터를 사용한다면 식별할 수 없다.
  - 인터넷 서비스 제공자(ISP)는 사용자 로그인시 동적으로 IP 주소를 할당하기 때문에 웹 서버는 사용자를 식별할 수 없다.
  - 보안 강화를 위해 네트워크 주소 변환 방화벽(NAT)를 통해 인터넷을 사용하면, 클라이언트 IP 주소를 내부에서 사용하는 하나의 방화벽 IP 주소로 변환한다.
  - HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 하기 때문에 웹 서버는 프락시 서버의 IP 주소를 본다.
    - 일부 프락시는 Client-ip, X-Forwarded-For HTTP 같은 확장 헤더로 문제를 해결

## 11.4 사용자 로그인

#### 개념

IP 주소로 사용자를 식별하는 수동적인 방식보다, 웹 서버는 사용자 이름과 비밀번호로 인증을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.

#### 주요 특징

WWW-Authenticate와 Authorization 헤더

- 웹 서버는 사용자에게 사용자 이름을 묻는다는 지시적인 체계를 가지고 있다.
- 한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보를 항상 확인할 수 있다.

#### HTTP 인증 과정

- 최초 요청: 브라우저가 www.joes-hardware.com 사이트로 요청한다.
- 인증 요구: 서버는 사용자의 식별정보를 얻고 싶어하고, 서버는 401 Login Required HTTP 응답 코드와 WWW-Authenticate 헤더를 반환하여 로그인하라고 요청한다.
- 사용자 인증: 사용자가 사용자 이름과 비밀번호를 입력하고 브라우저는 기존 요청을 다시 보내 사용자 식별을 시도한다.
- 성공적 로그인: 이제 서버는 사용자의 식별정보를 안다
- 지속적 인증: 이 시점 이후의 요청에 대해서, 브라우저는 서버에서 오는 식별 요청에 대해 자동으로 사용자 이름, 비밀번호를 포함한다.

## 11.5 뚱뚱한 URL

어떤 웹 사이트는 사용자가 사이트를 돌아다니면, URL의 처음이나 끝에 사용자의 상태 정보를 추가한 하이퍼링크를 동적으로 생성하여 사용자를 식별한다. 이를 뚱뚱한 URL이라고 한다.

#### 문제점

- 못생긴 URL: 브라우저에 보이는 뚱뚱한 URL은 사용자에게 혼란을 준다.
- 공유하지 못하는 URL: 뚱뚱한 URL을 공유하게 되면, 개인 정보가 노출될 수 있다.
- 캐시를 사용할 수 없음: URL이 달라지므로 기존 캐시에 접근할 수 없다.
- 서버 부하 가중: 서버는 뚱뚱한 URL에 해당하는 HTML을 다시 그려야 한다.
- 이탈: 사용자가 다른 사이트로 이동하거나 해서 뚱뚱한 URL을 이탈하게 되면 지금까지의 정보들이 초기화될 것 이다.
- 세션 간 지속성의 부재: 사용자가 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키

- 쿠키는 사용자를 식별하고 세션을 유지하는 방식 중 현재까지 가장 널리 사용하는 방식이다.
- 쿠키만으로 하기 힘든 일엔 앞서 설명한 기술들을 사용하기도 한다.
- 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키 내용물을 캐싱하지 않는다.

### 11.6.1 쿠키의 타입

#### 세션 쿠키(session cookie)

- 사용자가 사이트를 탐색할 때, 관련 설정과 선호 사항들을 저장하는 임시 쿠키
- 브라우저를 닫으면 삭제된다.

#### 지속 쿠키(persistent cookie)

- 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용
- 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다.

다른 점은 파기되는 시점뿐이다.  
Discard 파라미터가 설정되어 있거나, 파기되기까지 남은 시간을 가리키는 Expires, Max-Age 파라미터가 없으면 세션 쿠키

### 11.6.2 쿠키는 어떻게 동작하는가

동작방식:

- 처음 사용자가 웹 사이트 방문시 웹 서버는 사용자에 대해 아무것도 모른다.
- 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.
- 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie, Set-Cookie2(확장 헤더) 같은 응답 헤더에 담겨 사용자에게 전달한다.
- 쿠키는 어떤 정보든 포함할 수 있지만, 단순 사용자 추적 용도 식별 번호만 포함하기도 한다.
- 브라우저는 서버로부터 온 쿠키 헤더에 있는 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다.
- 사용자가 같은 사이트를 방문하면 브라우저는 서버가 보낸 쿠키를 요청 헤더에 담아 보낸다.

### 11.6.3 쿠키 상자: 클라이언트 측 상태

클라이언트 측 상태:

- 쿠키의 기본 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때 그 정보를 함께 전송하게 하는 것
- 그러므로 브라우저는 쿠키 정보를 저장할 책임이 있다. 이 시스템을 '클라이언트 측 상태'라고 한다.
- 쿠키 명세에서 이것의 공식적인 이름은 'HTTP 상태 관리 체계'이다.

#### 구글 크롬 쿠키

구글 크롬은 Cookies라는 SQLite 파일에 쿠키를 저장한다. 각 행이 갖는 주요 필드의 의미는 다음과 같다.

- `creation_utc`: 생성된 시점을 초 단위로 기술
- `host_key`: 쿠키의 도메인
- `name`: 쿠키의 이름
- `value`: 쿠키의 값
- `path`: 쿠키와 관련된 도메인에 있는 경로
- `expire_utc`: 쿠키의 파기 시점을 초 단위로 기술
- `secure`: 이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킨다

#### 인터넷 익스플로러 쿠키

- 캐시 디렉터리에 각 개별 파일로 쿠키를 저장되며 각 쿠키는 여러 행으로 기술되어 있다.
- 쿠키의 이름, 쿠키의 값, 도메인과 경로, 날짜나 표식 등 순으로 한 줄씩 기술된다.

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 수백/천 개의 쿠키를 가질 수 있지만, 보통 각 사이트에 2~3개 의 쿠키만을 보낸다. 또한, 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.
그 이유는 다음과 같다.

- 모두 전달할 경우 성능이 크게 저하된다.
- 대부분은 서버에 특화도니 이름/값 쌍을 포함하기 때문에, 대부분 사이트에서는 인식하지 않는 무의미한 값
- 신뢰하지 않는 사이트에서 잠재적인 개인정보 문제를 일으킬 수 있다.

#### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해 어떤 사이트가 해당 쿠키를 읽을 수 있는지 제어할 수 있다.

```
Set-Cookie: user="mary17"; domain="airtravlebargains.com"
```

www.airtravlebargains.com , specials.airtravelbargains.com 같이 airtravelbargains.com로 끝나는 사이트에서 쿠키가 적용될 것

#### 쿠키 Path 속성

웹 사이트의 일부 경로에 속하는 페이지에만 쿠키를 전달하게 Path 속성을 적용할 수도 있다.

```
Set-Cookie: pref=compact; domain="airtravlebargains.com"; path=/autos/
```

http://www.airtravelbargains.com/autos/.... 에 접근하면 다음 두 쿠키를 받는다.

```
Cookie: user="mary17"
Cookie: pref=compact
```

### 11.6.5 쿠키 구성요소

현재 사용되는 쿠키 명세에는 Version 0 쿠키 ('넷스케이프 쿠키')와 Version 1 쿠키('RFC 2965')가 있다. Version 1 쿠키는 Version 0 쿠키의 확장으로 널리 쓰이지는 않는다.

### 11.6.6 Version 0(넷스케이프) 쿠키

- 넷스케이프가 정의한 최초의 쿠키 명세
- Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드들 정의

#### Set-Cookie 헤더

```
Set-Cookie: name=value [; expries=date] [; path=path] [; domain=domain] [; secure]
```

- 쿠키의 이름과 값을 가짐.
- 쿠키 옵션 속성들에 세미콜론으로 이어 기술한다.

Set-Cookie 속성과 설명

- 이름=값
  - 필수 속성
  - 큰따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열
  - 사용자가 추후 웹 서버에 다시 방문하면 읽어올 어떤 이름=값 조합이든 만들 수 있다.
- Expires
  - 선택적 속성
  - 쿠키의 생명주기를 가리키는 날짜 문자열
  - 파기 일자에 다다르면, 쿠키는 삭제되고 전달되지도 않는다.
  - Expires를 명시하지 않으면 사용자의 세션이 종료될 때 파기된다.
  - 날짜 형식: `요일, DD-MM-YY HH:MM:SS GMT`
- Domain
  - 선택적 속성
  - 브라우저는 이 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송
  - '.com', '.edu', '.net' 등과 같이 특정 형식의 도메인을 기술하는 것을 방지하고자 2~3개 영역을 가지는 도메인을 기술해야 한다. (ex. 'acme.com')
  - 도메인이 명시되어 있지 않으면, Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 사용
- Path
  - 선택적 속성
  - path 속성에 기술된 값과 URL 경로의 앞부분과 일치하면, 쿠키를 전달
  - '/foo' -> '/foobar', '/foo/bar.html'
  - '/' -> 도메인에 있는 모든 경로
  - 경로를 명시하지 않으면, Set-Cookie 응답을 전달하는 URL의 경로 사용
- Secure
  - 선택적 속성
  - HTTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송

#### Cookie 헤더

```
Cookie: session-id=002-1145255-801638; session-id-time=1007884800
```

- 클라이언트가 서버에 요청할 때 Domain, Path, Secure 필터들이 현재 요청하려는 사이트에 들어맞으면서 파기되지 않은 쿠키들을 함께 보낸다.
- 모든 쿠키는 Cookie 헤더에 이어 붙여 보낸다.

### 11.6.7 Version 1 (RFC 2965) 쿠키

- Set-Cookie2 , Cookie2 헤더를 소개하며 Version 0 시스템과도 호환된다.
- Version 0 보다 좀 복잡하며 아직 모든 브라우저나 서버가 완전히 지원하지는 않는다.
  - 이제는 폐기되어 더 이상 지원되지 않음..

주요 변경 사항

- 쿠키마다 목적을 설명하는 설명문이 있다.
- 파기 주기에 상관없이 브라우저가 닫히면 쿠키를 강제로 삭제할 수 있다.
- 초 단위의 상대 값으로 쿠키의 생명주기를 결정할 수 있는 Max-Age
- URL의 포트번호로도 쿠키를 제어 가능
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보낸다.
- 호환되는 버전 번호
- 사용자 이름과 추가 키워드 구별하기 위해 $접두어를 사용

Set-Cookie2 속성과 설명

- 이름=값
  - 필수
  - Version 0 과 동일하나, 다른점은 '$'은 예약문자라 '$'로 시작하면 안된다.
- Version
  - 필수
  - 쿠키 명세의 버전을 가리키는 정수 값
- Comment
  - 선택
  - 서버가 쿠키를 사용하려는 의도 기술
- CommentURL
  - 선택
  - Comment가 기술된 웹페이지 URL 링크를 제공
- Discard
  - 선택
  - 클라이언트 프로그램이 종료될 때 클라이언트가 해당 쿠키를 삭제한다.
- Domain
  - 선택
  - Version 0 과 동일하나, 몇 가지 규칙이 더 있긴하다.
- Max-Age
  - 선택
  - 쿠키의 생명주기를 초 단위로 산정한 정수값
  - 쿠키의 나이가 Max-Age 보다 많아지면 클라이언트는 쿠키를 제거
  - 값이 0이면 해당 이름을 가진 쿠키를 즉시 지워야 함
- Path
  - 선택
  - Version 0 과 동일
- Port
  - 선택
  - Port 키워드만 기술하면, 현재 응답 서버의 포트에 대해서만 전송
  - 포트 여러 개를 기술하면, 포트 목록에 있는 포트에 해당하는 서버로만 쿠키 전달
- Secure
  - 선택
  - Version 0 과 동일

#### Version 1 Cookie 헤더

Version 0 Cookie 헤더와 동일하나, Set-Cookie2 필터 중 현재 사이트에 들어맞는 정보에 '$'를 붙여서 쿠키와 함께 전송

#### Version 1 Cookie2 헤더와 버전 협상

- Cookie2 요청 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트와 서버 간에 호환성을 협상하는 용도로 사용
  ```
  Cookie2: $Version="1"
  ```
- 서버가 Cookie2 헤더를 받으먄 Set-Cookie2 응답 헤더를 보내야함.
- 클라이언트가 Set-Cookie, Set-Cookie2 모두 보내면, Set-Cookie를 무시
- 클라이언트가 Version 0, Version 1 모두 지원해도 서버로부터 Version 0 Set-Cookie를 받으면 Version 0 Cookie 헤더를 보내야 함.
  - 그러나 업그레이드 하라는 의미로 Cookie2: $Version="1"을 보내야 함.

### 11.6.8 쿠키와 세션 추적

쿠키는 웹 사이트에 여러 번 방문하는 사용자를 추적하는 데 사용된다.

### 11.6.9 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다. 이전 사용자의 쿠키가 다른 사용자에게 할당되거나, 누군가의 개인 정보가 다른 이에게 노출되는 일이 생길 수 있다.

캐시 제어 지침들

#### 캐시되지 말아야 할 문서가 있다면 표시하라

- 문서가 Set-Cookie 헤더를 제외하고 캐시 해도 되는 경우 명시적으로 Cache-Control: no-cache="Set-Cookie"를 기술한다.

#### Set-Cookie 헤더를 캐시 하는 것에 유의하라

- Set-Cookie 헤더를 캐시하는 것은 주의를 기울여야 한다
- 여러 사용자에게 Set-Cookie 헤더를 보내게 되면, 사용자 추적에 실패할 것
- 어떤 캐시는 응답을 저장하기 전에 Set-Cookie 헤더를 제거하기 때문에, 그 데이터를 받는 클라이언트는 Set-Cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
- 캐시가 모든 요청마다 웹 서버와 재검사기켜 클라이언트로 가는 응답에 Set-Cookie 헤더 값ㅇ르 기술해 문제를 개선할 수 있다.
  ```
  Cache-Control: must-revalidate, max-age=0
  ```

#### Cookie 헤더를 갖고 있는 요청을 주의하라

- 요청이 Cookie 헤더와 요면, 결과 문서가 개인정보를 담고 있을 수도 있다. 개인 정보는 캐시되면 안되지만 그 표시를 하지 않는 서버도 있다.
- 보수적인 캐시는 Cookie 헤더를 포함한 요청에 응답으로 오는 문서는 캐시하지 않을 것이다.

### 11.6.10 쿠키, 보안 그리고 개인정보

- 쿠키를 비활성화할 수 있고, 로그 분석 같은 다른 방법으로 대체 가능하므로 보안상으로 엄청 위험한 것은 아니다.
- 원격 데이터베이스에 개인 정보를 저장하고, 쿠키에는 해당 키 값을 저장하는 식으로 사용하면, 예민한 데이터가 오가는 것을 줄일 수 있다.
- 개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기 때문에 항상 조심
