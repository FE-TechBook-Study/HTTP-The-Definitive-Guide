# 상현
# 11장. 클라이언트 식별과 쿠키

## 11.1 개별 접촉

현대의 웹 사이트는 개인화된 서버시스 제공하고 여러가지 방식으로 사이트를 개인화시켜서 사용자에게 제공

- 개별인사: 사용자에게 특화된 환영 메시지나 페이지 제공
- 사용자 맞춤 추천: 고객의 정보와 흥미를 학습해서 제품 추천
- 저장된 사용자 정보: 쇼핑을 더 편하게 할 수 있도록 사용자 정보(주소, 카드정보 등) 저장
- 세션 추적: 트랜잭션을 추적하여 사용자 상태를 파악

## 11.2 HTTP 헤더

사용자 정보 전달 헤더

| 헤더 이름 | 헤터 타입 | 설명 |
| --- | --- | --- |
| From | 요청 | 사용자의 이메일 주소 |
| User-Agent | 요청 | 사용자의 브라우저 |
| Referer | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지 |
| Authorization | 요청 | 사용자의 이름과 비밀번호 |
| Client-ip | 확장(요청) | 클라이언트 IP 주소 |
| X-Forwarded-For | 확장(요청) | 클라이언트 IP 주소 |
| Cookie | 확장(요청) | 서버가 생성한 ID 라벨 |
- From에 이메일 주소를 담아서 각 사용자를 파악할 수 있었으나, 악의적인 스팸이 있어서 From을 보내는 브라우저가 많지 않음
- User-Agent는 브라우저 정보를 전달하여 특정 브라우저에서 제대로 동작하도록 속성을 맞춰서 콘텐츠 전달 가능
- Referer에는 어떤 페이지로 유입이 되었는지 전달하여 사용자의 행태나 취향 파악 가능

## 11.3 클라이언트 IP 주소

IP주소가 바뀌지 않고 요청마다 IP주소를 알 수 있다면 사용자 파악을 할 수 있으나, 다음 약점을 가짐:

- 여러 사용자가 같은 주소를 공유하면 식별 불가능
- ISP(Internet Service Provider)를 사용하여 로그인 하면 매번 다른 IP주소를 할당하기에 식별 불가능
- 보안을 강화하기 위해 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 통해 실제 IP를 변경하기에 식별 불가능
- 프락시와 게이트웨이가 중간에 있을 경우 해당 장비의 IP를 활용하기에 식별 불가능

## 11.4 사용자 로그인

사용자의 이름과 비밀번호를 활용하여 명시적으로 식별 요청 가능한 방법

서버에서 401 Login Required코드를 보내면 브라우저는 로그인 화면을 보여주고 다음 요청부터 Authorization 헤더에 정보를 포함하여  통신

그러나, 유저는 아래 이유로 접속을 꺼려할 수도 있다.

- 사이트를 옮겨 다닐 때마다 각 사이트에 로그인 필요
- 로그인 필요 정보를 기억
- 사용자 정보(이름)이 먼저 선점되어있을 확률
- 다양한 비밀번호 조합 규칙

## 11.5 뚱뚱한 URL

“뚱뚱한 URL”이란 사용자 정보를 포함하고 있는 URL을 의미
유저가 페이지 방문 시, 값을 부여하여 URL에 추가하고 이를 활용하여 사용자를 추적

그러나 다음 문제를 포함:

- 못생긴 URL: 사용자에게 혼란 제공
- 공유하지 못하는 URL: 특정 사용자와 세션에 대한 정보를 포함하기에 URL공유는 정보 공유
- 캐시 사용 불가: URL이 달라지기 때문에 기존 캐시에 접근 불가능
- 서버 부하 증가: 뚱뚱한 URL에 해당하는 HTML을 다시 작성 필요
- 이탈: 페이지를 이탈하면 URL이 초기화되기에 진행상황 또한 초기화
- 세션 간 지속성 부재: 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃하면 모든 정보 소실

## 11.6 쿠키

쿠키는 앞선 기술들의 문제점들을 겪지는 않지만 쿠키만으로 해결하기 힘든 것은 앞선 기술들을 같이 활용

### 11.6.1 쿠키의 타입

크게 두 가지 존재. 다른 점은 파기되는 시점

- 세션 쿠키(session cookie)
    - 사용자가 사이트 탐색 시 관련 설정과 선호 사항을 저장하는 임시 쿠키
    - 브라우저를 닫으면 삭제
- 지속 쿠키(persistent cookie)
    - 사이트에 설정 정보나 로그인 이름을 유지하려고 사용하는 쿠키
    - 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작해도 유지

### 11.6.2 쿠키는 어떻게 동작하는가

쿠키는 이름=값 형태의 리스트르 가지고 Set-Cookie 혹은 Set-Cookie2(확장 헤더)같은 HTTP 헤더에 포함되어 전달하고 브라우저는 쿠키 데이테베이스에 저장하고 서버에 요청

쿠키는 단순 식별번호만 제한되지 않고 다양한 정보를 쿠키에 저장

### 11.6.3 쿠키 상자: 클라이언트 측 상태

브라우저는 쿠키 정보를 저장할 책임이 있으며 이 시스템을 “클라이언트 측 상태”라고 함
쿠키 명세에는 “HTTP 상태 관리 체계(HTTP State Management Mechanism)”라고 기재

- 구글 크롬 쿠키
    - SQLite 파일에 쿠키 저장하며 한 행이 쿠키 한 개에 해당
    - 13개의 필드가 존재하며 주요 필드로는:
        - creation_utc: 쿠키가 생성된 시점으로 Jan 1, 1970 00:00:00 GMT로부터 생성된 시간을 초 단위로 기술
        - host_key: 쿠키의 도메인
        - name: 쿠키의 이름
        - value: 쿠키의 값
        - path: 쿠키와 관련된 도메인에 있는 경로
        - expire_utc: 쿠키의 파기 시점 기재되어 Jan 1, 1970 00:00:00 GMT로부터 생성된 시간을 초 단위로 기술
        - secure: 쿠키를 SSL 커넥션일 경우에만 보낼지 의미
- 인터넷 익스플로러 쿠키
    - 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장
    - 자체적인 형식을 가지고 기술되지만 이해하기 쉽게 기재

### 11.6.4 사이트마다 각기 다른 쿠키들

쿠키 전부를 모든 사이트에 보내지 않고 각 사이트에 두 개 혹은 세 개의 쿠키만을 보냄:

- 쿠키를 모두 전송하며 성능 크게 저하. 실제 통신값보다 더 큰 정보를 보내는 형태…
- 서버에 특화된 값을 가지기에 특정 사이트를 제외하고 인식하지 않는 무의미한 값
- 모든 쿠키를 전달하면 신뢰하지 않는 사이트에도 전달하는 형태로 개인정보 문제

만약 광고사들이 각 사이트에 script되어 만들어낸 쿠키일 경우, 도메인이 같기에 같은 광고사를 사용하는 웹 페이지 전체를 걸쳐 유저의 정보를 추적할 수 있기에 최신 브라우저는 설정을 통해 쿠키 사용 방식에 제약

- 쿠키 Domain 속성
    - 서버가 쿠키 생성시 Domain 속성을 기술해서 어떤 사이트에만 읽을 수 있는지 제어
    - `Set-cookie: user=”mary17’; domain=”some.com”`
    - 사용자가 some.com의 도메인을 사용하는 곳이면 cookie는 항상 서버로 전송
- 쿠키 Path 속성
    - 웹 사이트 일부에만 적용 가능하도록 설정
    - `Set-cookie: pref=compact; domain=”some.com”; path=/autos/`
        - [some.com](http://some.com) 접속 시 → mary17만 획득
        - [some.com/autos/**에](http://some.com/autos/**에) 접속 시 → mary17 및 compact 정보 획득

### 11.6.5 쿠키 구성요소

Version 0 쿠키(”넷스케이프 쿠키”)와 Version 1 쿠키(”RFC 2965”)
Version 1 쿠키는 Version 0 쿠키의 확장으로 널리 쓰이지 않음

HTTP 1.1 명세 일부로 기술 X

### 11.6.6 Vesion 0(넷스케이프) 쿠키

최초의 쿠키로 넷스케이프에서 정의
Set-Cookie 응답 헤더와 Cookie 요청 헤더 사용

```tsx
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: name=value1 [; name2=value2] ....
```

- 이름=값(name=value)
    - 필수 속성으로 표현 시 큰따옴표로 감싸지 않고 세미콜론,  쉼표, 등호, 공백을 포함 X
    - `Set-Cookie: customer=Mary`
- Expires
    - 선택 속성으로 쿠키의 생명주기를 가리키는 날짜 문자열 표현. 날짜가 지나면 쿠키는 삭제
    - 타임 존은 GM로만 표현하고 날짜 요소 간 구분자는 대시(-)
    - 해당 속성이 없으면 세션이 끝날 때마다 파기
    - `Set-Cookie: customer=Mary; expires=Wednesday, 09-Nov-99 23:12:40 GMT`
- Domain
    - 선택 속성으로 기술된 도메인으로만 쿠키를 전송
    - 도메인이 명시되어 있지 않으면 Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 설정
    - `Set-Cookie: customer=Mary; domain="joes-hardware.com"`
- Path
    - 선택 속성으로 서버에 있는 특정 문서에만 쿠키 전달 가능
    - /foo로 작성되어 있다면 path/foo 하위로만 쿠키 전달
    - 명시되어 있지 않으면 Set-Cookie 응답을 전달하는 URL의 경로가 사용
    - `Set-Cookie: customer=Mary; domain="joes-hardware.com"`
- Secure
    - 선택 속성으로 포함되어 있으면 SSL 연결일 때만 쿠키 전송
    - `Set-Cookie: customer=Mary; secure`

서버로 요청으로 보낼 때는 위 정보들에 부합하는 쿠키를 모아서 아래와 같이 전송
`Cookie: customer=Mary; seesion-id=10000033`

### 11.6.7 Version 1(RFC 2965) 쿠키

> **GPT 확인 결과 현재 25년도에도 사용 X**
> 

Set-Cookie와 Cookie2 헤더가 표준이며 Version 0과 호환
넷스케이프보다 복잡하며 아직 모든 브라우저가 완전히 지원X

추가된 주요 변경 사항은:

- 쿠키마다 그 목적을 설명하는 설명문 존재
- 파기 주기에 상관없이 브라우저가 닫히면 쿠키를 강제로 삭제 가능
- 절대 날짜 값 대신에 초 단위의 상대 값으로 쿠키의 생명주기를 결정할 수 있는 Max-Age
- URL의 포트번호도 쿠키 제어에 추가
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 요청
- 호환되는 버전 번호
- 사용자 이름과 추가적이 키워드 구별위해 Cookie헤더에 $ 접두어 존재

![스크린샷 2025-07-31 오후 2.37.39.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Feeb5e716-b8ce-4155-89f9-767da593568a%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-31_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.37.39.png/size/w=1920?exp=1754016225&sig=5Ak-0z2Zq32JLDaVis7vPE8M34HUXzMEzjpAOMpx3Wk&id=241438a5-b001-808f-9a3e-f9cbbb10b1a9&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- 이름=값(name=value)
    - 필수 속성으로 이름=값 형태로 기재하며 “$”예약어라서 쿠키 이름이 “$”로 시작하면 안 됨
- Version
    - 필수 속성으로 쿠키의 버전을 가리키는 정수값
    - `Set-Cookie2: Part="Rocket"; Version="1"`
- Comment…..등등

서버에 요청을 보낼 때 Cookie는 아래와 같이 표현

```tsx
Cookie: $Version="1"
				ID="294123"; $Domain=".joes-hardware.com";
				color="blue"
				Coupon="hammer027"; $Path="/tools";
				Coupon="asdasd1"; $Path="/tools/cordless"
```

**버전 협상**

Cookie2 요청 헤더는 다른 버전을 지원하는 클라이언트와 서버 간 호환성을 협상하는 용도로 사용

서버가 Cookie2 헤더를 인식한다면 Set-Cookie2로 응답 헤더를 응답 전달
클라이언트는 서버로부터 받은 버전에 따라서 Cookie 헤더 버전을 결정

- Version 0 Set-Cookie → Cookie
- Version 1 Set-Cookie2 → Cookie2

### 11.6.8 쿠키와 세션 추적

![스크린샷 2025-07-31 오후 3.14.28.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F0e4f0292-0bef-4e3e-8a1c-a338e3564118%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-31_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.14.28.png/size/w=1920?exp=1754016254&sig=tDE_vAcMEFmSGw-MlrgmOHDZnqhl4pcbfhN-YOOzZ80&id=241438a5-b001-80fd-a008-efaddefdeb0c&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

1. 브라우저가 Amazon.com의 루트 페이지를 처음 요청
2. 서버는 클라이언트를 전자상거래 소프트웨어 URL로 리다이렉트
3. 클라이언트는 리다이렉트 URL로 요청
4. 리다이렉트를 보내면서 두 개의 쿠키를 첨부하여 응답 반환
5. 클라이언트는 새로운 URL에 쿠키 두 개를 첨부하여 다시 요청
6. 서버는 다시 리다이렉트를 보내면서 쿠키를 한 개 첨부하여 응답 반환
7. 클라이언트는 home.html 요청보내면서 네 개의 쿠키를 첨하여 요청
8. 서버 콘텐츠 응답 반환

### 11.6.9 쿠키와 캐싱

쿠키와 캐싱에 관련된 규칙은 잘 정리되어 있지 않기에 문서 캐싱에 주의 필요

- 캐시되지 말아야 할 문서가 있다면 표시
    - 문서가 Set-Cookie를 제외하고 캐시를 해도 되면 명시적으로 `Cache-Control: no-cache=”Set-Cookie”` 기재
- Set-Cookie 헤더를 캐시 하는 것에 유의
    - Set-Cookie 헤더의 응답이 캐싱되면 모든 유저에게 같은 cookie가 날라갈 수 있기에 사용자 추적 실패
    - 어떤 캐시는 응답 저장전에 Set-Cookie를 제거하기 때문에 필요한 cookie를 못 받을 수도 있음
    - 위 두 문제들을 해결하기 위해 캐시가 클라이언트로 보내기 전 재검사 요청을 하여 cookie 추가 가능
        - `Cache-Control: must-revalidate, max-age=0`
- Cookie 헤더를 가지고 있는 요청을 주의
    - 요청에 Cookie가 있다는 것은 개인 정보를 포함할 가능성이 높기에 응답값이 캐시되지 않도록 주의

### 11.6.10 쿠키, 보안 그리고 개인정보

쿠키의 개인정보를 누가 받는지 명확히 알고 개인정보 정책에만 유의한다면, 쿠키는 위험성보다 세션 조작이나 트랜잭션 상의 편리함이 더 큰 존재

# 12장. 기본 인증

## 12.1 인증

### 12.1.1 HTTP의 인증요구/응답 프레임워크

HTTP 자체에 인증을 요구하는 메서드가 존재하고 이를 “HTTP 인증 프레임워크”라고 기재
401 상태코드와 Authenticate

```tsx
// 응답
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="MySite"

// 요청
GET /private HTTP/1.1
Host: mysite.com
Authorization: Basic dXNlcjpwYXNz
```

### 12.1.2 인증 프로토콜과 헤더

기본 인증과 다이제스트 인증(다이제스트는 13장에서)

| 단계 | 헤더 | 설명 | 메서드/상태 |
| --- | --- | --- | --- |
| 요청 |  | 첫번 째 요청에는 인증 정보X | GET |
| 인증요구 | WWW-Authenticate | 401 상태 정보와 WWW-Authenticate 헤더에 서버에 있는 비밀번호 관련 영역을 기재 | 401 Unauthorized |
| 인증 | Authorization | 인증 알고리즘과 Authorization 헤더에 사용자 이름 + 비밀번호를 기술하여 서버에 요청 | GET |
| 성공 | Authorization-Info | 인증 정보가 부합하면 문서와 함께 응답하며 인증 세션에 관한 추가 정보가 있다면 Authorization-Info에 기술하여 응답 | 200 OK |

### 12.1.3 보안 영역

웹 서버는 기밀문서를 보안 영역(realm)그룹을 나눔
12.1.2의 표에서 인증요구를 서버에서 클라이언트로 물어볼 때 아래와 같이 realm영역이 기재되어 서버가 요청하는 권한의 범위를 알 수 있다

`WWW-Authenticate: Basic realm="Corporate Financials"`

## 12.2 기본 인증

### 12.2.1 기본 인증의 예

![스크린샷 2025-08-01 오전 10.59.35.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F4243cab1-a6fa-4e78-921f-f17e41ff5ba5%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-01_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.59.35.png/size/w=1920?exp=1754016280&sig=p-6s2eki330Nm2vmWbv5-qfRWyjbvgl1TRlOSR7qRPk&id=242438a5-b001-8086-8d2b-dc60784d8af7&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

1. jeff.png를 서버에 요청
2. 접근하는데 필요한 비밀번호를 요구하는 401 Authorization Required를 응답
3. 클라리언트는 사용자 이름과 비밀번호 입력창을 띄고 사용자 입력 완료 시, 콜롤으로 이어붙이고 base64 인코딩하여 Authorization헤더이 넣고 서버에 요청
    1. base64 인코딩을 하여 네트워크 트래픽에서 사용자 이름과 비밀번호가 노출 X
4. 서버는 디코딩하고 검사 후 문제 없으면 200 OK를 보내면서 응답

### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩

![스크린샷 2025-08-01 오전 11.13.26.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F6d93908b-5824-468d-a5e4-c40327adb57f%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-01_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.13.26.png/size/w=1920?exp=1754016302&sig=kJUOOj8ZVUI5Fz-JH-4r9dEYIixBFbKv7iyivHShHAA&id=242438a5-b001-80e3-a3d8-c287dfc0fe3b&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- 사용자 이름이 brian-totty이고 비밀번호가 Ow!라면 → “brian-totty:Ow!”를 생성
- 생성된 문자 “brian-totty:Ow!”를 base64 인코딩하여 복잡한 문자열 생성

### 12.2.3 프락시 인증

프락시를 통해서 들어오는 단계 앞에서 인증을 요구할 수 있으며 절차는 기본 인증과 동일
다만 쓰이는 코드와 헤더 이름이 다름

| 웹 서버 | 프락시 서버 |
| --- | --- |
| 401 | 407 |
| WWW-Authenticate | Proxy-Authenticate |
| Authorization | Proxy-Authorization |
| Authorization-Info | Proxy-Authorization-Info |

## 12.3 기본 인증의 보안 결함

- 인코딩한 값을 보내지만 누구나 디코딩을 할 수 있다. 따라서 문제가 된다면 모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나 보안이 더 강화된 다이제스트 인증을 사용하는 것이 더 좋다
- 더 복잡한 방식으로 인코딩이 되어 있더라고 내용 자체를 원 서버에게 보내면 인증 성공 후 서버에 접근 가능
- 사용자 대부분이 동일한 아이디와 비밀번호를 사용하기에 도용되어 중요 사이트에서 사용 가능
- 프락시나 중개자에 의해서 본래 의도가 바뀌는 경우, 기본 인증은 정상적인 동작 X
- 가짜 서버에게 연결되어 민감 정보를 보날 수도 있음
