# 상현
# 4주차: 5장 웹서버

## 5.1 다채로운 웹 서버

“웹 서버”라는 용어는 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비 양쪽을 지칭

### 5.1.1 웹 서버 구현

HTTP 및 그와 관련된 TCP 처리의 구현체

- 리소스 관리
- 웹 서버 설정, 통제, 확장 기능 제공

웹 서버의 여러 가지 형태:

- 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치 및 실행
- 관리 콘솔로 제공

### (MDN 내용 추가)

> [웹 서버란 무엇일까?](https://developer.mozilla.org/ko/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_web_server)
> 

하드웨어, 소프트웨어 혹은 두 개가 같이 동작하는 것을 의미 가능

- (하드웨어 측면) 소프트웨어와 website 컴포넌트 파일(HTML, JS, CSS, images)들을 저장하는 컴퓨터
- (소프트웨어 측면) 웹 사용자가 어떻게 호스트 파일들에 접근하지는 관리

“정적 웹 서버”는 단순히 파일을 전송
“동적 웹 서버”, 정적 웹 서버 + 추가 소프트웨어(애플리케이션 서버와 데이터 베이스),는 웹 페이지 생성을 위해 애플리케이션 서버에서 데이터 조회 후 HTML을 채움

### 5.1.2 다목적 소프트웨어 웹 서버

아파치, W3C의 직소(Jigsaw), Nginx

### 5.1.3 임베디드 웹 서버

일반 소비자용 제품(프린터, 가전제품 등등)에 내장될 목적으로 만들어진 작은 웹 서버

## 5.2 간단한 펄 웹 서버

perl로 작성된 서버에 대한 내용

## 5.3 진짜 웹 서버가 하는 일

![스크린샷 2025-07-02 오후 12.10.05.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F19cdf8e6-5683-419a-9108-3ae2e598a187%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.10.05.png/size/w=1920?exp=1751506879&sig=lsb1lFheGb5bx3TFyS37Ao4Jg_lRkIf2Nrmd-gMBxWs&id=224438a5-b001-802c-9e71-f23e68aadf24&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

1. 커넥션을 맺는다 - 클라이언트의 접속을 받아들이거나 원치 않은 클라이언트라면 닫음
2. 요청을 받는다 - HTTP 요청을 메시지를 네트워크로부터 읽음
3. 요청을 처리 - 요청 메시지를 해석하고 행동
4. 리소스에 접근 - 메시지에서 지정한 리소스 접근
5. 응답 반환 - 응듭을 클라이언트로 반환
6. 트랜잭션 로그 기록 - 로그파일에 트랜잭션 완료 기록

## 5.4 단계 1: 클라이언트 커넥션 수락

### 5.4.1 새 커넥션 다루기

새 커넥션이면 목록에 추가하고 데이터 요청을 준비.
인가되지 않거나 악의적으로 판단된 커넥션의 경우 웹 서버는 마음대로 거절하거나 즉시 닫기 가능

### 5.4.2 클라이언트 호스트 명 식별

대부분 웹 서버는 “역방향 DNS”를 사용해서 클라이언트 IP 주소를 클라이언트 호스트 명으로 변환되도록 설정
GPT 확인시, 로깅에 유리하느데 IP로만 기재되어 있으면 요청자를 사람이 파악하기 어렵기에 domain name으로 변환시킬 시 사용자 친화적으로 활용 가능

그러나, 역방향 DNS는 시간 소요가 있기에 특정 상황에서만 허용(특정 확장자(`.html`, `.cgi`에 대해서만 lookup)

```scheme
HostnameLookups off

<Files ~ "\.(html|htm|cgi)$">
    HostnameLookups on
</Files>
```

### 5.4.3 ident를 통해 클라이언트 사용자 알아내기

몇몇 웹 서버는 IETF ident 프로토콜을 지원을 한다.
IETF ident 프로토콜은 사용자 정보를 보내서 서버가 로깅을 하여 추후 어떤 사용자가 HTTP 커넥션을 초기화했는지 알아낼 수 있다.

그러나, 공공 인터넷에서는 다음을 포함한 여러 이유로 잘 작동하지 않는다:

- 많은 클라이언트들이 identd 신원확인 프로토콜을 실행하지 않음
- ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연
- 방화벽이 ident 트래픽을 block
- ident 프로토콜은 조작하기 쉬움
- ident 프로토콜은 가상 IP 주소를 잘 지원 안 함
- 클라이언트 사용자 이름 노출로 프라이버시 침해 우려

## 5.5 단계 2: 요청 메시지 수신

웹 서버는 요청 메시지를 파싱할 때, 웹 서버는 다음과 같은 일 수행

- 요청줄을 파싱하여 요청 메서드, 지정된 리소스 식별자, 버전 번호 탐색
- 메세지 헤더 일기
- (존재한다면) 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄 찾기
- 요청 본문이 있다면 읽기

### 5.5.1 메세지의 내부 표현

![스크린샷 2025-07-02 오후 2.46.38.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F59770997-a0da-4461-b39a-998882c34104%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.46.38.png/size/w=1920?exp=1751506904&sig=gBW6kHB2s0O-W4J71WruG5Abk2Ffcbf_uT4ZV_FOKB0&id=224438a5-b001-80e0-8b73-dbd9bfb1fecb&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장.

### 5.2.2 커넥션 입력/출력 처리 아키텍처

![스크린샷 2025-07-02 오후 2.48.34.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F252ec62b-00e6-45d3-a77b-456792437db2%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.48.34.png/size/w=1920?exp=1751506928&sig=uPawAdWgkAFMPaSWj1LDq7ujsiMbtCYYXvXGCDC1lnk&id=224438a5-b001-80da-abf9-f36f1b7ee730&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- **단일 스레드 웹 서버:** 한 번에 하나씩 요청 처리. 처리 될 때까지 다른 일을 못 하기에 성능 문제 존재\
- **멀티프로세스와 멀티스레드 웹 서버**: 요청을 처리할 프로세스를 미리 만들 수도, 요청때마다 만들 수도 있지만 많은 메모리를 차지하기에 스레드/프로세스의 최대 개수 제한
- **다중 I/O 서버:** 모든 커넥션을 감시하고 커넥션의 작은 양을 처리 → 처리 완료 후 상태 변경하여 다시 커넥션 목록으로 이동 → 다시 커넧션의 작은 양 처리 반복
- **다중 멀티스레드 웹 서버:** 멀티쓰레드와 다중 I/O를 결합한 형태

## 5.6 단계 3: 요청 처리

서버는 요청에 대해서 처리한다

## 5.7 단계 4: 리소스의 매핑과 접근

웹 서버가 클라이언트에 콘텐츠를 전달하려면 그전에 요청 메시지의 URI에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아서 그 콘텐츠의 원천 식별 필요

### 5.7.1 Docroot

리소스 매핑의 가장 단순한 형태는 요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것.
일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 콘덴츠를 위해 예약 → 이 폴더는 “문서 루트” 혹은 “docroot”로 지칭

```scheme
// httpd.conf

DocumentRoot /usr/local/httpd/files
```

- **가상 호스팅된 docroot**
    - 각 사이트에 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅
    - 요청의 URI나 Host헤더에서 얻은 IP 주소나 호스트 명을 이용해 올바른 문서 루트 식별
    - 아파치에서는 VirtualHost 블록을 활용하여 지정
- **사용자 홈 디렉터리 docroots**
    - 한 대의 웹 서버에서 각자의 개인 웹사이트 경로를 지정
    - 보통 ‘/’과 ‘~’ 다음에 사용자 이름 지정하여 개인 문서 루트 지정

### 5.7.2 디렉터리 목록

디렉터리 URL에 대한 요청을 받을 수 있으며 다음과 같이 해동 가능

- 에러 반환
- 디렉터리 대신 특별한 ‘색인 파일’ 반환
- 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지 반환

대부분의 웹 서버는 디렉터리 안에서 index.html 또는 index.htm 파일을 찾고 반환 하는데, DirectoryIndex 지시자를 통해서 나열된 순으로 파일을 반환 가능

```scheme
DirectoryIndex index.html index.htm home.html home.htm index.cgi
```

그러나, 디랙테리 색인 기능 사용 시 일반적으로 발견한 수 없는 파일도 드러나게 되는 단점이 있다.

### 5.7.3 동적 콘텐츠 리소스 매핑

**동적 매핑**: 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑

웹 서버는 요청받은 URI가 동적 매핑에 해당한다면, 주소 내부에 있는 애플리케이션 서버난 CGI 스크립트를 실행 시켜 동적 컨텐츠를 생성 후 클라이언트에 반환

### (GPT 5.7.3 동적 콘텐츠 리소스 매핑)

**✅ HTTP/1.x 시대 (특히 1.0, 1.1)**

- **Nginx (또는 Apache)**:
    
    클라이언트와 TCP 커넥션을 직접 맺고,
    
    - **정적 파일**은 직접 서빙 (HTML, CSS, 이미지 등)
    - **동적 요청**은 애플리케이션 서버나 CGI로 전달 (FastCGI, PHP-FPM, mod_php 등)
- **동적 처리 담당**:
    
    `.cgi`, `.php`, `.jsp`, `.py` 등
    
    → 해당 요청은 **프로세스를 새로 띄우거나**, **백엔드 프로그램에 요청을 위임**해 동적으로 HTML 등 생성
    

**✅ HTTP/2 시대 이후 (특히 SPA + API 중심 아키텍처)**

- **Nginx 역할 축소**:
    
    주로 리버스 프록시 역할만 수행.
    
    커넥션 유지 및 분배만 담당 (`proxy_pass`, `stream`, `TLS termination`)
    
- *애플리케이션 서버(예: Node.js, Spring 등)**가:
    - 정적 리소스도 직접 서빙 (SPA 빌드 결과물)
    - 동적 API 처리도 전부 담당
        
        → 즉, **모든 요청**을 받아 처리 (정적+동적 통합 처리)
        

**❓왜 애플리케이션 서버가 모든 것을 담당하게 되었는가?**

1. **SPA 구조의 등장**:
    
    HTML 하나만 받고, 이후 모든 요청은 JS가 API로 처리 → 정적/동적 구분이 모호해짐
    
2. **HTTP/2 멀티플렉싱**:
    
    커넥션 하나로 다수 요청을 처리 가능 → 굳이 웹 서버가 커넥션 관리 + 요청 분기를 따로 할 필요가 없음
    
3. **배포 단순화**:
    
    백엔드 서버 하나에 모든 기능을 넣고 컨테이너로 배포하면 관리 편함
    
4. **프록시 오버헤드 제거**:
    
    요청을 다시 넘기는 proxy 계층이 줄어들면 latency가 줄고 성능이 나아짐
    

### 5.7.4 서버사이드 인클루드(Server-Side Includes, SSI)

어떤 리소스가 서버사이드 인클루드 설정되어 있다면 서버는 그 리소스의 콘텐츠를 클라이언트에게 보내기 전에 처리
특별한 패턴(아래 주석)을 인식하여 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환

```html
<html>
<body>
  <h1>Welcome</h1>
  <!--#include file="navbar.html" -->
  <p>This is my page!</p>
  <!--#include file="footer.html" -->
</body>
</html>

```

### 5.7.5 접근 제어

웹 서버는 각각의 리소스에 접근 제어 할당 가능.
IP 확인 또는 비밀번호 확인을 통하여 체크 가능

## 5.8 단계 5: 응답 만들기

### 5.8.1 응답 엔티티

본문에는 주로 다음을 포함:

- MIME 타입을 서술하는 Content-Type 헤더
- 응답 본문의 길이를 서술하는 Content-Length 헤더
- 실제 응답 본문의 내용

### 5.8.2 MIME 타입 결정하기

웹 서버는 응답 본문의 MIME 타입 결정해야 함.

- **mime.types**:
    - 파일 이름의 확장자 사용
- **매직 타이핑(Magic typing)**
    - 아파치 웹 서버 같은 경우에 파일 내부를 검사하고 특정 패턴에 대한 테이블(매직 파일이라고 호칭)에 해당하는 패턴이 있는 지 확인하여 MIME 타입 결졍. 느리긴 하지만 표준 확장자가 없는 이름일 경우 편리
- **유형 명시(Explicit typing)**
    - 파일 확장자나 내용에 상관없이 어떤 MIME 타입을 갖도록 웹 서버가 설정 가능
- **유형 협상(Type negotiation)**
    - 한 리소스가 여려 종류의 문서 형식으로 되어 있을 수 있음. 웹 서버는 사용자와 협상 과정을 통해 사용하기 가장 좋은 형식을 판별할 수 있음
        - "사용자와 협상 과정"**이란?
            - 클라이언트가 `Accept` 헤더를 보낼 경우, 서버가 그에 맞는 파일을 선택 가능
                - 예:
                    - 클라이언트: `Accept: application/xml, text/html`
                    - 서버: `/foo.xml`, `/foo.html` 중에서 선택

### 5.8.3 리다이렉션

리다이렉션은 다음 경우에 유용

- **영구히 리소스가 옮겨진 경우**
    - 리소스가 새 URL이 부여되어 위치를 옮겼거나 이름이 바뀌었을 때 301 status code를 전달
- **임시로 리소스가 옮겨진 경우**
    - 임시로 옮겨지거나 이름이 변경된 경우, 303 또는 307 status code 전달
- **URL 증강**
    - 문맥 정보를 포함시키기 위해 다른 URL로 리다이렉트.
        - 현재 URL에서 특정정보를 포함하여 다시 다른 URL로 옮기고 옮겨진 URL에서 다시 요청 처리
    - 303 또는 307 status code 전달
- **부하균형**
    - 현재 요청받은 서버가 과부하라면 부하를 덜기 위해서 다른 서버로 리다이렉트
    - 303 또는 307 status code 전달
- **친밀한 다른 서버가 있을 때**
    - 서버는 요청한 클라이언트 정보를 갖고 있는 다른 서버로 리다이렉트 가능
    - 303 또는 307 status code 전달
- **디렉터리 이름 정규화**
    - URI 끝에 빝금(/)을 빠뜨렸다면 대부분의 웹 서버는 상대적인 경로가 정상적으로 동작할 수 있도록 빝금을 추가한 URI로 리다이렉트

## 5.9 단계 6: 응답 보내기

제곧내…별거 없음

## 5.10 단계 7: 로깅

트랜잭션이 완료되면 어떻게 수행되었는지에 대한 로그파일 작성
