## 5.1.1 웹 서버 구현

- 웹 서버는 HTTP와 관련된 TCP 처리를 포함해 리소스 제공, 설정, 통계, 접근 제어 등 기능을 제공.
- TCP 커넥션 관리와 운영 체제 의존적인 기능도 포함.
- 대표 구현 방식:
  1. 소프트웨어 설치형 웹 서버 (Apache 등)
  2. 마이크로프로세서에 탑재된 임베디드 웹 서버

## 5.1.2 다목적 소프트웨어 웹 서버

- 범용 OS에 설치하여 동작하며, Apache, Microsoft IIS, nginx 등이 대표적.
- 다양한 웹 서버 프로그램이 존재하고 대부분 오픈소스.
- URL이 있는 모든 웹 리소스 제공 가능.

## 5.1.3 임베디드 웹 서버

- 소비자용 전자기기에 내장되는 소형 웹 서버.
- 설정용 인터페이스 제공 (예: 라우터 설정 페이지).
- 리소스와 기능은 제한적임.

# 5.3 진짜 웹 서버에서 하는 일

1. 클라이언트 접속 수락 (커넥션 맺기)
2. HTTP 요청 수신
3. 요청 메시지 해석
4. 리소스 접근
5. 응답 메시지 생성
6. 응답 전송
7. 트랜잭션 로그 기록

![스크린샷 2025-07-07 오전 7.02.44.png](attachment:35eb1ed2-6d4e-4dc4-96b2-81f5672dcc3e:스크린샷_2025-07-07_오전_7.02.44.png)

# 5.4 단계 1: 클라이언트 커넥션 수락

## 5.4.1 새 커넥션 다루기

- 클라이언트가 웹 서버의 포트로 접속 시, 웹 서버는 새로운 TCP 커넥션을 수락한다.
- 이후 커넥션을 처리할 핸들러(별도 프로세스/스레드 등)를 만든다.

## 5.4.2 클라이언트 호스트 명 식별

- 웹 서버는 클라이언트의 IP 주소를 DNS 역질의(reverse DNS lookup)하여 호스트 이름으로 바꿀 수 있다.
- 이 작업은 느리고 필수가 아님.
- 대부분의 서버는 `HostnameLookups` 옵션을 통해 이 기능을 비활성화한다.

## 5.4.3 ident를 통해 사용자 알아내기

- `ident 프로토콜`은 클라이언트 컴퓨터에서 **TCP** 커넥션의 `사용자 이름을 알아내는 방식`
- ident는 TCP 커넥션 양 끝의 포트 번호를 이용해 클라이언트의 운영 체제에 질의
- 웹 서버는 ident 서버(113번 포트)를 통해 클라이언트 OS에 사용자 이름 요청을 보낼 수 있음
- 그러나 이 기능은 보안 문제가 많고, **클라이언트 시스템에** ident 데몬이 실행 중일 때만 작동
- 대부분 서버에서는 이 기능을 사용하지 않으며, **불**필요한 보안 노출을 막기 위해 꺼놓는 경우가 많음

# 5.5 단계 2: 요청 메시지 수신

클라이언트가 보낸 HTTP 요청 메세지를 파싱할 때 웹서버는 다음과 같은 일을 수행

- 요청줄을 파싱하여 요청 메서드,. 지정된 리소스의 식별자, 버전 번호를 찾음
  - 각 값은 스페이스 한 개로 분리되어 있음
  - CRLF 문자열로 끝남
- 메시지 헤더들을 읽음.
  - 각 메시지 헤더는 CRLF로 끝남
- 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아냄
- 요청 본문이 있다면, 읽음
  - 길이는 Content-Length 헤더로 정의

## 5.5.1 메시지의 내부 표현

- 몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장

![스크린샷 2025-07-07 오전 7.20.17.png](attachment:aeaef860-fef5-4474-8524-fc1baa3f0102:스크린샷_2025-07-07_오전_7.20.17.png)

## 5.5.2 커넥션 입력/출력 처리 아키텍처

웹 서버는 다양한 커넥션 처리 모델을 사용할 수 있음

1. **단일 스레드 웹서버**
   - 하나의 요청만 처리
2. **멀티 프로세스와 멀티스레드 웹 서버**
   - 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드 할당
   - 너무 많은 메모리나 시스템 리소스를 소비하기 때문에 최대 개수 제한
3. **다중 IO 서버**
   - 많은 커넥션을 지원하기 위해 웹 서버는 다중 I/O 아키텍처를 채택
   - 다중 I/O 아키텍처에서는 모든 커넥션을 동시에 감시하면서 운영
   - 커넥션 상태가 바뀔 때(예: 데이터 사용 가능) 해당 커넥션에 대한 처리만 수행
   - 특정 커넥션이 준비되면, 커널은 열린 커넥션 목록 중 어떤 작업이 가능한지 알려주며, 서버는 그에 따라 해당 작업을 수행
4. **다중 멀티스레드 웹 서버**
   - 여러 CPU 코어를 효과적으로 활용하기 위해 멀티스레드 웹 서버는 다중 프로세스 기반으로 구성
   - 각 프로세스는 여러 개의 스레드를 갖고 있고, 각 스레드는 자신에게 할당된 커넥션을 감시
   - 이 구조는 CPU 자원을 최대한 활용하면서도 각 커넥션에 대해 세분화된 처리를 가능
   - 각 커넥션이 독립적으로 작업됨으로써, 전체 처리 효율이 향상

# 5.6 단계 3: 요청 처리

웹 서버가 요청을 받으면 서버는 요청으로부터 메서드, 리소스, 헤더, 본문을 얻어내어 처리

# 5.7 단계 4: 리소스의 매핑과 접근

- 웹 서버는 정적 리소스(HTML, 이미지 등) 뿐만 아니라, 동적으로 생성되는 콘텐츠도 클라이언트 요청에 따라 제공
- 이를 위해, 웹 서버는 요청 메시지의 URI를 기반으로 어떤 리소스를 제공해야 할지 판단하고, 내부적으로 적절한 경로 또는 프로그램에 매핑

## 5.7.1 Docroot

- **Docroot**
  - URI 경로를 실제 파일 시스템 내의 경로로 매핑하기 위한 기준 디렉터리
- **주의점**
  - docroot를 벗어나는 경로에 접근할 수 없도록 주의
  - 고성능 웹 서버는 보통 URI에 맞춰 문서 루트 내부 파일을 찾는 방식보다 더 정제된 방식 사용
  ![스크린샷 2025-07-07 오전 7.34.44.png](attachment:24de6a88-6501-4ba7-928f-13e0b5907f66:스크린샷_2025-07-07_오전_7.34.44.png)

**`가상 호스팅 Docroot`**

- 한 서버에서 여러 도메인을 운영할 때, 각 도메인에 대해 다른 `DocumentRoot`를 설정할 수 있음
- 클라이언트 요청의 `Host` 헤더를 기준으로 어떤 사이트인지 판단
  ![스크린샷 2025-07-07 오전 7.36.19.png](attachment:54000f2d-8555-410b-b007-04403170fce3:스크린샷_2025-07-07_오전_7.36.19.png)

**`사용자 홈 디렉터리 docroots`**

- 사용자의 홈 디렉터리 하위에 웹 디렉터리(`public_html`)를 두고, 이를 개별 사이트로 서비스하는 방식
  ![스크린샷 2025-07-07 오전 7.37.05.png](attachment:6b44017e-034a-4111-a0ff-506635d3ffa0:스크린샷_2025-07-07_오전_7.37.05.png)

## 5.7.2 디렉터리 목록

- 클라이언트가 디렉터리 경로만 요청한 경우, 서버는 다음 중 하나를 수행
  - 에러 반환
  - 디렉터리 내부 파일 목록 보여줌
  - `index.html` 등의 디폴트 파일 반환
  - HTML 페이지 형태로 목록을 반환

## 5.7.3 동적 콘텐츠 리소스 매핑

- 웹 서버는 URI를 동적으로 **프로그램 실행**에 연결할 수 있음
  ![스크린샷 2025-07-07 오전 7.39.41.png](attachment:5f5e9eae-6737-484e-81eb-62dd103c1744:스크린샷_2025-07-07_오전_7.39.41.png)

## 5.7.4 서버사이드 인클루드 (SSI)

- `.shtml` 또는 특정 설정된 HTML 문서 내에서 스크립트를 삽입해 출력에 반영하는 기법
- 서버는 응답을 클라이언트에 보내기 전, 변수 처리나 조건문 등을 수행하여 **동적으로 HTML을 생성**
- HTML 주석에 포함된 SSI 구문을 찾아 처리

## 5.7.5 접근 제어

- 웹 서버는 리소스마다 접근 제어가 가능
- 클라이언트의 IP 주소에 따라 허용/차단하거나, 비밀번호 인증을 요구할 수 있음

# 5.8 단계 5: 응답 만들기

- 서버가 리소스를 식별한 뒤, 요청 메시지에 대한 처리를 수행하고 나면 응답 메시지를 생성
- 응답 메시지는 다음 요소를 포함
  - 응답 상태 코드
  - 응답 헤더
  - 응답 본문 (필요한 경우)

## 5.8.1 응답 엔터티

- 트랜잭션에서 응답 본문이 필요하다면, 서버는 이를 생성해 메시지에 포함시킴
- 응답 메시지에 포함되는 일반적인 구성 요소
  - `Content-Type`: 본문의 MIME 타입을 명시
  - `Content-Length`: 본문의 길이를 명시
  - 실제 응답 본문의 내용 (예: HTML 문서, 이미지, JSON 등)

## 5.8.2 MIME 타입 결정하기

다음은 MIME 타입과 리소스를 연결하는 여러가지 방법이다.

1. **mime.types**
   - 웹서버는 MIME 타입을 나타내기 위해 파일 이름의 확장자를 사용할 수 있음
   - 각 파일 확장자에 대응되는 MIME 타입을 정의한 파일을 탐색한다.
   - 확장자 기반 연계는 가장 흔한 방법이며, `/etc/mime.types` 같은 파일에 등록됨
2. **매직 타이핑**
   - 파일의 내용을 읽고, 알려진 바이트 패턴과 비교하여 MIME 타입을 유추
   - 파일 확장자가 없거나 잘못된 경우에도 사용할 수 있는 방식
   - 속도는 느리지만 유용성이 높음
3. **유형 명시**
   - 서버 설정에서 특정 파일 또는 디렉터리에 대해 MIME 타입을 강제로 지정할 수 있음
   - 확장자나 내용과 무관하게 작동

## 5.8.3 리다이렉션

웹 서버는 요청에 대해 **리다이렉션 응답**을 보낼 수 있으며, 이는 보통 3xx 상태 코드를 통해 전달

1. **영구 리소스가 옮겨진 경우**
   - `301 Moved Permanently`
   - URL이 변경되었고, 새 URI를 클라이언트에게 알려줌
2. **임시로 리소스가 옮겨진 경우**
   - `302 Found`, `307 Temporary Redirect`
   - 리소스가 일시적으로 다른 위치에 있을 때 사용
3. **URL 증강**
   - 서버가 요청된 URL에 쿼리나 다른 정보를 추가해 새 URL로 리다이렉션할 수 있음
   - 303 / 307
4. **부하 균형**
   - 요청 분산을 위해 리다이렉션을 사용하는 경우
   - 303 / 307
5. **친화성 있는 다른 서버가 있을 때**
   - 사용자 정보를 고려해 더 적절한 서버로 리다이렉션
   - 307
6. **디렉터리 이름 정규화**
   - 디렉터리 요청에서 `/`가 누락된 경우 등, 서버는 URI를 수정하여 리다이렉션함

이후는 그냥 응답 보내고 로깅
