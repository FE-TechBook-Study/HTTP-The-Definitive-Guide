HTTP는 다음을 보장한다.

- 객체는 올바르게 식별되므로(Content-Type 미디어 포맷과 Content-Language 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
- 객체는 올바르게 압축이 풀릴 것이다.(Content-Length 와 Content-Encoding 헤더를 이용해서).
- 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서).
- 사용자의 요구를 만족할 것이다(내용 협상을 위한 Accept 관련 헤더들에 기반하여).
- 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용해서).
- 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 Content-MD5 체크섬을 이용해서).

이 모든 것을 가능하게 하기 위해, HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

이 장에서 다루는 내용들

- HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 포맷과 동작방식
- 어떻게 HTTP가 엔터티 본문의 크기를 기술하며, 크기를 측정하기 위해 HTTP가 무엇을 요구하는지
- 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔터티 헤더들(콘텐츠의 포맷, 문자, 언어를 기술하기 위해 사용된다)
- 공간을 적게 차지하고 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용하는, 디코딩 가능한 콘텐츠 인코딩
- 특정 종류의 콘텐츠의 송수신을 개선하기 위해 HTTP가 데이터를 실어 나르는 방식을 수정하는 전송 인코딩. 그 중에서도 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 조각으로 쪼개 전달하는 청크 인코딩
- 클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는태그, 라벨, 시간, 체크섬의 모음
- 콘텐츠의 버전 번호처럼 동작하는 검사기들(웹 애플리케이션에게 그들이 최신 콘텐츠를 가지고 있음을 확신할 수 있게 해준다). 그리고 객체를 최신으로 유지하기 위해 설계된 HTTP 헤더 필드들
- 중단되었던 다운로드를 중단된 지점에서부터 재개하고자 할 때 유용한 범위 요청
- 클라이언트가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델타 인코딩 확장
- 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는, 엔터티 본문의 체크섬

# 1. 메시지는 컨테이너, 엔터티는 화물

HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다. 

- Content-Type: 엔터티에 의해 전달된 객체의 종류
- Content-Length: 전달되는 메시지의 길이나 크기
- Content-Language: 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding: 객체 데이터에 대해 행해진 변형(압축 등)
- Content-Location: 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range: 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.
- Content-MD5: 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified: 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires: 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow: 이 리소스에 대해 어떤 요청 메서드가 허용되는지 예)GET과 HEAD
- ETag: 이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.
- Cache-Control: 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지는 않다.

## 1.1 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만 담고 있기 때문에, 엔터티 헤더는 그 데이터의 의미에 대해 설명할 필요가 있다.

예를 들어, Content-Type 엔터티 헤더는 우리에게 그 데이터(이미지, 텍스트 등)을 어떻게 해석해야 하는지 말해주며,

Content-Encoding 엔터티 헤더는 우리에게 그 데이터가 압축되었거나 혹은 추가적인 인코딩이 되었는지 말해준다. 

엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

![image.png](attachment:f77e5b90-3da6-4e2f-8d8d-6bdb6f0b8490:image.png)

a: 엔터티 본문은 헤더의 끝을 의미하는 CRLF 바로 다음의 65번째 바이트로 시작하낟. 엔터티 본문은 ‘HI! I’m a message!’ 라는 ASCII 문자열을 담고 있다.

b: 엔터티 본문은 67번째 바이트로 시작한다. 엔터티 본문은 GIF 이미지에 대한 이진 콘텐츠를 담고 있다. GIF 파일은 6바이트의 버전 서명, 16비트의 너비, 16비트의 높이로 시작한다. 

# 2. Content-Length: 엔터티의 길이

Content-Length  헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.

어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다(gzip으로 압축된  텍스트 파일이라면 원래 크기가 아니라 압축된 후의 크기다.)

Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.

서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.

## 2.1 잘림 검출

옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다.

그러나 Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못한다.

클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 필요로 한다. 

메시지 잘림은 캐싱 프락시 서버에서 특히 취약하다.

만약 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못했다면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 될 것이다.

잘린 메시지를 캐시하는 위험을 줄이기 위해, 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐시하지 않는다.

## 2.2 잘못된 Content-Length

Content-Length가 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다.

HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어 있다.

## 2.3 Content-Length와 지속 커넥션 (Persistent Connection)

Content-Length는 지속 커넥션을 위해 필수다.

응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것이다.

Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다.

HTTP 애플리케이션은 Content-Length 헤더 없이는 어디까지가 엔터티 본문이고 어디부터가 다음 메시지인지 알 수 없을 것이다.

청크 인코딩을 사용할 경우에는 Content-Length 헤더 없는 지속 커넥션을 만날 수 있다.

데이터를 각각이 특정한 크기를 갖는 일련의 청크들로 쪼개어 보내어, 서버가 헤더가 생성되는 시점에서 엔터티 전체의 크기를 알 수 없다하더라도(엔터티가 동적으로 생성되고 있는 중일 수도 있으므로), 서버는 청크 인코딩을 이용해 엔터티를 잘 정의된 크기의 조각들로 전송할 수 있다.  

## 2.4 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해준ㄴ다.

만약 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.

## 2.5 엔터티 본문 길이 판별을 위한 규칙

엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙들로, 반드시 나열된 순서대로 적용되어야 한다. 

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다.
    
    이는 부가 정보에 불과하며, 실제 본문 길이를 서술하지 않는다.
    가장 중요한 예는 HEAD 응답이다. HEAD 메서드는 GET 요청을 보냈다면 받게될 응답에서 본문은 제외하고 헤더들만 보내라고 서버에게 요청한다.
    GET 응답은 Content-Length 헤더를 돌려주기 때문에, HEAD 응답 또한 그럴 것이다. 
    그러나 HEAD 응답은 본문을 갖지 않는다. 
    1XX, 204, 304 응답 또한 정보성 Content-Length 헤더를 갖지만 본문은 갖지 않는다.
    엔터티 본문을 금하는 메시지는 어떤 엔터티 헤더 필드가 존재하느냐와 상관없이 반드시 헤더 이후의 첫 번째 빈 줄에서 끝나야 한다. 
    
2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0바이트 청크’라 불리는 특별한 패턴으로 끝나야 한다.
3. 메시지가 Content-Length 헤더를 갖고 메시지 유형이 엔터티 본문을 허용한다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
만약 Content-Length 헤더 필드와 identity가 아닌 Transfer-Encoding 헤더 필드를 갖고 있는 메시지를 받았다면 반드시 Content-Length 헤더를 무시해야 한다.
왜냐하면 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식을 바꿀 것이기 때문이다. 
4. 메시지가 ‘multipart/byteranges’ 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면(Content-Length 헤더로), 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다. 
이 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다.
5. 위의 규칙에 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
클라이언트는 메시지가 끝났다는 신호를 위해 커넥션을 닫을 수 없다. 서버가 응답을 돌려줄 방법이 없기 때문.
서버만이 메시지가 끝났다는 신호를 위해 커넥션을 닫을 수 있다.
6. HTTP/1.0 과 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 유효한 Content-Length 헤더도 갖고 있어야 한다. 

# 3. 엔터티 요약

HTTP가 TCP/IP와 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯한 여러 가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.

엔터티 본문에 대한 의도치 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사를 할 수 있다. 

# 4. 미디어 타입과 차셋(Charset)

Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. 

MIME 타입은 전달되는 데이터 매체의 기저 형식(HTML 파일, 마이크로소프트 워드 문서, MPEG 비디오 등)의 표준화된 이름이다.

클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용한다.

주 미디어 타입(텍스트, 이미지, 오디오 등)으로 시작해서 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입(subtype)으로 구성된다.

![image.png](attachment:d4f215eb-48ea-4445-82a1-aa1eb5181b49:image.png)

Content-Type 헤더가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요하다.

엔터티가 콘텐츠 인코딩을 거친 경우에도 Content-Type 헤더는 여전히 인코딩 전의 엔터티 본문 유형을 명시할 것이다.

### 1. 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.

엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 ‘charset’ 매개변수가 그 대표적인 예이다.

```jsx
Content-Type: text/html; charset=iso-8859-4
```

텍스트 데이터(HTML, CSS, JS 등)는 결국 **비트(0, 1)의 집합**인데, 이것을 글자(문자열)로 바꾸려면 **문자 인코딩 방식**이 필요하다.

그 인코딩 방식을 지정하는 게 `charset` 매개변수이다.

- `text/html` → HTML 문서임
- `charset=iso-8859-4` → HTML 안의 글자는 **ISO-8859-4 인코딩**으로 저장/해석해야 함

### 2. 멀티파트 미디어 타입

HTTP는 멀티파트 본문도 지원하나,

일반적으로는 폼을 채워서 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할 때의 두 가지 경우에만 사용된다.

- 설명
    
    ### 1. 멀티파트(multipart)란?
    
    일반적으로 HTTP 본문은 **하나의 데이터**만 담습니다.
    
    예:
    
    ```
    Content-Type: text/plain
    
    Hello World!
    
    ```
    
    → 단순 텍스트 한 덩어리만 있음.
    
    그런데 어떤 경우에는 **본문 안에 여러 개의 데이터 조각**을 담아야 할 때가 있습니다. 이럴 때 쓰는 것이 **멀티파트(multipart) 미디어 타입**입니다.
    
    - 본문을 여러 부분(part)으로 나누어 전송
    - 각 part마다 고유한 헤더와 내용이 있음
    - 경계(boundary) 문자열로 구분
    
    ---
    
    ### 2. "폼을 채워서 제출할 때"
    
    브라우저에서 `<form>` 태그로 데이터를 전송할 때, 특히 **파일 업로드** 같은 상황에서 `multipart/form-data` 타입이 사용됩니다.
    
    예:
    
    ```
    POST /upload HTTP/1.1
    Content-Type: multipart/form-data; boundary=----12345
    
    ------12345
    Content-Disposition: form-data; name="username"
    
    sohee
    ------12345
    Content-Disposition: form-data; name="file"; filename="pic.png"
    Content-Type: image/png
    
    (binary data...)
    ------12345--
    
    ```
    
    → 여기서는 username(텍스트)와 file(이미지 파일)을 **한 요청 본문 안에 동시에** 담아 보냅니다.
    
    ---
    
    ### 3. "문서의 일부분을 실어 나르는 범위 응답"
    
    두 번째로는 **서버가 한 문서의 일부만 보내는 경우**입니다.
    
    예: 큰 동영상을 스트리밍하거나, 브라우저에서 파일 다운로드 중 중간에 끊겼을 때 이어받을 때.
    
    이때는 `Content-Type: multipart/byteranges` 가 쓰입니다.
    
    - 클라이언트가 `Range` 헤더로 "1~1000 바이트만 줘" 요청
    - 서버는 여러 범위(range)를 묶어서 응답
    - 각 범위가 본문 안에서 멀티파트 구조로 나뉘어 있음
    
    예:
    
    ```
    HTTP/1.1 206 Partial Content
    Content-Type: multipart/byteranges; boundary=ABC123
    
    --ABC123
    Content-Range: bytes 0-99/200
    (100 bytes of data)
    --ABC123
    Content-Range: bytes 100-199/200
    (100 bytes of data)
    --ABC123--
    
    ```
    
    ---
    
    ### 4. 정리
    
    - 멀티파트 미디어 타입은 본문을 여러 조각으로 나눌 수 있는 형식
    - **주로 두 가지 상황에서만 쓴다**
        1. **폼 제출(form-data)** → 특히 파일 업로드
        2. **범위 응답(byte-ranges)** → 큰 파일 일부만 내려줄 때

### 3. 멀티파트 폼 제출

http 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각가이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.

멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.

![image.png](attachment:8975a3ac-608d-43a5-9aa8-c638863949e6:image.png)

boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

텍스트 필드와 파일 업로드 필드로 이루어진 폼으로 데이터를 보낸다고 가정한다면, 다음과 같은 본문으로 이루어질 것이다. 

![image.png](attachment:b5579940-04db-4d2e-8065-e09604d58ad6:image.png)

### 4. 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답 또한 멀피파트가 될 수 있다. 

그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다. 

# 5. 콘텐츠 인코딩

HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 한다.

예를 들어, 느린 속도로 연골된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송 시간을 줄이기 위해 압축을 할 수있다.

서버는 제삼자가 볼 수 없도록 콘텐츠를 암호화하거나 뒤섞어서 보낼 수도 있다. 

이러한 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다.

콘텐츠 인코딩이 끝난 데이터는 엔터티 본문에 담아 수신자에게 보낸다.

## 1. 콘텐츠 인코딩 과정

1. 웹서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만(본문이 압축되거나 했다면) Content-Length는 다르다. 
콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
3. 수신측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

Content-Type 헤더는 엔터티의 원래 포맷을 기술하며, 이는 디코딩된 엔터티를 보여주기 위해 필요한 정보다. Content-Length 헤더는 인코딩된 본문의 길이를 나타낸다.

![image.png](attachment:bf875403-fbb0-44e9-afbf-c30873bbb953:image.png)

## 2. 콘텐츠 인코딩 유형

Content-Encoding 헤더는 IANA을 통해 표준화된 토큰값을 이용해서, 인코딩에 사용된 알고르짐들에 대해 기술한다.

![image.png](attachment:6129a2c8-7d65-4611-9d7f-146b72304996:image.png)

gzip, compress, deflate 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다.

이 중 gzip은 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘이다.

## 3. Accept-Encoding 헤더

서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달한다. 

만약 요청시 해당 헤더가 없다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다.(Accpet-Encoding:*을 전달한 경우도 같다).

![image.png](attachment:aef36901-9134-480c-8daf-4c0fc2a2959c:image.png)

# 6. 전송 인코딩과 청크 인코딩

콘텐츠 인코딩은 콘텐츠 포맷과 연관되어 있다.

예를 들어, 텍스트 파일은 gzip으로 압축되지만 JPEG는 gzip으로 잘 압축되지 않는다.

전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다. 

메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있다.

![image.png](attachment:79e8e23f-ae97-40e8-8b0e-47400423543d:image.png)

## 1. 안전한 전송

역사적으로, 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 ‘안전한 전송’을 위해 존재했다.

HTTP에서 젠송된 메시지의 본문이 문제를 일으키는 이유 중 두가지는 다음과 같다.

1. 알 수 없는 크기
    
    몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다.
    흔히 이 서버들은 그 사이즈를 알기 전에 데이터의 전송을 시작하려고 한다.
    HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에, 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려시도한다. 
    
2. 보안
    
    공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법도 있다. 그러나 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔치 않다.
    
- 설명
    
    ### 1. 전송 인코딩(Transfer-Encoding)이란?
    
    - `Content-Length` 헤더는 본문의 **최종 크기**를 알려줘야 브라우저가 "어디까지가 본문인지" 구분할 수 있습니다.
    - 하지만 경우에 따라서는 **본문 크기를 미리 알 수 없는 상황**이 있어요.
        
        예: 동적으로 생성되는 데이터 스트림, 실시간 로그, 압축하면서 보내는 데이터 등.
        
    - 이럴 때 쓰는 게 **전송 인코딩**입니다. 대표적으로 `chunked` 전송 방식이 있습니다.
    
    ```
    Transfer-Encoding: chunked
    
    ```
    
    이 방식에서는 본문을 **작게 쪼갠 조각(chunk)** 들로 나눠서 보내고, 각 chunk 앞에 길이를 써줍니다. 마지막에 `0\r\n\r\n`을 보내면 "끝났다"는 뜻이 됩니다.
    
    ---
    
    ### 2. 첫 번째 문제: 알 수 없는 크기
    
    - 일부 서버나 게이트웨이는 콘텐츠 전체를 다 만들어내기 전까지는 최종 크기를 알 수 없습니다.
    - 하지만 HTTP는 `Content-Length`가 필요할 때가 있죠.
    - 그래서 이 경우 서버는 본문을 chunk 단위로 잘라 보내면서, 마지막에 "끝"을 표시하는 **특별 꼬리말(trailer)** 을 붙여 전송합니다.
    - 이게 바로 `Transfer-Encoding: chunked` 방식의 핵심입니다.
    
    즉, “알 수 없는 크기” 문제를 해결하기 위해 **전송 인코딩**이 필요합니다.
    
    ---
    
    ### 3. 두 번째 문제: 보안
    
    - 초창기에는 "데이터를 네트워크 상에서 그대로 보내면 위험하니, 전송 인코딩으로 데이터를 알아보기 어렵게 섞어버리면 안전하지 않을까?" 라는 발상이 있었습니다.
    - 하지만 이건 **전송 계층 보안(SSL/TLS)** 이 보편화되면서 사실상 쓰이지 않습니다.
    - 지금은 보안이 필요하다면 HTTP 전송 인코딩이 아니라 HTTPS(TLS 암호화)를 씁니다.

## 2. Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 두 개 뿐이다.

1. Transfer-Encoding
    - 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
2. TE
    - 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.
- 설명
    
    ## 1. `Transfer-Encoding` 헤더
    
    - **응답(response) 헤더**에서 주로 쓰임.
    - “이 메시지 본문을 어떤 전송 인코딩으로 보냈다”를 나타냅니다.
    - 대표적인 값: `chunked`
    
    예시:
    
    ```
    HTTP/1.1 200 OK
    Transfer-Encoding: chunked
    
    ```
    
    → 서버가 본문 크기를 미리 몰라서 `Content-Length`를 안 쓰고, 대신 **chunked 방식**으로 잘라 보냈다는 뜻입니다.
    
    클라이언트는 이를 보고 “본문이 chunked로 오니까 조각별로 읽어야겠구나” 하고 처리합니다.
    
    ---
    
    ## 2. `TE` 헤더
    
    - **요청(request) 헤더**에서만 사용됨.
    - 클라이언트(브라우저나 앱)가 서버에게:
        
        “나는 이런 전송 인코딩을 이해할 수 있어. 필요하다면 이걸로 보내줘.” 라고 알리는 용도.
        
    - 즉, **지원 가능한 전송 인코딩 목록**을 서버에 알려줍니다.
    
    예시:
    
    ```
    GET /example HTTP/1.1
    Host: example.com
    TE: trailers
    
    ```
    
    여기서 `trailers`는 “나는 chunked encoding 뒤에 붙는 **트레일러 헤더**도 이해할 수 있다”는 의미입니다.
    
    즉, 서버가 chunked 전송 시 마지막에 추가적인 헤더들을 보내도 클라이언트가 처리 가능하다는 신호예요.
    

## 3. 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다.

각 청크를 서버는 순차적으로 보낸다.

청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.

본문이 동적으로 생성됨에 따라, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있다.

본문 전체를 모두 보낼때까지 이 단계를 반복한다.

청크 인코딩이 전송 인코딩의 한 형태이며 따라서 본문이 아닌 메시지의 속성이다.

앞서 멀티파트 인코딩은 본문의 속성이며 청크 인코딩과는 완전히 분리되어 있다.

### 청크와 지속 커넥션

클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다.

클라이언트는 서버가 커넥션을 닫을 때까지를 본문으로 간주하고 읽을 것이다.

지속 커넥션에서는, 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 한다. 콘텐츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알아내는 것이 불가능할 것이다.

청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이 딜레마에 대한 해법을 제공한다.

서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.
HTTP 응답 헤더 블럭으로 시작하고, 이어서 청크의 스트림이 온다. 

![image.png](attachment:23f09a48-017e-478c-80a9-926acd2c4720:image.png)

## 4. 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다. 

그림과 같이 송신자가 콘텐츠 인코딩을 사용해서 HTML 파일을 압축하고 그 청크 데이터를 전송 인코딩을 사용해서 전송한다.

수신자가 본문을 재구축하는 절차는 이와 순서가 반대다.

![image.png](attachment:4f99272c-99f4-4c4a-b3c4-7aff7673ba9c:image.png)

## 5. 전송 인코딩 규칙

전송 인코딩이 메시지 본문에 적용될 때, 몇 가지 규칙이 반드시 적용되어야 한다.

- 전송 인코딩의 집합은 반드시 ‘chunked’를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

이 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 해준다.

# 7. 시간에 따라 바뀌는 인스턴스

웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.

https://www.naver.com에 방문하면 매번 조금씩 다른 결과를 얻을 수 있다.

네이버 홈페이지를 하나의 객체라고 생각하고, 그것의 각각 다른 버전을 객체의 각각 다른 인스턴스라고 생각해보자.

그림에서 클라이언트는 같은 리소스(URL)를 여러 번 요청했지만, 시간이 흐름에 따라 리소스의 다른 인스턴스를 받게 된다. 

![image.png](attachment:fceeb096-8a1e-4648-b13b-6d3bd4506e91:image.png)

HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것은 인스턴스 조작(instance manipluation)이라 불리며 객체의 인스턴스에 작용한다.

대표적인 두 가지가 범위 요청과 델타 인코딩이다.

둘 다, 클라이언트가 자신이 갖고 있는 리소스의 사본이 서버가 갖고 있는 것과 정확히 같은지 판단하고, 상황에 따라서는 새 인스턴스를 요청할 수 있는 능력을 가질 것을 요구한다. 

# 8. 검사기와 신선도

조건부 요청이라고 불리는 특별한 요청은, 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것이다. 

## 1. 신선도

서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다. 

Expires나 Cache-Control 헤더를 통해 이러한 정보를 제공할 수 있다. 

Expires 헤더는 문서가 만료되어 더 이상 신선하다고 간주할 수 없게 되는 정확한 날짜를 명시한다. 

![image.png](attachment:d7d3fd23-6d8c-4778-bcc8-232fb6c9a9bb:image.png)

Cache-Control 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다. 수명은 시계 동기화에 의존하지 않으므로 더 정확한 결과를 말해줄 것이다. 

![image.png](attachment:16b8ce1b-935a-4348-8887-9a9998b6405f:image.png)

## 2. 조건부 요청과 검사기

캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있다.

캐시는 원 서버에서 현 시점의 사본을 가져올 수 있지만, 대개 서버에 있는 문서는 여전히 캐시에 들어있는 신선하지 못한 사본과 같을 것이다. 

만약 서버의 문서가 캐시가 갖고 있는 것과 같음에도 불구하고 항상 그 문서를 가져온다면 캐시는 네트워크의 대역폭을 낭비하고, 캐시와 서버에 불필요한 부하를 주고, 모든 것을 느려지게 만들게 된다.

이를 고치기 위해, HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공한다. 

조건부 요청은 특정 요청이 참일 때에만 수행된다.

예를 들어 캐시는 다음 조건부 GET 메시지를 서버에 보내어, /announce.html 파일이 2002년 6월 29일(캐시된 문서가 작성자에 의해 마지막으로 변경된 날짜) 이후에 변경된 경우에만 한해서 파일을 보내달라고 할 수 있다. 

![image.png](attachment:3ba4f0d6-2aa3-4fbc-a9b7-5551c2e2a585:image.png)

조건부 요청은 ‘If-’로 시작하는 조건부 헤더에 의해 구현된다.

조건부 헤더는 조건이 참일 때만 수행되도록 한다. 

만약 조건이 참이 아니면 서버는 HTTP 에러 코드를 돌려보낸다. 

![image.png](attachment:d531e434-96fe-4a23-8708-e80d5575fcc1:image.png)

# 9. 범위 요청

HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.

범위 요청을 이용하면, HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.

![image.png](attachment:3727bf6f-f167-4285-b5ce-ad75758d6008:image.png)

이 예에서 클라이언트는 처음 4,000바이트 이후의 부분을 요청하고 있다. 

Range 헤더는 여러 범위로 요청을 하기 위해 사용될 수도 있다.

예를 들어, 어떤 문서에 대한 다운로드 시간을 줄이기 위해 동시에 여러 서버에 접속해서 같은 문서에 대해 새로 다른 범위를 요청하는 클라이언트를 상상해보자. 

응답은 멀티파트 본문과 Content-Type: multipart/byteranges 헤더와 함께 하나의 엔터티로 돌아온다. 

# 10. 델타 인코딩

새 페이지 전체를 서버가 클라이언트에 보내는 대신, 페이지에 대한 클라이언트의 사본에 대해 변경된 부분만을 서버가 보낸다면 클라이언트는 더 빨리 페이지를 얻을 수 있을 것이다.

델타 인코딩는 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다. 

어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 때문에, 델타 인코딩은 일종의 인스턴스 조작이다.

![image.png](attachment:ba860f8f-f945-4a55-825f-acfcd2901f95:image.png)

클라이언트는 자신이 갖고 있는 버전에 대한 유일일한 식별자(지난번 응답의 ETag 헤더에 들어있던 것)를  If-None-Match 헤더에 담는다.

이것은 서버에게 “녜가 갖고 있는 최신 버전의 페이지가 이것과 같은 ETag를 갖고 있지 않다면, 최신 버전의 페이지를 보내달라”고 말하는 클라이언트의 방식이다.
그러면 If-None-Match 헤더에 의해 서버는 클라이언트에게 그 페이지의 최신 버전 전체를 보내게 될 것이다.
