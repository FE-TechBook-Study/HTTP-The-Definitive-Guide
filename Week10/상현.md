# 상현
## 15.1 메시지는 컨테이터, 엔터티는 화물

![스크린샷 2025-08-19 오전 10.05.08.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fcf7dda9f-135a-430e-af86-2cb7da6324cf%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-19_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.05.08.png/size/w=1920?exp=1755738176&sig=FvH3wCaquOlgKwM2D946KOlFjRthSI5CcQeB95mXwlI&id=254438a5-b001-8033-b0ec-dbd9056ecf25&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

주요 엔터티 헤더로는:

- Content-Type: 엔터티에 의해 전달된 객체의 종류
- Content-Length: 전달되는 메시지의 길이나 크기
- Content-Language: 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding: 객체 데이터에 대해 행해진 변형(압축등)
- Content-Location: 요청 시점을 기준으로 객체의 또 다른 위치
- Content-Range: 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
- Content-MD5: 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified: 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires: 엔터티가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow: 이 리소스에 대해 어떤 요청 메서드가 허용되는지
- ETag: 이 인스턴스에 대한 고유한 검사기
- Cache-Control: 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자

### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만 가지고 있음
이 가공되지 않은 데이터는 엔터티 헤더의 정보로 분석

예를 들어, Content-Type을 통하여 데이터를 어떻게 해석해야 하는지, Content-Encoding을 통하여 데이터가 압축되었을 때 어떻게 풀어야하는지 표시

또한, 본문은 항상 헤더가 끝나고 빈 CRLF 줄 바로 다음부터 시작

### 15.2 Content-Length: 엔터티의 길이

엔터티 본문의 크기를 바이트 단위로 표현
메시지를 청크 인코딩으로 전송하지 않는 이상 필수적으로 포함

### 15.2.1 잘림 검출

HTTP 커넥션 종료로 메시지가 끝났음을 인지했는데 Content-Length가 없다면 케넥션이 정상적으로 닫힌 것인지 구분 불가
따라서, 잘림 검출을 하기 위해 Content-Length가 필요하며 캐싱 프락시는 해당 값이 없으면 보통 캐시하지 않음

### 15.2.2 잘못된 Content-Length

없는 것 보다 잘못된 값을 가지고 있는 경우 더 큰 피해 유발 가능
그래서 몇몇 클라이언트, 서버, 프락시들은 잘못된 값들로 인한 버그들을 탐지하고 교정을 시도하며 HTTP 1.1에서는 사용자에게 잘못된 길이를 받았다고 표시

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

지속 커넥션을 위해 필수
지속 커넥션에서 메세지의 끝을 인식할 방법이 없기에 Content-Length값을 통해 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 파악

15.6에서 나올 예정이지만 청크 인코딩을 통해서 Content-Length가 없는 지속 커넥션 가능

### 15.2.4 콘텐츠 인코딩

콘텐츠가 압축되어 있거나 인코딩되 있다면 Content-Length는 변경된 콘텐츠의 길이로 정의

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙들 순서:

1. 본문을 갖는 것이 허용되지 않는 HTTP 메시지에서는 Content-Length 헤더가 무시
    1. HEAD요청은 응답의 헤더들만 받기로 되어 있는데 Content-Length값이 포함이 되어 있는 경우 값 무시 필요
2. Tansfer-Encoding 헤더를 포함하고 있다면 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0 바이트 청크’라 불리는 특별한 페턴으로 종료 필요
3. Transfer-Econding 헤더가 있으면서 값이 “identity”가 아니라면 Content-Length값 무시
4. multipart/byteranges’ 타입에서 Content-Length가 없으면, 각 파트가 스스로 크기를 정의한다. 단, 수신자가 이 형식을 해석 가능할 때
5. 위의 규칙이 적용되지 않으면, 엔터티는 서버가 커넥션을 닫을 때 종료
6. HTTP 1.0 호환을 위해서 HTTP/1.1(*persistent connection이 기본이기 때문에*)에서 본문이 있는 요청은 반드시 유효한 Content-Length를 가져야 하며, 없으면 서버는 오류를 반환

## 15.3 엔터티 요약

신뢰할 만한 전송 프로토콜 위에서 HTTP 통신이 되더라도 중간에 메시지가 변형이 될 수 있음
메시지 무결성을 확인하기 위해 엔터티 본문을 MD5 알고리즘을 적용한 값을 Content-MD5 헤더에 정의하여 보냄. 또한 해당 값은 프록시/캐시를 거쳐도 변형되지 않고 그래도 전달
수신자는 응답을 받으면 무결성 체크를 위해서 디코딩된 엔티티 본문에 MD5 알고리즘을 적용하고 Content-MD5값과 비교

하지만 자주 전송되지 않고, 다른 알고리즘이나 헤더값(Want-Digest)을 활용하여 체크 

## 15.4 미디어 타입과 차셋(Charset)

Content-Typ 필드는 엔터티 본문의 MIME 타입을 기재
해당 값은 인터넷 할당 번호 관리기관(Internet Assigned Numbers Authority, IANA)에서 등록된 MIME 타입을 이용하며 빗금(/)을 기준으로 앞은 주 미디어 타입, 뒤는 서브타입으로 구성

콘텐츠가 인코딩을 거친 경우에도 Content-Type은 인코딩 전의 유형을 명시

### 15.4.1 텍스트 매체를 위한 문자 인코딩

내용 유형을 더 자세히 지정하기 위해 선택적인 매개변수도 지원
`Content-Type: text/html; charset-iso-8859-4`

### 15.4.2 멀티파트 미디어 타입

하나의 복합 메시지로 취급
본문을 지원하는 경우는 폼을 채워서 제출하거나 문서의 일부분을 실어 나르는 범위 응답할 때만

### 15.4.3 멀티파트 폼 제출

폼을 작성하고 제출하게 된다면 `Content-Type: multipart/form-data boundary=[asdasd]`와 깉이 요청
boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 사용

### 15.4.4 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답은 `Content-Type: multipart/byteranges`로 수신
범위 요청은 추후 자세히

## 15.5 콘텐츠 인코딩

인코딩은 발송하는 쪽에서 콘텐츠에 적용하며 인코딩이 완료되면 수신자에게 전달

### 15.5.1 콘텐츠 인코딩 과정

1. 원본 Content-Type과 Content-Length헤더를 동반한 메시지를 생성
2. 콘텐츠 인코딩이 되며 인코됭된 메시지는 Content-Type은 같지만 Content-Length은 다르며, Content-Encoding헤더를 추가하여 수신자가 디코딩할 수 있게 도와줌
3. 수신 측은 인코딩된 메시지를 받고 디코딩하여 원본 획득

### 15.5.2 콘텐츠 인코딩 유형

인코딩 가능한 유형은 IANA에 기재가 되며 확장 인코딩으로 인코딩 추가도 가능
흔히 쓰이는 인코딩 토큰은 아래:

- gzip, compress, deflate, identity

### 15.5.3 Accept-Encoding 헤더

서버는 클라이언트가 디코딩할 수 없는 형태로 보내서는 안됨
따라서 요청 시, Accept-Encoding헤더를 통해서 클라이언트가 디코딩 가능한 목록을 서버에 전달
만약 Accept-Encoding 헤더가 없을 시, 어떤 인코딩이든 가능하다고 간주

표현을 할 때는 아래와 같이 기재:

- `Accept-Encoding: OR Accept-Encoding: *`
    - 모든 것을 허용
- `Accept-Encoding: gzip: 1.0, Identity;q=1.0, identity;q=0.5, *;=q=0`
    - q값을 통해서 선호도 기재(1에서 0의 범위, 1에 가까울 수록 선호도 증가)

## 15.6 전송 인코딩과 청크 인코딩

### 15.6.1 안전한 전송

대부분 안전하지만 문제를 일으키는 이유:

- 알 수 없는 크기
    - 메시지는 콘텐츠의 크기를 기재해야하는 데, 몇몇 서버는 인코딩이 끝나지 않았는데도 전송 시작
    - 그렇기에 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터 전달
- 보안
    - 보안이 적용되기전에 전송 인코딩이 적용되어 뒤섞이는 경우가 있지만 흔하지 않음

### 15.6.2 Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하는 헤더 두 개:

- Transfer-Encoding: 어떤 인코딩이 적용되었는지 수신자에게 전달
- TE
    - 어떤 확장된 전송 인코딩을 사용할 수 있는지 요청 헤더에 추가
    - Accept-Encoding과 같이 Q값(선호도)를 가질 수 있으나, 0.0값을 못 가짐

```tsx
GET XXXXX HTTP/1.1
...
TE: trailers, chuncked

//
HTTP/1.1 200 OK
Transfer-Encoding: chuncked
```

### 15.6.3 청크 인코딩

전송 인코딩의 한 부분이며, 메시지를 각 청크로 분리해서 본문 전체를 보낼 때까지 순차적으로 전달

- 청크와 지속 커넥션
    - 청크는 동적으로 생성이 되면서 그 크기를 헤더에 포함해서 전달
    - 본문을 전부 다 보낼 때까지 반복하다가 크기가 0인 청크를 응답하여 본문이 끝났음을 알림
- 청크 인코딩된 메시지의 트레일러
    - 다음 조건을 만족하면 청크 메시지에 트레일러 추가 가능
        - 클라이언트가 TE 헤더에 트레일러 수용가능하다고 할 경우
        - 트레일러가 서버에서 추가되었으며 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터인 경우

### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용 가능
예를 들어, 먼저 메시지 콘텐츠를 인코딩하고 청크 데이터로 나뉘어 전송 인코딩

수신자(클라이언트) 입장에서는 발신자의 액션을 역으로 해석
청크 데이터를 모으고 Content-Encoding의 값으로 디코딩하여 원문 복원

### 15.6.5 전송 인코딩 규칙

전송 인코딩 사용 시 몇가지 규칙이 반드시 적용 필요:

- 전송 인코딩 집함은 반드시 ‘chunked’ 포함 필요. 유일한 예외는 커넥션의 종료가 끝나는 경우
- 청크 전송 인코딩이 사용되었다면 메시지 본문에 적용된 마지막 전송 인코딩 존재 필요
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용

전송 인코딩은 HTTP 1.1에서 새로 소개된 기능이기에 지원 여부 확인 필요하며 서버가 이해할 수 없는 전송 인코딩 메시지를 받았다면 501 Uimplemented 상태로 응답

그러나 HTTP 1.1 이라면 최소한 청크 인코딩만은 반드시 지원 필요

## 15.7 시간에 따라 바뀌는 인스턴스

시간에 따라 응답 객체가 변경
HTTP는 특정한 종류의 요청이나 응답을 다루는 방법을 인스턴스 조작(instance manipulation)

인스턴스 조작에는 “범위 요청”과 “델타 인코딩”이 있는데 이 들은 클라이언트가 자신이 갖고 있는 리소스의 사본이 서버가 갖고 있는 것과 정확히 같은지 판단하고 상황에 따라서 새 인스턴스를 요청할 수 있는 능력 보유

## 15.8 검사기와 신선도

### 15.8.1 신선도

서버는 응답 헤더에 Expires나 Cache-Control을 붙여서 문서에 대한 신선도를 제공 가능
네트워크 시간 프로토콜과 같은 시계 동기화 프로토콜을 하면 좋으나 많이 하지 않으므로 상대시간으로 만료하는 Cache-Control이 조금 더 효율적

### 15.8.2 조건부 요청과 검사기

조건부 요청과 관련되어 있는 “If-”로 시작하는 헤더로 조건에 부합하면 서버은 변경된 값을 보내고 아니라면 HTTP에러 코드를 반환

7장의 캐시 처리를 더 자세히 보는 것을 추천

## 15.9 범위 요청

범위 요청을 통해 중단된 시점에서 다시 재개를 하거나 문서의 특정 범위만 요청 가능

서버는 아래와 같이 응답에 Accept-Ranges라는 헤더를 통해서 범위 요청이 가능하다는 것을 표시
이 헤더 값은 측정의 단위로 주로 바이트

```tsx
HTTP/1.1 200 OK
Date: Fri, 05 Nov 1999. 22:13:13 GMT
Accept-Ranges: bytes
```

클라이언트는 서버에게 Range라는 헤더를 통해서 어디서부터 요청할 것인지 표시
아래는 4,000 bytes까지는 받았다는 것을 표시

```tsx
GET xxxx.html HTTP/1.1
HOST: XXXXXX
Range: bytes=4000-
```

![스크린샷 2025-08-21 오전 9.25.46.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F6f4f09d1-2f54-44d3-9ed9-2316ec29346a%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-21_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.25.46.png/size/w=1920?exp=1755738196&sig=fKwu9QUS_ft26SNFCKqSVfDQVoP1z0BbQEsXISk3SPI&id=256438a5-b001-8021-9bf6-d9966f8ec69e&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

## 15.10 델타 인코딩

서버에서 변경된 페이지를 전체를 보내지 않고 변경된 일부분만 보내 전송량을 최적화하는 HTTP 프로토콜의 확장

![스크린샷 2025-08-21 오전 9.33.33.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F079b88ad-eeff-488b-90fb-6424a0e1b9de%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-21_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.33.33.png/size/w=1920?exp=1755738245&sig=2XTlDBtX_X_jqEaNmE5JFUPs-mQrWZwztB0aaqiG71s&id=256438a5-b001-80e5-b616-d0ba86b23af9&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

- 클라이언트는 서버에서 If-None-Match에 E-tag값을 보내서 변경점을 확인하면서 A-IM 헤더를 통해서 자신이 델타를 받을 수 있음을 표시
    - A-IM(Accept-Instance-Manipulation): 예전 버전과 델타를 이용해 최신 버전의 문서를 생성하는 알고리즘 목록을 서버에서 전달
- 서버는 다음 정보를 클라이언트에게 응답
    - HTTP status로 226 IM Used
    - IM(Instance-Manipulation) 헤더를 통해 인스턴스 조작 했음을 표시하며 사용한 알고리즘
    - 새 E-tag
    - Delta-base에는 어떤 델타를 이용해 수행을 했는지 표시

델타 인코딩에 사용되는 헤더들은:

- ETag, If-None-Match, A-IM, IM, Detla-Base

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

IANA에 등록된 인스턴스 조작의 몇가지:

- vcdiff, diffe, gdiff, gzip, deflate, range, identit

델타 인코딩은 변경된 부분만 보낼 수 있다는 장점이 있지만, 서버 부하가 증가한다는 단점이 존재

- 서버는 자신이 제공하는 페이지가 변경된 순간의 모든 사본 보유 필요. 즉 서버 디스크 용량 차지하여 전송량 감소로 얻은 이득이 금방 무의미하게 될 가능성
