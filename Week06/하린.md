# 7장. 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.

캐시는 다음과 같은 혜택을 준다.

- 불필요한 데이터 전송을 줄여 네트워크 비용 감소
- 네트워크 병목을 줄여 대역폭을 늘리지 않고도 페이지 로드 속도 감소
- 원 서버에 대한 요청을 줄여 서버 부하 감소 및 응답 속도 개선
- 거리로 인한 지연 감소

## 7.1 불필요한 데이터 전송

복수의 클라이언트가 원 서버 페이지에 접근할 때 동일한 바이트들이 반복해서 이동한다. 이 불필요한 데이터 전송은 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며 웹 서버에 부하를 준다.

캐시를 이용하면, 첫 번째 응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복 트래픽을 주고받는 낭비가 줄어든다.

## 7.2 대역폭 병목

캐시는 또한 네트워크 병목을 줄여준다.

- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
  같은 건물/사무실 내의 LAN(Local Area Network)에 있는 컴퓨터들끼리 통신할 때는 매우 빠른 속도로 데이터를 주고받을 수 있지만 인터넷을 통해 멀리 있는 서버와 통신할 때는 상대적으로 느린 속도로 통신한다.

- 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 크기가 큰 문서의 일수록 캐싱은 성능을 대폭 개선할 수 있을 것

- 대역폭은 문서의 크기가 클수록 지연을 일으키며, 속도는 네트워크 종류의 차이에 따라 많이 달라진다.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

캐싱은 갑작스런 요청 쇄도에 대처하기 위해 중요하다.

- 갑작스러운 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 일으킨다.

## 7.4 거리로 인한 지연

대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있다.

클라이언트와 서버 사이에 라우터가 그다지 많지 않더라도, 물리적으로 거리가 멀수록 지연시간이 증가할 수 밖에 없다.

물리적으로 가까운 곳에 캐시를 설치해서 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄여 거리로 인한 지연 문제를 해결할 수 있다.

## 7.5 적중과 부적중

캐시는 모든 문서의 사본을 저장하지는 않는다.

- 캐시 적중 : 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리된다.
- 캐시 부적중 : 대응하는 사본이 없다면 그냥 원 서버로 전달

### 7.5.1 재검사(Revalidation)

원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.  
이러한 신선도 검사를 HTTP 재검사라 부른다.

캐시는 클라이언트가 요청한 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다.

효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 빠르게 검사할 수 있는 특별한 요청을 정의했다.

- 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다.
- 콘텐츠가 변경되지 않았다면, 서버는 304 Not Modified 응답을 보낸다.
- 사본이 여전히 유효함을 알게 된 캐시는 사본이 신선하다고 표시한 뒤 그 사본을 클라이언트에 제공한다.

이를 재검사 적중 혹은 느린 적중이라고 부른다. 이것은 원 서버와 검사를 할 필요가 있기 때문에 순수 캐시 적중보다 느리고, 서버로 부터 객체 데이터를 받아올 필요가 없기 때문에 캐시 부적중 보다는 빠르다.

#### If-Modified-Since 헤더

서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.

[해당 요청이 서버에 도착했을 때 일어날 수 있는 상황]

1. 서버 콘텐츠가 변경되지 않은 경우 - 재검사 적중
   서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보낸다.
2. 서버 콘텐츠가 변경된 경우 - 재검사 부적중
   서버는 콘텐츠 전체와 함께 평범함 HTTP 200 OK 응답을 보낸다.
3. 객체가 삭제된 경우
   서버는 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제한다.

### 7.5.2 적중률

캐시가 요청을 처리하는 비율을 캐시 적중률(문서 적중률)이라고 부른다.

- 0~1까지의 값으로 되어있지만, 퍼센트로 표현되기도 한다.
  - 0% : 모든 요청이 캐시 부적중
  - 100% : 모든 요청이 캐시 적중
- 적중률에 영향을 미치는 요인들
  - 캐시가 얼마나 큰지
  - 캐시 사용자들의 관심사가 얼마나 비슷한지
  - 캐시된 데이터가 얼마나 자주 변경되거나 개인화되는지
  - 캐시가 어떻게 설정되어 있는지

오늘날 적중률 40%면 웹 캐시로 괜찮은 편이다.

문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지를 보여준다. 이것을 개선하면 전체 대기시간이 줄어든다.

### 7.5.3 바이트 적중률

문서들마다 크기가 다르기 때문에 문서 적중률이 모든 것을 말해주지는 않는다. 몇몇 큰 객체는 덜 접근되지만 크기 때문에 전체 트래픽 비중에 크게 기여할 수도 있다.

바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 이 측정값은 트래픽이 절감된 정도를 포착해낸다.

- 100% : 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미

바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여준다. 이것을 개선하면 대역폭 절약을 최적화할 수 있다.

### 7.5.4 적중과 부적중의 구별

HTTP는 클라이언트에게 캐시가 적중이었는지 부적중이었는지 말해주지 않는다.

클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것

- 응답의 Date 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 응답이 캐시된 것임을 알 수 있다.

또 다른 방법은 Age 헤더를 이용하는 것이다.

- Age 헤더 : 응답이 원본 서버에서 생성된 후 얼마나 오래되었는지를 초 단위로 나타내는 HTTP 헤더

## 7.6 캐시 토폴로지

캐시는 한 명의 사용자에게만 할당될 수도 있고 수천 명의 사용자들 간에 공유될 수도 있다.

- 개인 전용 캐시 : 한 명에게만 할당된 캐시로 한 명의 사용자가 자주 찾는 페이지를 담는다.
- 공용 캐시 : 사용자 집단에게 자주 쓰이는 페이지를 담는다.

### 7.6.1 개인 전용 캐시

웹 브라우저는 개인 전용 캐시를 내장하고 있다. 대부분의 브라우저는 자주 쓰이는 문서를 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

### 7.6.2 공용 프락시 캐시

공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 공유된 프락시 서버이다.  
프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 사용자의 입장에서 서버에 접근한다. 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

개인 전용 캐시는 같은 문서를 네트워크를 거쳐 여러 번 가져오는 반면,  
공용 캐시는 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다.

### 7.6.3 프락시 캐시 계층들

작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 걸러 남겨진 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.  
이 아이디어는 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단 원 서버로 올라갈수록 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하자는 것이다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

캐시망의 프락시 캐시는 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내린다.

캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 다음과 같은 일들을 한다.

- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거하여 특정 부모 캐시를 동적으로 선택
- 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 탐색
- 다른 캐시들이 그 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(트래픽이 다른 네트워크로 건너가는것)은 허용하지 않는다.

이러한 캐시 사이의 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해준다.

## 7.7 캐시 처리 단계

오늘날 상용 프락시 캐시는 고성능이면서도 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어졌다. 기본적인 동작은 대개 단순하며 일곱 단계로 이루어져 있다.

### 7.7.1 단계 1: 요청 받기

캐시는 네트워크로부터 도착한 요청 메시지를 읽어들인다. 고성능 캐시는 여러 개의 트랜잭션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.

### 7.7.2 단계 2: 파싱

다음으로 캐시는 요청 메시지를 파싱하여 URL과 헤더를 추출하고 조작하기 쉬운 자료 구조에 담는다.

### 7.7.3 단계3: 검색

캐시는 알아낸 URL로 로컬 복사본이 있는지 검사하고, 없다면 받아온 후 로컬에 저장한다.  
만약 문서를 로컬에서 가져올 수 없다면, 상황에 따라 원 서버나 부모 프락시에서 가져오거나 실패를 반환한다.

캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하므로 올바른 서버 헤더가 반환될 수 있다. 또한 객체가 캐시에 머무른 기간에 대한 기록이나 사용된 빈도등에 대한 메타데이터를 포함한다.

### 7.7.4 단계 4: 신선도 검사

캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.

HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다. 이 기간 동안 문서는 '신선'한 것으로 간주되고 서버와의 접촉없이 바로 제공할 수 있다.

캐시된 사본을 너무 오래 갖고 있었다면 그 객체는 '신선하지 않은' 것으로 간주되며, 캐시는 제고 전에 문서에 어떤 변경이 있었는지를 서버와 재검사 해야 한다.

복잡한 신선도 검사 규칙은 이 장 나머지 부분에서 설명..

### 7.7.5 단계 5: 응답 생성

캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.

캐시된 응답은 원 서버에서 온 것처럼 보이게 서버 응답 헤더를 토대로 응답 헤더를 생성한다.  
캐시는 클라이언트에 맞게 헤더를 조정해야 한다. (ex. 요청 , 원 서버 응답 간의 HTTP 버전 호환)
또한 캐시 신선도 정보(Cache-Control, Age, Expires 헤더), Via 헤더를 포함시킨다.  
Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것이므로 캐시가 조정해서는 안된다.

### 7.7.6 단계 6: 전송

캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.

### 7.7.7 단계 7: 로깅

선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그를 남긴다.

각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다.

## 7.8 사본을 신선하게 유지하기

캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아니다. 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.

- 문서 만료(서버 재검사): HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지하게 해주는 단순한 메커니즘

### 7.8.1 문서 만료

Cache-Control과 Expires라는 특별한 헤더들을 이용해 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
문서가 만료되기 전이면, 캐시는 서버와의 접촉 없이 사본을 제공할 수 있다. 그러나 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사 후 신선한 사본을 얻어와야 한다. (유효기간도 갱신)

### 7.8.2 유효기간과 나이

서버는 HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해서 유효기간을 명시한다.

- Cache-Control:max-age
  - max-age 값은 문서의 최대 나이를 정의한다.
  - 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓갑(초 단위)이다.
  - ex) `Cache-Control: max-age=484200`
- Expires
  - 절대 유효기간
  - 만약 유효기간이 경과했다면, 그 문서는 더 이상 신선하지 않다.
  - ex) `Expires: Fri, 05 Jul 2002, 05:00:00 GMT`

### 7.8.3 서버 재검사

캐시 문서가 만료되었다는 것은 실제로 원 서버의 문서와 다르다는 것을 의미하지는 않으며, 검사할 시간이 되었음을 뜻한다.

- 서버 재검사 : 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음을 의미
  - 재검사 결과 콘텐츠가 변경되었다면, 캐시는 문서의 새로운 사본을 가져와 저장한 뒤 클라이언트에게 보내준다.
  - 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.

캐시는 문서의 신선도를 매 요청마다 검증할 필요없이 문서가 만료되었을 때 한 번만 서버와 재검사하면 된다. 이는 서버 트래픽을 절약하고 사용자 응답 시간을 개선한다.

### 7.8.4 조건부 메서드와의 재검사

HTTP 조건부 메서드는 재검사를 효율적으로 만들어준다.

#### 조건부 GET의 동작

- 캐시가 '조건부 GET'이라는 요청을 보내면 웹 서버는 객체가 캐시된 이후 변경되었을 때만 객체 본문을 보내준다.
- GET 요청 메시지에 조건부 헤더를 추가하여 요청
- 웹 서버는 조건이 참인 경우에만 객체를 반환

### 7.8.5 `If-Modified-Since: <date>`: 날짜 재검사

- 가장 흔히 쓰이는 캐시 재검사 헤더
- 주어진 날짜 이후에 문서가 수정되었다면 요청 메서드를 처리
- 문서가 주어진 날짜 이후로 변경되었다면, 조건은 참이고 새로운 문서가 새로운 만료 날짜와 그 외 헤더들과 함께 캐시에 반환
- 문서가 주어진 날짜 이후로 변경되지 않았다면, 조건은 거짓이고 서버는 304 Not Modified 응답. 효율을 위해 본문은 x
- 응답 헤더의 Last-Modified 헤더와 함께 동작한다.

### 7.8.6 `If-None-Match: <tags>`: 엔터티 태그 재검사

엔터티 태그(Entity Tag)의 필요성

- 문서가 일정 시간 간격으로 다시 쓰여지지만 내용은 같을 수 있음
- 문서가 변경되었지만 전 세계의 캐시들이 데이터를 다시 읽어들이기엔 사소한 경우
- 어떤 서버들은 그들이 갖고 있는 파일의 최종 변경 시각을 판별하기 어려운 경우

현재 캐시가 갖고있는 엔터티 태그가 원 서버의 최신 엔터티 태그와 일치하지 않는 경우에 재검사 후 새 객체를 요청한다.

### 7.8.7 약한 검사기와 강한 검사기

캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티 태그를 사용한다.

- 약한 검사기
  - 콘텐츠가 조금 변경되면 그정도면 같은 것이라고 취급
  - 서버는 `W/` 접두사로 약한 검사기를 구분 `ETag: W/"v2.6"`
- 강한 검사기
  - 콘텐츠가 변경될 때마다 반드시 변경되어야함

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modfied 일시를 사용하는가

- HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환하면, 반드시 엔터티 태그 검사기를 사용
- 서버가 Last-Modified 값만을 반환했다면, 클라이언트는 if-Modified-Since 검사를 사용

## 7.9 캐시 제어

HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있는지를 서버가 설정할 수 있는 여러 가지 방법을 제공한다.

- `Cache-Control: no-store` - 캐시가 검증된 사본을 저장하는 것을 금지
- `Cache-Control: no-cache` - 캐시가 서버와 재검사하지 않고는 캐시된 사본을 제공할 수 없음
- `Cache-Control: must-revalidate` - 캐시가 만료 정보를 엄격하게 따르도록 함
- `Cache-Control: max-age` - 문서가 서버로부터 온 이후 흐른 시간이 초과하면 캐시할 수 없음
- `Expires` - 절대 만료 날짜 지정

### 7.9.1 no-cache와 no-store 응답 헤더

no-store, no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

```
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache // HTTP/1.0+와의 하위호완성을 위해 HTTP/1.1에 포함
```

- no-store: 캐시가 응답의 사본을 저장하는 것을 금지. 클라이언트에게 no-store 응답 전달 후 객체를 삭제
- no-cache: 로컬 캐시 저장소에 저장은 가능하지만, 서버와 재검사 없이는 클라이언트로 제공 불가

### 7.9.2 Max-Age 응답 헤더

`Cache-Control: max-age` 헤더는 신선함과 나이에 관련된 정보를 제공한다.

```
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

- max-age: 문서가 서버로 부터 온 이후로 흐른 시간(초 단위)
- s-maxage: max-age와 동일하지만, 공용 캐시에만 적용

### 7.9.3 Expires 응답 헤더

더 이상 사용하지 않기를 권하는 Expires 헤더는 초 단위가 아닌 실제 만료 날짜를 명시한다.

```
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```

### 7.9.4 Must-Revalidate 응답 헤더

캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초 재검사 없이는 제공할 수 없음을 의미한다.

```
Cache-Control: must-revalidate
```

- 캐시가 만료된 객체에 대해 원 서버와 재검사를 강제
- 재검사 실패 시 캐시는 504 Gateway Timeout 오류 반환

### 휴리스틱 만료

만약 응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적(휴리스틱) 방법으로 최대 나이를 계산할 수 있다.

#### LM인자 알고리즘

문서가 최근에 변경되었다면 곧 또 변경될 가능성이 높고, 오래 전에 변경된 문서는 안정적이라고 가정하는 알고리즘

- LM 인자 계산 공식:

  - 캐시가 서버와 대화한 시간과 문서가 마지막으로 변경된 시각을 뻰 값(문서가 마지막으로 수정된 이후 흐른 시간)에 LM 인자를 곱한 값 만큼을 신선도 유지기간으로 추정한다.
    ```
    신선도 수명 = (Date - Last-Modified) × LM 인자
    ```

- 휴리스틱 만료의 안전장치
  - 상한값 설정: 대부분의 캐시 구현체는 휴리스틱 만료에 상한값을 설정
    예: 최대 24시간, 1주일 등

### 7.9.6 클라이언트 신선도 제약

웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시키는 리프레시나 리로드 버튼을 갖고 있다. 이 버튼은 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져오게 한다.

클라이언트는 Cache-Control 헤더를 사용해 만료 제약을 엄격하게 하거나 느슨하게 할 수 있다.

클라이언트가 사용할 수 있는 Cache-Control 요청 지시어들:

- `Cache-Control: max-stale` - 캐시는 신선도를 검사하지 않고 제공 가능
- `Cache-Control: max-stale = <s>` - 문서가 주어진 초만큼 신선하지 않아도 제공 가능
- `Cache-Control: min-fresh = <s>` - 클라이언트는 적어도 s초 후까지 신선한 문서만들 받아들임
- `Cache-Control: max-age = <s>` - 캐시가 s초보다 오래된 문서는 반환할 수 없음
- `Cache-Control: no-cache` - 클라이언트는 캐시된 리소스의 사본을 받아들이지 않음
- `Cache-Control: no-store` - 캐시는 요청이나 응답을 저장해서는 안 됨
- `Cache-Control: only-if-cached` - 클라이언트는 캐시에 들어있는 사본만 원함

## 7.10 캐시 제어 설정

웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공한다.

### 7.10.1 아파치로 HTTP 헤더 제어하기

아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공한다.

#### mod_headers

개별 헤더들을 설정할 수 있는 지시어를 이용해 HTTP 헤더를 추가할 수 있다.

어떤 디렉토리의 모든 HTML파일을 캐시되지 않도록 설정하는 예

```
<Files *.html>
Header set Cache-Control no-cache
</Files>
```

#### mod_expires

프로그램 로직이나 설정파일을 통해 Expires 헤더를 자동으로 생성하는 프로그램

```
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
```

#### mod_cern_meta

HTTP 헤더들의 파일을 특정 객체와 연결시켜주는 메타파일들을 생성해 주어, 각 메타파일에 원하는 헤더들을 추가할 수 있다.

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

웹 서버 설정 파일과의 상호작용 없이도 HTML 문서의 HTTP 헤더 정보를 HTTP-EQUIV 태그를 통해 제공할 수 있다.

```html
<html>
  <head>
    <title>My Document</title>
    <meta http-equiv="Cache-Control" content="no-cache" />
  </head>
  ...
</html>
```

- 서버의 부하 가중, 정적인 설정값, 다른 타입의 파일 미지원 등의 이유로 지원하는 웹 서버나 프락시가 거의 없다.
- 몇몇 브라우저가 태그를 파싱하고 HTTP 헤더처럼 다루는 것은 프락시 캐시와는 다른 규칙이 적용되어 캐시 만료에 대한 혼란을 초래할 수 있다.

## 7.11 자세한 알고리즘

HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 상세한 알고리즘을 제공한다.

### 7.11.1 나이와 신선도 수명

캐시가 문서의 사본이 충분히 신선한지 판단하기 위해, 두 가지 값을 계산한다.

1. 문서의 현재 나이 - 서버가 문서를 보낸 이후 그 문서가 얼마나 오래되었는지
2. 신선도 수명 - 문서가 신선하다고 볼 수 있는 수명 . 얼마나 신선할 수 있는지

캐시는 문서의 나이가 신선도 수명보다 작으면 해당 사본을 제공할 수 있다.

### 7.11.2 나이 계산

응답의 나이는 응답이 서버에서 생성되었을 때부터 지금까지의 총 시간이다. 캐시는 응답이 캐시에 도착했을 때 Date나 Age 헤더를 분석해서 얼마나 오래된 것인지 알 수 있다.  
또한 문서가 로컬 캐시에 얼마나 오래 머물렀는지 알 수 있다. 이 둘을 합하면 응답의 전체 나이가 된다.

```
나이 = 문서가_캐시에_도착했을_때의_나이 + 사본이_캐시에_머무른_시간
```

#### 겉보기 나이

모든 컴퓨터가 정확히 똑같은 시계를 갖고 있다면, 캐시된 문서의 나이는 단순히 `현재 시간 - 서버가 문서를 보낸 시간`인 '겉보기 나이'가 될 것이다.  
그러나, 클라이언트와 서버의 시계는 서로 차이가 있을 수 있다. 이 같은 두 컴퓨터의 시계 설정 차이로 인한 문제를 클록 스큐라고 부른다. 클록 스큐 때문에 겉보기 나이가 음수가 되는 경우에는 그것을 0으로 만들어야 한다.

#### 점층적 나이 계산

HTTP/1.1은 동기화된 시계가 존재하지 않는다는 문제에 대한 우회책으로, 문서가 프락시나 캐시를 문통과할 때마다 Age 헤더에 상대적인 나이를 누적해서 더하도록 한다. Age 헤더 값은 프락시를 통과하면서 점점 늘어난다.  
그러나 응답 체인에 있는 비-HTTP/1.1 장치는 Age 헤더를 인식하지 못하고 고치지 않거나 삭제해버릴 수 있어 모두가 HTTP/1.1을 채택하지 않는 이상 모자란 추정값인 상태로 남아있을 수 있다.
이 상대 나이 값은 Date 와는 별개로 개산되어, 두 나이 추정값 중 보수적인(max) 것이 선택된다.

#### 네트워크 지연에 대한 보상

문서가 프락시들과 부모 캐시의 긴 연쇄를 거쳐서 왔다면 네트워크 지연은 상당한 수준일 것이다.  
HTTP/1.1은 서버에서 캐시로의 왕복 시간을 더함으로써 네트워크 지연을 보수적으로 교정한다.

```
겉보기_나이 = max(0, 응답_받은_시간 - Date_헤더값);
보정된_겉보기_나이 = max(겉보기_나이, Age_헤더값);
응답_지연_추정값 = 응답을_받은_시각 + 요청을_보낸_시각
문서가_캐시에_도착했을_때의_나이 = 보정된_겉보기_나이 + 응답_지연_추정값;
```

### 7.11.3 완전한 나이 계산 알고리즘

문서의 완전한 현재 나이를 계산하기 위해 문서가 캐시에 얼마나 오랫동안 머물렀는지 알 필요가 있다.
[그림 7-18]

### 7.11.4 신선도 수명 계산

어떤 문서의 신선도 수명은 문서가 클라이언트에게 제공해주기에는 더 이상 신선하지 않게 될 때까지 얼마나 오랜 시간 동안 가져올 수 있도록 허용되는지 말해준다. 신선도 수명은 서버와 클라이언트의 제약조건에 의존한다.

### 7.11.5 완전한 서버 신선도 알고리즘

```
휴리스틱 = 0;

if (Max_Age_헤더가_설정되었다면) {
    신선도_수명 = Max_Age_값;
} else if (Expires_헤더가_설정되었다면) {
    신선도_수명 = Expires_값 - Date_값;
} else if (Last_Modified_헤더가_설정되었다면) {
    신선도_수명 = max(0, (Date_값 - Last_Modified_값) * LM_비율);
    휴리스틱 = 1;
} else {
    신선도_수명 = 기본_최대_수명_기본값;
    휴리스틱 = 1;
}

if (휴리스틱) {
    if (신선도_수명 > 기본_최대_수명_기본값) {
        신선도_수명 = 기본_최대_수명_기본값;
    }

    if (신선도_수명 < 기본_최소_수명_기본값) {
        신선도_수명 = 기본_최소_수명_기본값;
    }
}
```

## 7.12 캐시와 광고

캐시는 성능을 개선하고 트래픽을 줄이는 것을 목표로 하지만, 광고 업계에서는 문제가 될 수 있다.

### 7.12.1 광고 회사의 딜레마

- 콘텐츠 제공자들은 광고를 통해 돈을 벌기 때문에 정확한 접근 횟수 통계가 필요
- 인터넷 캐시가 접근들을 흡수하여 원 서버의 실제 접근 횟수를 정확히 측정하기 어려움
- 광고료는 노출 횟수에 따라 결정되므로 중요한 이슈

### 7.12.2 퍼블리셔의 응답

오늘날 광고회사들은 '캐시 무력화' 가법을 사용하여 캐시가 시청 수를 가로채지 못하도록 한다.

- CGI 게이트웨이를 통해 매접근마다 광고 URL을 고쳐 씀

이상적으로는 콘텐츠 제공자는 캐시가 그들의 트래픽을 흡수하도록 내버려 두고, 캐시는 그들에게 적중이 얼마나 일어났는지 알려주어야 한다.

### 7.12.3 로그 마이그레이션

캐시 로그 활용

- 캐시 서버의 적중 로그를 수집하여 수동으로 제공
- 그러나 크기가 크고 비표준이며 인증과 프라이버시 이슈가 존재한다.
- 광고 수익을 교정해주는 지원 인프라 개발 필요

### 7.12.4 적중 측정과 사용량 제한

RFC 2227, "HTTP를 위한 간단한 캐시 적중량 측정과 사용량 제한"은 더 간단한 방법을 정의한다.

- 서버가 Meter 라는 헤더를 통해 특정 URL에 대한 캐시 적중 횟수를 정기적으로 받는다.
- 사용량 제한 : 서버는 캐시별로 문서 제공 횟수/처리 시간등을 설정하여 사용한도를 제어할 수 있다.
