# 클라이언트와 보안 식별

HTTP 트랜젝션은 상태가 없기 때문에 웹 사이트에서 각 사용자에서 오는 HTTP 트랜젝션을 식별할 방법이 필요하다.

사용자 식별 기술은 다음과 같다.

- `HTTP 헤더들`
- `클라이언트 IP 주소`
- `사용자 로그인 인증`
- `fat URL`
- `쿠키`

## 1. HTTP 헤더

- 사용자에 대한 정보를 전달하는 가장 일반적인 7가지 요청 헤더
- `Client-ip`, `X-Forwarded-For`, `Cookie`는 확장 헤더(선택적)

| 헤더 이름 | 헤더 타입 | 설명 |
| --- | --- | --- |
| **`From`** | 요청 | 사용자의 이메일 주소 |
| **`User-Agent`** | 요청 | 사용자의 브라우저 정보 |
| **`Referer`** | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지 |
| **`Authorization`** | 요청 | 사용자 이름과 비밀번호(뒤에서 다룸) |
| **`Client-ip`** | 확장(요청) | 클라이언트의 IP 주소(뒤에서 다룸) |
| **`X-Forwarded-For`** | 확장(요청) | 클라이언트의 IP 주소(뒤에서 다룸) |
| **`Cookie`** | 확장(요청) | 서버가 생성한 ID 라벨(뒤에서 다룸) |

### 1️⃣ From 헤더

- 사용자의 이메일 주소를 포함하는 헤더
- 개일정보 노출 우려로 잘 사용되지 않음
  - 악의적으로 이메일을 수집해서 스팸 메일 발송하거나함
- 현대 브라우저에서는 기본적으로 비활성화

### 2️⃣ User-Agent

- 클라이언트의 `브라우저 종류`, `버전`, `OS` 정보를 서버에 전달
- 활용 사례
  - 방문자의 브라우저 비율, OS 비율 파악
  - 모바일 / PC에 따른 다른 UI 제공
  - 봇 방지
  - 레거시 지원 (특정 브라우저 버전에는 다른 JS 제공해준다던지…)

```jsx
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36
```

### 3️⃣ Referer

- 클라이언트 요청의 출처를 전달
- 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킴

```jsx
Referer: https://www.google.com/search?q=리드AI
```

### 4️⃣ Client-ip

- 클라이언트의 IP를 명시적으로 담아 서버에 전달하는 확장 요청 헤더
- 취약점 존재
  - 공용 IP인 경우 식별 불가
  - ISP로 인한 동적 IP 주소의 경우에도 매번 다르기 때문에 식별 불가
  - NAT와 같이 ip를 변환하는 경우도 식별 불가
    ![스크린샷 2025-08-04 오전 12.49.28.png](attachment:79878774-831a-4357-bcc3-e8edc8970537:스크린샷_2025-08-04_오전_12.49.28.png)
  - 프락시 같은 경우는 `X-Forwraded-For` 헤더를 사용해도 신뢰 불가
    - 예를 들어, 클라이언트 IP가 공유 IP 혹은 변환 IP인 경우

### 5️⃣ Authorization

- 클라이언트가 서버에 인증 정보를 전달할 때 사용하는 헤더
- 자세한건 12장

### fat URL

- 헤더는 아니지만 사용자를 식별하는 방법 중 하나 (레거시)
- 사용자의 상태를 URL에 담아서 유지시키는 방법
  ```jsx
  https://example.com/page/ABC123
  ```
- 보안 취약
  - 링크 공유시에 사용자 정보 노출
  - 탈취하기 매우 쉬움

## 2. 쿠키

가장 많이 사용되는 사용자를 식별하고 세션을 유지하는 방식

### 1️⃣ 쿠키 타입

- 세션 쿠키와 지속 쿠키가 있음
- 세션 쿠키
  - 브라우저를 닫으면 파기
  - 메모리에 저장
  - `Expires`와 `Max-Age` 값이 없으면 세션 쿠키
- 지속 쿠키
  - 브라우저를 닫아도 유지
  - 디스크에 저장

### 2️⃣ 쿠키의 동작 방식

1. **서버에서 클라이언트로 쿠키를 생성**

   1. 클라이언트가 서버로 요청
   2. 서버가 응답 헤더에 `Set-Cookie` 포함

   ```jsx
   HTTP/1.1 200 OK
   Content-Type: text/html
   Set-Cookie: sessionId=ABC123; Path=/; HttpOnly; Secure
   ```

2. **클라이언트에서 서버로 쿠키를 담아 전송**

   1. 클라이언트가 서버로 발급받은 쿠키를 담아 전송
   2. 브라우저 자동으로 `Cookie` 헤더에 쿠키를 포함

   ```jsx
   GET /dashboard HTTP/1.1
   Host: example.com
   Cookie: sessionId=ABC123
   ```

- 구글 크롬 쿠키
  - SQLite에 쿠키를 저장한다.
  - 이런식으로 확인할 수도 있다
  ```jsx
  sqlite3 ~/Library/Application\ Support/Google/Chrome/Default/Cookies
  ```
  ```jsx
  SELECT host_key,
         name,
         value,
         datetime(creation_utc/1000000-11644473600, 'unixepoch') AS created_at
  FROM cookies
  LIMIT 10;
  ```
  ![스크린샷 2025-08-04 오전 12.09.04.png](attachment:7df68c0e-c0ae-45cb-af38-b897deba5837:스크린샷_2025-08-04_오전_12.09.04.png)

### 3️⃣ 쿠키 버전

- Version 0 쿠키 (넷스케이프 쿠키라고 불림)
- Version 1 쿠키 (RFC 2965)
  - Version 0의 확장이지만 거의 사용되지 않음

### 4️⃣ Version 0 쿠키

- 일반적으로 사용되는 쿠키
- Set-Cookie 헤더는 다음과 같은 옵션을 가짐

| 속성 | 설명 |
| --- | --- |
| **Name=Value(\*)** | 필수. 쿠키의 이름과 값 쌍 (예: `sessionId=ABC123`) |
| **Domain** | 쿠키가 유효한 도메인. 없으면 응답한 서버 도메인으로 제한됨 |
| **Path** | 쿠키가 유효한 경로. 기본 `/` |
| **Expires** | 쿠키 만료 시각 (GMT 형식 문자열, 예: `Wed, 21 Oct 2025 07:28:00 GMT`) |
| **Secure** | HTTPS 연결에서만 전송 |
| **HttpOnly** | (원래 Netscape 사양에는 없지만, 현재 브라우저에서 지원) JS 접근 차단 |

- 모든 쿠키는 다음과 같이 이어 붙임
  ![스크린샷 2025-08-04 오전 1.11.52.png](attachment:937ab619-fc61-43e8-83b4-72692e2aa25a:스크린샷_2025-08-04_오전_1.11.52.png)

### 5️⃣ Version 1 (RFC 2965) 쿠키

- Version 0을 호환하지만 대부분의 브라우저나 서버가 완전히 지원하지 않음

| 속성                  | 설명                                               |
| --------------------- | -------------------------------------------------- |
| **Name=Value**        | 필수. 쿠키의 이름과 값 쌍 (예: `sessionId=ABC123`) |
| **Domain**            | 쿠키가 유효한 도메인 (`.example.com` 등)           |
| **Path**              | 쿠키가 유효한 경로 (기본 `/`)                      |
| **Expires**           | 절대 만료 시각 (GMT 형식, Version 0과 동일)        |
| **Max-Age**           | 상대 만료 시간(초 단위). 0이면 즉시 삭제           |
| **Secure**            | HTTPS 연결에서만 전송                              |
| **HttpOnly**          | JS에서 접근 불가(XSS 방지)                         |
| **SameSite**          | CSRF 방지 옵션 (`Strict`, `Lax`, `None`)           |
| **Priority** (Chrome) | 쿠키 삭제 우선순위(`Low`, `Medium`, `High`)        |
| **Comment**           | 쿠키 용도 설명(현대 브라우저에서는 무시)           |
| **Version**           | RFC 2109/2965 쿠키 버전 식별 (보통 `1`)            |

- 추가적으로 Port에 대한 정보도 추가할 수 있음
- 클라이언트에서는 추가적인 키워드 구별을 위해 $ 접두어 사용
  ```jsx
  Cookie: $Version = 1;
  SESSIONID = abc123;
  $Path = '/';
  $Domain = 'example.com';
  $Port;
  ```

**버전 협상**

- Cookie2 요청 헤더
  - 클라이언트가 서버와 `쿠키 버전 호환성을 협상`하기 위해 사용
  ```
  Cookie2: $Version="1"
  ```
  - 클라이언트가 Version 1 쿠키를 지원한다는 것을 서버에 알림.
- 서버 응답 규칙
  - 서버가 Version 1 형식의 쿠키를 인식하면 `Set-Cookie2` 헤더로 쿠키를 전송
  - 서버가 Version 0 형식만 사용하면 기존 `Set-Cookie` 헤더 사용
- 중복 전송 시 동작
  - 만약 클라이언트가 같은 쿠키를 `Set-Cookie`와 `Set-Cookie2` 모두 보낸다면 서버는 이전 방식(Set-Cookie)만 무시하고 최신(`Set-Cookie2`)을 사용
- 업그레이드 신호
  - 서버가 아직 Version 0 쿠키만 보낼 때에도 클라이언트는 `Cookie2: $Version="1"` 헤더를 보내 해당 서버를 업그레이드할 수 있음을 알림

### 6️⃣ 쿠키와 캐싱

쿠키 트랜젝션과 관련된 문서를 캐싱하는 것은 주의해야함

- 캐시되지 말아야 할 문서가 있다면 표시
  - `Set-Cookie` 응답은 보통 사용자별 맞춤 데이터
  - 이런 응답을 잘못 캐시하면 다른 사용자에게도 그대로 전달될 수 있음
  ```jsx
  // 캐시 안한다는 걸 표시
  Cache-Control: no-cache, "Set-Cookie"

  // 혹은 캐시해도 되는 문서에는 캐시하여 대역폭 절약
  Cache-Control: public
  ```
- `Set-Cookie` 헤더를 캐시 하는 것에 유의
  - 캐시 서버에 Set-Cookie 응답까지 캐시해버리면 다른 사용자들에게 재사용되기 때문에 제거해야함
  - 문제 해결을 위해 캐시는 항상 원 서버에 확인해야함
  ```jsx
  Cache-Control: must-revalidate, max-age=0
  ```
- `Cookie` 헤더를 가지고 있는 요청을 주의
  - 개인정보를 담고 있을 수도 있기 때문에 처리 필요
  - 예시
    - Set-Cookie 있는 이미지는 캐시 가능 (이미지는 사용자별 차이 없음)
    - Set-Cookie 있는 텍스트 응답은 캐시 금지 (개인정보 포함될 수 있음)

# 기본 인증

## 1. 인증

### 1️⃣ HTTP의 인증요구/응답 프레임워크

- HTTP는 자체적으로 인증요구와 응답 메커니즘을 제공
- 서버는 요청이 오면 바로 응답하지 않고, 먼저 “너 누구야?”라고 묻는 방식
- 사용자가 올바른 자격 증명을 보내면 서버는 문서를 반환
- 이 과정을 통해 비인가 사용자가 민감한 자원에 접근하는 것을 방지

![스크린샷 2025-08-04 오전 10.22.15.png](attachment:d2265a5c-2bb3-46cf-8204-f626709806e5:스크린샷_2025-08-04_오전_10.22.15.png)

### 2️⃣ 인증 프로토콜과 헤더

- HTTP는 인증을 위해 특별한 `제어 헤더`를 사용
- 대표적인 인증 프로토콜은 두 가지
  - 기본 인증 (Basic Authentication)
  - 다이제스트 인증 (Digest Authentication)

**`헤더 흐름과 단계`**

| 단계 | 헤더 | 설명 | 메시지/상태 |  |
| --- | --- | --- | --- | --- |
| 요청 | - | 첫 요청에는 인증 정보가 없음. | GET |  |
| 인증요구 | `WWW-Authenticate` | 서버가 401 상태 코드와 함께 “사용자 이름+비밀번호를 보내라”는 지시를 보냄. | 401 Unauthorized |  |
| 인증 | `Authorization` | 클라이언트가 사용자 이름과 비밀번호를 인코딩해 `Authorization` 헤더에 담아 재요청. | GET |  |
| 성공 | `Authentication-Info` | 인증 성공 시 200 OK와 함께 문서 반환. `추가 인증 세션 정보`를 담을 수도 있음. | 200 OK |  |

![스크린샷 2025-08-04 오전 10.27.14.png](attachment:c219ae36-5743-4658-b668-093fb904967d:스크린샷_2025-08-04_오전_10.27.14.png)

- 서버가 클라이언트에 `WWW-Authenticate` 헤더를 보낼 때 `realm` 지시자를 통해 보안 영역 그룹을 확인할 수 있다.

<aside>
💡

`realm`

</aside>

- 클라이언트에게 어떤 영역에 대한 인증인지를 알려주는 문자열
- 같은 서버라도 서로 다른 리소스나 서비스에 대해 서로 다른 인증 영역을 가질 수 있음
- 예시
  ```jsx
  WWW-Authenticate: Basic realm="Family"
  ```
  - Family 영역에 대한 인증을 수행

## 2. 기본 인증

- 가장 잘 알려진 HTTP 인증 규약
- 거의 모든 주요 클라이언트와 서버에서 지원
- 원래 HTTP/1.0에 포함되어 있었으나, 상세 내용은 **RFC 2617**로 이동

<aside>
💡

RFC 2617

</aside>

- HTTP 인증: 기본 인증과 다이제스트 접근 인증에 대한 인터넷 표준 문서
- 현재는 폐지 상태
- 최신 표준은 **RFC 7617 (Basic)**, **RFC 7616 (Digest)** 로 대체됨

### 1️⃣ 기본 인증의 헤더 정보

- 기본 인증 프로토콜에서는 Authentication-Info 헤더를 사용하지 않음

| 구분 | 헤더 | 예시 | 설명 |
| --- | --- | --- | --- |
| **인증 요구 (서버 → 클라이언트)** | `WWW-Authenticate` | `WWW-Authenticate: Basic realm="Family"` | - 클라이언트에 인증 필요 알림- `realm`은 보호 구역 이름(어떤 비밀번호를 입력해야 하는지 구분용) |
| **인증 응답 (클라이언트 → 서버)** | `Authorization` | `Authorization: Basic dXNlcjpwYXNz` | - `username:password`를 콜론(`:`)으로 연결 후 Base64 인코딩- 서버는 이를 디코딩해 인증 수행 |
| **상태 코드** | `401 Unauthorized` | `HTTP/1.1 401 Unauthorized` | - 인증이 필요하거나 잘못된 경우 반환 |
| **인증 성공 시** | `200 OK` | `HTTP/1.1 200 OK` | - 인증에 성공하면 요청한 리소스와 함께 반환 |

### 2️⃣ Base-64 사용자 이름/비밀번호 인코딩

HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론(:)으로 이어서 합치고. base-64 인코딩함

<aside>
💡

Base 64 인코딩

</aside>

- 바이너리나 특수문자(국제 문자, 공백, 콜론 등)를 HTTP 헤더나 텍스트로 안전하게 전송하기 위함
- 원리
  - 데이터를 6비트 단위 시퀀스로 변환
  - 각 6비트를 64개의 문자 집합(알파벳 대소문자, 숫자, `+`, `/`)에서 선택해 표현
- 장점
  - 전송 중 데이터 변형을 방지할 수 있음
  - HTTP 헤더에서 허용되지 않는 문자(공백, 콜론 등)도 안전하게 포함 가능
- 특징
  - Base64 인코딩 자체는 암호화가 아님네트워크 상에서 쉽게 디코딩 가능
  - 주 목적은 HTTP 전송 호환성 확보와 문자 변형 방지

**`HTTP 기본 인증에서 Base 64 인코딩 과정`**

1. 사용자 입력

   ```jsx
   사용자 이름: brian-totty
   비밀번호: Ow!
   ```

2. `username:password`로 연결

   ```jsx
   brian-totty:Ow!
   ```

3. Base64 인코딩

   ```jsx
   YnJpYW4tdG90dHk6T3ch;
   ```

4. Authorization 헤더에 포함

   ```jsx
   Authorization: Basic YnJpYW4tdG90dHk6T3ch
   ```
