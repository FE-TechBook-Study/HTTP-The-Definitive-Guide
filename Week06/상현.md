# 상현
## 7.1 불필요한 데이터 전송

캐시를 사용하게 된다며 반복적인 같은 요청에 대하여 캐시된 사본을 전달하기에 원 서버가 중복해서 트래픽을 주고받는 낭비가 감소

## 7.2 대역폭 병목

많은 네트워크는 원격 서버보다 로컬 네트워크에 더 넓은 대역폭을 제공.
따라서 원격 서버에서 받아온 것을 로컬 네트워크에 캐싱을 하면 병목 현상 감소 가능

## 7.3 갑작스러운 요청 쇄도(Flash Crowds)

캐싱은 많은 사람들이 짧은 시간 안에 웹 문서에 접근할 때 웹 서버에 과부하를 경감 또는 대체 가능

## 7.4 거리로 인한 지연

통신이 빛의 속도로 이루어진다고 해도 물리적인 서버를 거치기에 지연 발생.
따라서 거리가 멀수록 지연 발생 가능

## 7.5 적중과 부적중

캐시에 사본이 있어서 전달을 했다면 캐시 적중(cache hit)
만약 대응하는 사본이 없다면 캐시 부적중(miss)

### 7.5.1 재검사(Revalidation)

![스크린샷 2025-07-15 오후 2.10.42.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F57c555c3-20d6-4315-9a4b-06770914d32f%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.10.42.png/size/w=1920?exp=1752804787&sig=cs6Z-rozh89wg3U78f9NegbCr5TtVHpn03AI_OldOfI&id=231438a5-b001-800f-87c4-f010fe2cdfe5&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

재검사란 원 서버 콘텐츠가 변경될 수 있기에 캐시의 내용이 여전히 최신인지 검사하는 신선도 검사
또한 캐시의 양은 많지만 네트워크 대역폭은 부족하기에 충분히 오래된 경우에만 재검사하도록 설정

재검사 적중 혹은 느린 적중: 캐시는 재검사가 필요할 때 “작은 재검사 요청”을 보내며 변경점이 없으면 아주 작은 304 Not Modified 응답을 전달

![스크린샷 2025-07-15 오후 2.16.54.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F431d2d8d-7e04-4afd-b731-bc8feecf5609%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.16.54.png/size/w=1920?exp=1752804802&sig=a9QO8sri6oVox3HwTdYhj_OpSvhny3JiFWJwXrDehSs&id=231438a5-b001-80cd-b50c-f0c021c68941&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

속도로 보면 (제일 빠름)캐시 적중 > 캐시 재검사 적중 > 캐시 부적중 순으로 느리다.
그 이유는 

- 캐시 적중은 사본을 그대로 들고오고
- 캐시 재검사는 원 서버와 검사를 하지만 캐시를 그대로 보낼 수 있고
- 캐시 부적중은 원 서봐 검사를 하고 서버 객체를 다시 받아와야 함.

또한, 재검사를 원 서버에 요청을 보낼 때 `If-Modified-Since` 헤더를 보내 해당 시간 이후로 변경점이 있는 원 서버에 요청을 보냄. 이 때 다음과 같은 세 가지 상황 발생 가능

- 재검사 적중: 객체가 변경되지 않았으니 작은 HTTP 304 Not Modified 전달
- 재검사 부적중: 사본과 다른다면 HTTP 200 OK와 함께 객체  전달
- 객체 삭제: 객체가 삭제되었다면 HTTP 404 Not Found 응답 전달

### 7.5.2 적중률

캐시 요청을 처리하는 비율을 “캐시 적중률” 또는 “문서 적중률”이라고 칭함.
흔히 퍼센트로 표시되며 0% ~ 100%로 사이로 표현되고 적중률을 높이는 것은 어렵기에 40%면 양호하다고 판단.

높이기 위해서는 아래를 확인하는 것이 좋음

- 캐시의 크기
- 캐시 사용자들의 관심사 유사도
- 캐시된 데이터의 변경 빈도
- 캐시 설정

### 7.5.3 바이트 적중률

문서들의 용량이 제각각 다르기에 얼마나 캐시가 잘 되었나를 판단하기 위해 절감된 정도를 표현하는 바이트 단위 측정률을 선호
퍼센트로 표시되며 0% ~ 100%로 사이로 표현되고 높을 수록 캐시의 양호성을 의미

### (부가) 적중률 및 바이트 적중률

둘 다 성능에 유용하며 각 다른 부분을 의미

- 문서 적중률 또는 캐시 적중률을 감소하면 전체 지연시간을 감소가능
- 바이트 적중률을 높이면 대역폭의 절약을 의미

### 7.5.4 적중과 부적중의 구별

HTTP는 응답을 전부 HTTP 200 OK로 주기에 캐시 적중인지 부적중인 구별할 수 없다.
해당 정보가 캐시인 지 판별을 하려면:

- 응답의 Date값이 요청의 Date보다 오래면 캐시
- 응답이 얼마나 오래되었는 지 알려주는 `Age`헤더를 확인

## 7.6 캐시 토폴로지

### 7.6.1 개인 전용 캐시

한 명에게만 할당된 캐시이며 웹 브라우저 개인 전용 캐시가 그 예.
자주 쓰이는 문서를 각 사용자 컴퓨터 디스크에 캐시를 하고 사용

### 7.6.2 공용 (프락시) 캐시

캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버.
자주 찾는 문서를 캐시에 저장하여 모든 요청에 대해 캐시의 문서를 제공.

프락시 캐시는 수동 설정하거나 자동 설정 가능(PAC, WPAD)

### 7.6.3 프락시 캐시 계층들

![스크린샷 2025-07-15 오후 3.01.13.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F98f693d1-7602-4ba5-a36a-fc988ea8551c%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.01.13.png/size/w=1920?exp=1752804816&sig=p08I9gnKb4RIhDq3uCVSZebOY1QmRmkZbsDbejsUhkg&id=231438a5-b001-8002-b081-c45f95c790b3&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

클라이언트 주의에 작고 저렴한 캐시들부터 원 서버로 가는 중간에 캐시 계층을 만들어서 지역 내에서 해결하는 아이디어
로컬에서 캐시 적중을 하지 않고 계속 부모 캐시로 성능 저하

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

(20장에서 더 자세히)

- URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거하여 특정 부모 캐시를 동적으로 선택
- 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 탐색
- 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 불허용

## 7.7 캐시 처리 단계

기본적으로 다음 7단계로 구성

![스크린샷 2025-07-15 오후 4.10.11.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F7356eec5-2b51-44a7-880f-ba7887cb4644%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.10.11.png/size/w=1920?exp=1752804832&sig=NYrEvuHvd-fIkFdAGRidtuoh7z4uTgJ0hLXJkw7wqlU&id=231438a5-b001-80b2-b472-d1301e98fc03&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

### 7.7.1 단계 1: 요청 받기

네트워크를 감지하고 요청 읽기

### 7.7.2 단계 2: 파싱

메세지를 여러 부분으로 파싱하고 처리하기 쉬운 자료 구조로 분리

### 7.7.3 단계 3: 검색

URL을 읽고 해당하는 로컬 사본 확인.
로컬에서 가져올 수 있는지 알고리즘을 통해 확인 후

- 가져올 수 있다면, 찾아서 반환
- 가져올 수 없다면, 원 서버나 부모 프락시에서 가져오거나 실패 반환

캐신된 객체는 얼마나 오랬동안 캐시에 머물렀는지 얼마나 자주 사용되었는지 등에 대한 메타데이터를 같이 포함

### 7.7.4 단계 4: 신선도 검사

사본의 신선도를 판별하는 정보를 통하여 신선도 검사를 하고

- 신선하지 않으면, 원 서버에 요청하여 재검사
- 신선하다면, 사본을 선택

### 7.7.5 단계 5: 응답 생성

캐시된 응답은 원 서버에서 온 것 처럼 보이게 하고 싶기 때문에 캐시는 캐시된 서버 응답 헤더를 토대로 응답 생성
(캐시에 의해 수정되고 늘어날 수 있음)

캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임을 가짐.

- 클라이언트가 1.1 버전으로 응답을 기대하는데 서버가 1.0 응답을 가지고 있다면 반드시 헤더를 적절하게 번역 필요
- 캐시 신선도 관련 정보를 삽입
- 요청이 프락시 캐시를 거쳐갔음을 표시하기 위해 Via 헤더

주의할 것은 Date 헤더 값은 원 서버에서 최초로 생겨난 일시를 표현하기에 수정 불가

### 7.7.6 단계 6: 전송

응답 헤더가 준비되면 캐시는 응답을 클라이언트로 전달

### 7.7.7 단계 7: 로깅

- 캐시 적중, 부적중 횟수 등 통계기록 관련을 갱신
- 요청 종류, URL, 이벤트 기록

가장 많이 쓰이느 다음 두 개 이며 21장에서 더 자세히

- 스퀴드 로그 포맷(Squid log format)
- 넷그케이프 확장 공용 로그 포맷(Netscape extended common log format)

## 7.8 사본을 신선하게 유지하기

### 7.8.1 문서 만료

원 서버가 각 문서에 유효기간을 표시할 수 있게 `Cache-Control`과 `Expires`라는 특별한 헤더를 사용

### 7.8.2 유효기간과 나이

`Cache-Control`과 `Expires`는 둘다 같은 역할을 하지만 표시 방식과 만료 체크방식에 미묘한 차이가 존대

- `Cache-Control: max-age`: 문서가 처음 생성된 이후부터 더 이상 신선하다고 간주될 때까지의 경과한 시간의 최대갑(초 단위)
    - `Cache-Control: max-age=484200` → 2022년 6월 29일 09:30 ~ 2022년 7월 5일 사이 기간의 초 단위 환산, 134.5(시간) * 3600(초)
- `Expires`: 절대 유효기간 명시하여 경과하면 신선하지 않은 것으로 판단
    - `Expires: Fri, 05 Jul 2002, 05:00:00 GMT`

### 7.8.3 서버 재검사

캐시 만료된 문서라고 해서 문서가 만료되었다기보다는 검사를 할 시간이 되었다는 것을 뜻 함

- 재검사 결과 콘텐츠가 변경 되었다면, 문서의 새로운 사본으로 갈음 후 클라이언트에 전달
- 재검사 결과 콘텐츠가 변경이 없다면, 새 만료일을 포함한 새 헤더들로 캐시 데이터의 헤더를 갱신

HTTP 프로토콜은 캐시로부터 다음 행동 중 하나를 기대:

- ‘충분히 신선한’ 캐시된 사본
- 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
- 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
- 경고 메시지가 부착된 캐시된 사본(부정확하다면)

### 7.8.4 조건부 메서드와 재검사

HTTP는 조건부 메서드(GET)를 통해서 캐시 재검사를 효율적으로 운영
조건부 헤더를 통해서 보내며 조건이 참인 경우에만 객체를 반환

캐시 검사에 자주 쓰이는 헤더는:

- `If-Modified-Since: <data>` 문서가 주어진 날짜 이후로 수정이 되었다면 요청 메서드 수행하며 `Last-Modified` 헤더와 같이 사용
- `If-None-Match: <tags>` 문서에 대한 일렬번호(E-tag같은)을 통하여 문서의 태그가 다를 경우에 요청 수행

### 7.8.5 If-Modified-Since: 날짜 재검사

흔히 ‘IMS 요청’이라고 부르며,

- 문서가 주어진 날짜 이후 변경이 있다면 조건이 참이기에 문서를 받아와 캐시에 저장
- 문서가 주어진 날짜 이후 변경되지 않았다면 조건은 거짓이고 서버는 작은 304 Not Modified응답과 **헤더만** 클라이언트에 전달

Last-Modified 헤더와 함께 동작하며 몇몇 웹 서버는 “날짜 이후에 변경된 것”을 보는 것이 아닌 “마지막 변경일자가 이 날짜가 아닌 경우”에 문서를 반환하도록 문자열 비교만하여 설정

```tsx
// 서버로 요청
GET xxxxxx
If-Modified-Since: Sat, 29 Jun 2022, 14:30:00 GMT
```

### 7.8.6 If-None-Match: 엔티티 태그 재검사

일시에 대한 재검사가 어려운 상황들로:

- 문서가 일정 간겨으로 다시 쓰여지지만 실제로는 같은 데이터를 포함
- 어떤 변경이 문서의 변경으로 받아들이기에는 사소한 것(철자는 사소한 주석의 변경)
- 어떤 서버는 페이지에 대한 최근 변경 일시를 정확하기 판별 불가능
- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게 정밀도가 충분하지 않을 수 있음

```tsx
// 서버로 요청
GET xxxxxx
If-None-Match: "v2.6"
```

변경점이 없다면 304 Not Modified
변경점이 있다면 새 사본과 Etag와 함께 반환

### 7.8.7 약한 검사기와 강한 검사기

HTTP 1.1에서 비록 콘텐츠가 조금 변경되었더라고 “같은 것” 으로 서버가 주장할 수 있게 해주는 “약한 검사기(weak validator)” 지원
”강한 검사기(strong validator)”는 콘텐트가 바뀔 때마다 변경

약한 검사기는 “W/” 접두사로 판별

```tsx
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

### 7.8.8 언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

엔티티만 있다면 엔티티를 이용
Last-Modified만 있다면 If-Modified-Since
둘 다 받고 둘 다 보낸다면, 서버는 모두 만족하지 않으면 304 Not Modified를 반환

MDN에 If-None-Match 문서와 If-Modified-Since header 에 따르면 둘 다 있을 경우에, If-None-Match가 더 우선시 된다는 것을 확인 가능

> When used in combination with [`If-Modified-Since`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/If-Modified-Since), `If-None-Match` has precedence if the server supports it. [**MDN: If-None-Match**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/If-None-Match?utm_source=chatgpt.com)
> 

> When used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/If-None-Match), it is ignored, unless the server doesn't support `If-None-Match`. [**MDN: If-Modified-Since header**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/If-Modified-Since?utm_source=chatgpt.com)
> 

## 7.9 캐시 제어

### 7.9.1 no-cache와 no-store 응답 헤더

```tsx
Cache-Control: no-store
Cache-Control: no-cache
Progma: no-cache
```

‘no-store’는 캐시에서 해당 리소스를 저장 X
’no-cache’는 캐시에 저장되지만 서버와 재검사를 꼭 하고 클라이언트에 전달 뜻함
`Progma: no-cache`는 HTTP1.0 하위호환을 위해서 포함. 하위호환이 필요 없을 경우 `Cache-Control: no-cache`로 사용

### 7.9.2 Max-Age 응답 헤더

```tsx
Cache-Control: max-age=484200
Cache-Control: s-maxage=484200
```

서버에 온 시간부터까지의 유효기간 표시
s-maxage는 공유된 캐시에만 적용

### 7.9.3 Expires 응답 헤더

```tsx
Expires: Sat, 29 Jun 2022, 14:30:00 GMT
```

각 서버마다 동기화가 안 되어 있거나 부정확한 시계를 가지고 있을 수 있기에 실제 만료 날짜를 명시하여 해당 날짜 이후로는 만료되도록 설정
Expires: 0로 설정하여 항상 만료되도록 설정하는 것은 문법 위반이기에 비권장

### 7.9.4 Must-Revalidate 응답 헤더

```tsx
Cache-Control: must-revalidate
```

신선하지 않은 리소스를 원 서버와의 최초 검사 없이는 제공 불가를 의미
캐시가 원 서버에 신선도 검사를 했지만 원 서버가 사용할 수 없는 상태이면 캐시가 504 Gateway Timeout error 반환

### 7.9.5 휴리스틱 만료

`Cache-Control: max-age` 또는 `Expires` 헤더 어느 것도 없다면 캐시는 경험적인 방법(heuristic)으로 최대 나이 계산

그 중 하나인 LM 인자 알고리즘은:

- 캐시된 문서의 마지막 변경일이 상당히 예전이라면 안정적인 문서라 판단하고 오래 보관되어 있어도 안전하다고 판단
- 캐시된 문서가 최근데 변경되었다면 아마 자주 변경될 것이라고 추측하고 짧은 시간 동안만 캐시

휴리스틱으로 계산한 신선도의 최대치는 1주일이며 보수적인 사이트는 하루로 설정
최근 변경일 조차 없다면 기본 신선도(1시간 ~ 1일)로 설정하며 보수적인 사이트는 클라이언트에게 데이터 제공할 때마다 신선도 재검사 실행

### 7.9.6 클라이언트 신선도 제약

웹브라우저는 브라우저의 캐시나 프락시 캐시의 콘텐츠를 강제로 갱신시켜주는 리프레시가가 있으며 이 때 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사 및 콘텐츠 로드

### 7.9.7 주의할 점

퍼블리셔가 터무니 없는 유효기간을 설정한다든가 아예 사용조차 하지 않아서 문서의 신선도 체크가 어려운 상황도 존재

## 7.10 캐시 제어 설정

### 7.10.1 아파치로 HTTP 헤더 제어하기

mod_headers

- 개별 헤더 설정 조작 가능

```tsx
<Files *.html>
 Headers set Cache-control no-cache
</Files>
```

mod_expires

- 만료 날짜가 담긴 Expires 헤더를 자동을 생성하는 로직 제공
- 아래 기재 방법들과 같이 편리한 기술 방식도 사용 가능

```tsx
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 miutes"
```

mod_cern_meta

- 파일에 대응되는 메타 파일을 생성하여 원하는 HTTP 헤더들를 추가 가능

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

웹 서버 설정 파일과의 상호작용 없이도 쉽게 HTML 문서에 HTTP 정보를 부여할 수 있게 HTML 2.0은 `<META HTTP-EQUIV>` 태그를 정의하여 아래와 같이 사용 가능

```tsx
<HTML>
	<HEAD>
	  <TITLE></TITLE>
	  <META HTTP-EQUIV="Cache-contorl" CONTENT="no-cahce" >
	</HEAD>
```

그러나 이 기능은 서버의 부하를 가증하며, 정적인 설정값이며, HTML만 지원하기에 웹 서버나 프락시는 기능 지원X
브라우저가 이를 해독하여 HTTP 헤더로 사용하여 혼란을 초래할 수 있기에 서버가 보내온 HTTP 헤더를 보는 것일 제일 확실

![스크린샷 2025-07-18 오전 9.41.29.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fe25cf181-abe4-4db9-8932-77d1408562c9%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-07-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.41.29.png/size/w=1920?exp=1752804857&sig=U2GfHGkURhvWS0O7XiKDCGpgGkdrK1vCbHd25wCl_8Q&id=234438a5-b001-80e7-b2a5-d51b822e329e&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

## 7.11 제사한 알고리즘

> 캐시 만료 공식의 적나라한 세부사항에 관심이 없다면, 이 절은 건너뛰어도 좋다
> 

### 7.11.1 나이와 신선도 수명

캐시된 사본의 나이와 신선도 수명 이 두가지로 클라리언트 전달 여부가 판단
`충분히_신선한가 = 나이 < 신선도 수명`

캐시는 서버가 보내온 Age헤더나 Date헤더를 통해 문서의 나이를 판별하고
(GPT 체크)신선도 수명은 max-ages나 Expires를 통해 확인

클라이언트가 요구하는 신선도 기준이 다를 수 있으며

- `Cache-Control: max-stale` ****→ 좀 오래된 거여도 받아
- `Cache-Control: min-fresh` → 앞으로도 신선할 시간 남은 것만 줘

### 7.11.2 나이 계산

```tsx
const 겉보기_나이 = max(0, 응답받은_시각 - Date_헤더값)
const 보정된_겉보기_나이 = max(겉보기_나이, Age_헤더값)
const 응답_지연_추정값 = 응답받은_시각 - 요청을_보낸_시각
const 문서가_우리의_캐시에_도착했을_떄_나이 = 보정된_겉보기_나이 + 응답_지연_추정갑
const 사본이_우리의_캐시에_머무른_시간 = 현재시각 - 응답을받은_시각

const 나이 = 문서가_우리의_캐시에_도착했을_떄_나이 + 사본이_우리의_캐시에_머무른_시간
```

응답의 나이: 서버에서 생성되었을 때부터 지금까지의 총 시간

- 서버 → 라우터 → 게이트웨이 → 클라이언트(캐시)까지의 시간을 전부 의미
- 계산은 Date헤더나 Age헤더를 분석하여 정립

그러나, 다른 캐시에서 받은 사본은 나이를 알기 어려운 데 그 이유는 모든 서버가 동기화된 시계를 갖고 있지 않기 때문에.

**겉보기 나이는 Date 헤더에 기반한다**
그렇기에 모든 서버의 시간은 잘 동기화 되어있지 않기에 차이가 나는 시간을 대비 필요
시계 설정 차이로 인한 문제 = 클록 스큐
나이가 음수로 계산이 된다면 0으로 보정이 필요

**점층적 나이 계산
….**

## 7.12 캐시와 광고

### 7.12.1 광고 회사의 딜레마

캐시를 통해서 빠르게 콘텐츠를 보여주고 네트워크 비용 감소 가능.
그러나 광고는 볼 때마다 돈을 벌고 원 서버의 접근 횟수도 상관이 있기에, 캐시를 사용하게 된다면 접근 횟수에 따른 프로세스가 작동하지 않음

### 7.12.2 퍼블리셔의 응답

캐시가 광고 시청 수를 가로채지 않기 위해서 ‘캐시 무력화’ 기법 사용
원 서버와 통신이 되었기에 횟수를 알 수 있고 본문 데이터를 전송하지 않지만 트랜잭션 소요가 있음

### 7.12.3 로그 마이그레이션

모든 것을 캐시로 받고 로그를 원 서버에 전달해줄 수 있으나 로그 분별 또는 분리가 어렵고 용량이 크기에 어려움 존재.
이를 해결하기 위해서 벤더 사들이 협력하여 개발

### 7.12.4 적중 측정과 사용량 제한

RFC 2227 SImple Hit-Metering and Usage-Limiting for HTTP에서 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter 헤드를 사용하여 서버는 업데이트 받을 수 있음
21장에서 더 자세히 알 예정
