HTTP 애플리케이션은 인터넷 콘텐츠 접근을 위한 통일된 방법을 제공한다. HTTP 위에 다른 프로토콜을 얹고자 할 때 **게이트웨이, 터널, 릴레이**가 등장하며, 각각 다음과 같은 역할을 한다

- **게이트웨이**: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
- **애플리케이션 인터페이스**: 웹 애플리케이션 간 통신을 담당
- **터널**: HTTP가 아닌 트래픽을 전송할 때 사용
- **릴레이**: 단순한 HTTP 프락시로, 한 번에 한 개의 요청을 전달

## 8.1 게이트웨이

### 🔹 정의

- 클라이언트의 요청을 받아 다른 프로토콜 또는 시스템으로 전달하고 응답을 반환하는 중계자
- 예: HTTP → FTP, HTTP → 데이터베이스 등

### 🔹 게이트웨이 유형 3가지 예시

1. **FTP 서버용 게이트웨이**
    - HTTP 요청을 받아 FTP 명령으로 변환
2. **보안 게이트웨이 (SSL)**
    - HTTPS 요청을 SSL로 해독 후 HTTP 서버로 전달
3. **애플리케이션 서버 게이트웨이**
    - HTTP 요청을 API 호출로 변환하여 백엔드 애플리케이션과 통신

![스크린샷 2025-07-28 오후 9.03.52.png](attachment:4383584b-13a5-496a-b636-342c84551779:스크린샷_2025-07-28_오후_9.03.52.png)

### 🔹 클라이언트 측 vs 서버 측 게이트웨이

- **서버 측**: 클라이언트는 HTTP, 서버는 외부 프로토콜
- **클라이언트 측**: 클라이언트는 외부 프로토콜, 서버는 HTTP
- 클라이언트 측 프로토콜과 서버 측 프로토콜을 `/`으로 구분해 기술한다.

---

## 8.2 프로토콜 게이트웨이

### 🔹 개요

- 트래픽을 HTTP 외 다른 프로토콜로 자동 변환하는 구성
- 사용자는 HTTP만 쓰지만, 게이트웨이는 내부적으로 FTP 등으로 변환

### 🔹 예시

- 브라우저의 프락시 설정에서 FTP URL 요청 시, HTTP/FTP 게이트웨이로 전달

![스크린샷 2025-07-28 오후 9.06.24.png](attachment:1ea861f3-dcfa-40ad-a6dc-cd863fda659f:스크린샷_2025-07-28_오후_9.06.24.png)

---

## 8.3 리소스 게이트웨이

### 🔹 개요

- 애플리케이션 서버와 웹 서버 사이의 연결
- 클라이언트는 HTTP 요청, 게이트웨이는 API 호출로 응답

### 🔹 예시

- A: 디지털카메라 이미지 요청 → API → 최종 이미지 반환
- B: 전자상거래 요청 → API → HTML 페이지로 결과 반환

![스크린샷 2025-07-28 오후 9.07.36.png](attachment:ab49d19c-4dc9-40e8-8fe6-43c04301c2c1:스크린샷_2025-07-28_오후_9.07.36.png)

---

## 8.3.1 공용 게이트웨이 인터페이스 (CGI)

### 🔹 특징

- 가장 오래된 서버 확장 인터페이스
- 서버는 CGI를 통해 특정 URL 요청 시 외부 프로그램 실행

### 🔹 동작 방식

- 요청이 들어오면 CGI 프로그램 프로세스를 생성
- 응답을 만들어 클라이언트에 전달

![스크린샷 2025-07-28 오후 9.08.35.png](attachment:06798de5-30cd-40ac-a31b-9305c6130ce6:스크린샷_2025-07-28_오후_9.08.35.png)

---

## 8.3.2 서버 확장 API

### 🔹 기존 CGI 문제점

- CGI는 매 요청마다 프로세스를 생성 → 성능 저하
- 해결책: Fast CGI 또는 서버 확장 API

### 🔹 서버 확장 API

- 서버 내에서 직접 모듈 형태로 동작
- 더 빠르고 안정적임
- 예: FrontPage Server Extension (FPSE)

---

## 8.4 애플리케이션 인터페이스와 웹 서비스

- 기존의 리소스 게이트웨이는 단순히 HTTP를 통해 요청/응답을 처리
- 그러나 복잡한 애플리케이션 연동 시에는 단순 HTTP로 표현하기 어려운 정보 교환 필요
- HTTP 확장
    - FrontPage 서버 확장 → POST 메시지에 RPC 덧붙임
    - WebDAV → HTTP 헤더에 XML 첨부
- **웹 서비스(Web Services)**
    - 웹 애플리케이션 간 통신을 위한 표준화된 방식
    - SOAP (Simple Object Access Protocol): XML로 데이터를 포장해 HTTP 메시지에 담아 전송
    

---

## 8.5 터널

HTTP가 아닌 트래픽을 HTTP 연결을 통해 전달하는 기법.

### 🔸 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

- `CONNECT` 메서드는 클라이언트가 게이트웨이에 터널 요청
- 게이트웨이는 대상 서버와 TCP 커넥션 연결 후, HTTP 200 응답을 반환
- 이후 클라이언트와 서버 간의 모든 데이터는 **암호화된 상태로 양방향 전송**
- CONNECT 예시
    
    ```
    CONNECT home.netscape.com:443 HTTP/1.0
    User-agent: Mozilla/4.0
    ```
    

### 🔸 데이터 터널링, 시간, 커넥션 관리

- 게이트웨이는 터널 안의 데이터 내용을 볼 수 없음
- 순서, 흐름 파악 불가 → **데이터는 언제든지 도착**
- CONNECT 요청 이후 인증 실패 시 → 인증 후 재요청 필요
- 커넥션이 한쪽에서 끊기면 반대쪽도 프락시에 의해 끊김

### 🔸 SSL 터널링

- 원래는 SSL 트래픽이 방화벽에 막힘 → 우회 위해 **HTTP 터널링** 사용
- SSL 암호화된 데이터는 필터링 불가 → HTTP 포트(80)로 우회 가능

![스크린샷 2025-07-28 오후 9.13.28.png](attachment:44f051f6-786d-4cc9-b608-4da9c589aebc:스크린샷_2025-07-28_오후_9.13.28.png)

### 🔸SSL 터널링 vs HTTP/HTTPS 게이트웨이

| 항목 | SSL 터널링 | HTTPS 게이트웨이 |
| --- | --- | --- |
| 보안 적용 범위 | 클라이언트 ↔ 서버 전체 | 클라이언트 ↔ 게이트웨이 |
| 인증 방식 | 클라이언트가 직접 인증 | 게이트웨이는 인증 미지원 가능 |
| 사용 편의성 | 좋음 (보안 우수) | 설정과 관리 복잡 |

### 터널 인증

- 프락시가 터널 요청을 허용하기 전에 **인증** 절차 필요
- 예시 흐름
    1. CONNECT 요청
    2. 프락시가 인증 요구 (407)
    3. 인증 포함한 CONNECT 재요청
    4. TCP 연결 후 200 응답

![스크린샷 2025-07-28 오후 9.13.05.png](attachment:503c1ddc-0a05-4f3c-beb2-962059ad834c:스크린샷_2025-07-28_오후_9.13.05.png)

### 🔸터널 보안에 대한 고려사항

- 게이트웨이는 터널 안의 트래픽 내용 식별 불가
- 악용 가능성 존재 (예: 사내 게임 트래픽, 암호화된 피싱 등)
- 해결책: **포트 기반 화이트리스트** 도입

---

## 8.6 릴레이

HTTP 릴레이는 단순 HTTP 프락시로서 명세를 완전히 준수하지 않는 **단순 트래픽 중계자**

### 🔸 특징

- 모든 헤더나 메서드 로직을 처리하지 않고 무조건 전달
- 간단한 필터링/진단에 사용 가능하지만, **상호 운용 문제 발생 가능**

### 🔸 위험 예시: Keep-Alive 문제

1. 클라이언트가 `Connection: Keep-Alive` 요청
2. 릴레이는 이를 이해하지 못하고 그대로 서버로 전달
3. 서버는 응답에 Keep-Alive 헤더 포함
4. 클라이언트는 연결 유지된다고 판단하고 다음 요청
5. 릴레이는 이를 처리하지 않아 hang(멈춤) 상태 발생

![스크린샷 2025-07-28 오후 9.14.17.png](attachment:54831faa-a1a3-4655-b669-16b99731e130:스크린샷_2025-07-28_오후_9.14.17.png)

### 🔸 결론

- 릴레이는 의도치 않게 통신을 망칠 수 있음
- 단순 릴레이라 해도 HTTP 명세를 어느 정도 준수하도록 구현해야 함