이 장에서는 여러 종류의 리소스에 접근하는데 HTTP가 어떻게 쓰이는지 알아보고, 다른 프로토콜이나 애플리케이션 간 통신에 HTTP를 어떻게 사용하는지 알아본다.

- 게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스다.
- 애플리케이션 인터페이스: 서로 다른 형식의 웹 애플리케이션이 통신하는 데 사용한다.
- 터널: HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하는 데 사용한다.
- 릴레이: 일종의 단순한 HTTP 프락시로, 한 번에 한 개의 홉에 데이터를 전달하는 데 사용한다.

# 1. 게이트웨이

웹이 더 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것은 분명해졌다.

이 문제에 대한 해결책으로, 인터프리터 같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트웨이를 고안해냈다.

게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.

애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고, 게이트웨이는 그에 응답할 수 있다.

게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작하는데, 동적인 콘텐츠를 생성하거나 데이터 베이스에 질의를 보낼 수 있다. 

![image.png](attachment:8a250042-9faf-40d8-92fe-519fe428bc39:image.png)

이미지 설명:

클라는 HTTP를 통해 리소스 요청하고, 죠의 컴퓨터 가게 서버는 리소스를 얻기 위한 게이트웨이 인터페이스 역할을 하고 있다.

게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다.

![image.png](attachment:e4719f4d-c4c8-4974-946a-fc0a24bc5abe:image.png)

### (a) HTTP/FTP 서버 측 FTP 게이트웨이

- **구성:**
    
    `HTTP 클라이언트 → 게이트웨이 → FTP 서버`
    
- **설명:**
    
    사용자는 브라우저(HTTP 클라이언트)를 통해 FTP 서버의 리소스에 접근하고 싶지만, 직접 FTP를 사용할 수 없을 경우, **게이트웨이가 HTTP 요청을 FTP로 변환**하여 대신 통신한다.
    
    즉, **HTTP ↔ FTP 프로토콜 변환 게이트웨이이다.**
    
- **활용 예:**
    
    웹 브라우저 주소창에 `ftp://`로 시작하는 URL을 입력했을 때, 브라우저가 내부적으로 FTP를 처리하지 못하면, 중간 게이트웨이가 FTP 서버와 통신하여 콘텐츠를 가져온다.
    

---

### (b) HTTPS/HTTP 클라이언트 측 보안 게이트웨이

- **구성:**
    
    `HTTPS 클라이언트 → 게이트웨이 → 웹 서버`
    
- **설명:**
    
    클라이언트는 HTTPS(암호화된 통신)를 사용하지만, 서버는 HTTP(암호화되지 않은 통신)만 지원할 경우, **게이트웨이가 암호화 해제 및 변환 역할**을 한다.
    
    즉, 게이트웨이는 **HTTPS ↔ HTTP 프로토콜 중계자**로 동작하며, 보안 요구를 만족시키는 동시에 서버와의 통신도 가능하게 한다.
    
- **활용 예:**
    
    회사 내부망에서 HTTPS 트래픽을 **프록시 서버**나 **SSL Terminator**에서 받아서, 내부 HTTP-only 서비스로 전달하는 경우.
    

---

### (c) HTTP/CGI 서버 측 애플리케이션 게이트웨이

- **구성:**
    
    `HTTP 클라이언트 → 앱 서버(게이트웨이 역할) → 프로그램 (CGI 또는 API 호출)`
    
- **설명:**
    
    클라이언트는 HTTP 요청을 통해 서버에 접근하지만, 서버에서 실제 비즈니스 로직을 처리하는 것은 별도의 프로그램이다.
    
    **앱 서버가 게이트웨이 역할**을 하며, 클라이언트 요청을 받아 CGI(또는 다른 API)를 통해 로컬 프로그램을 실행하고 그 결과를 HTTP로 응답한다.
    
- **활용 예:**
    
    PHP, Python, Perl 같은 스크립트 언어 기반의 CGI 방식 웹 애플리케이션. 또는 현대에는 Node.js, Flask, Django 같은 백엔드 프레임워크도 이와 유사한 구조를 가짐.
    

## 1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로 구분해 기술한다.

HTTP/NNTP → HTTP 클라이언트와 NNTP 뉴스 서버 사이의 게이트웨이.

서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다.

클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다. 

# 2. 프로토콜 게이트웨이

프락시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.

보통, 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리 서버(리버스 프락시)로 설정할 수도 있다.

![image.png](attachment:4d3eb70f-a3df-4db3-98af-c149a57dffa2:image.png)

## 2.1 HTTP/*: 서버 측 웹 게이트웨이

서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다. 

![image.png](attachment:5fd56fd6-cb63-4061-919a-7fa7b9c8329f:image.png)

## 2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있다.

클라는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호활 것이다.

![image.png](attachment:e55c178c-cb63-4879-bc01-ed5a20485ec0:image.png)

## 2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

![image.png](attachment:fbb8a18a-1212-459c-8444-4aa9dff8bd1d:image.png)

웹 서버의 앞단에 게이트웨이가 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다.

이 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹서버로 보낼 일반 HTTP 요청을 만든다. 

원 서버보다 더욱 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 한다. 

하지만 이는 게이트웨이와 원 서버 간의 암호화하지 않은 트래픽을 전송하기 때문에, 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야 한다. 

# 3. 리소스 게이트웨이

게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버오 게이트웨이를 한 개의 서버로 결합한다.

애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이다.

애플리케이션 서버는 게이트웨이의 애플리케이션 프로그래밍 인터페이스(API)를 통해서 요청을 서버에서 동작하고 있는 애플리케이션에 전달한다. 

![image.png](attachment:a2b6609c-92f8-4d4e-8938-8c429ccd18dc:image.png)

### 애플리케이션 서버

- **핵심 기능:**
    
    HTTP 클라이언트의 요청을 받아, **서로 다른 백엔드 시스템(API, 장비, 소프트웨어)** 에 중계하는 **중앙 허브 역할**을 수행.
    
- **API 구성:**
    - `웹 카메라 API`: 실제 하드웨어(카메라 장비, 영상 처리 소프트웨어 등)와 연동
    - `전자상거래 API`: 내부 비즈니스 로직을 담은 시스템과 연동

애플리케이션 게이트웨이에서 유명했던 최초의 API는 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)였다.

CGI는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합이다.

지난 수년간, 상용 웹 서버는 웹서버와 애플리케이션 간의 통신에 사용할 정교한 인터페이스를 제공해왔다.

게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리한다.

헬퍼 애플리케이션은 필요한 데이터를 전달받는다.

전달받은 데이터는 요청 전체이거나 사용자가 데이터베이스에서 실행시키려는 질의 같은 것이다. (URL의 query string을  통해 전송된다.)

그 다음, 바로 클라이언트로 전달할 응답이나 응답 데이터를 서버에 반환한다.

서버와 게이트웨이는 별개의 애플리케이션이기 때문에 각각 가지고 있는 책임은 분명히 나뉘어 있다 .

이 단순한 프로토콜(요청을 받아 처리해서 응답하는)은 가장 오래되고 널리 쓰이는 서버 확장 인터페이스인 CGI이다.

![image.png](attachment:be4c6e64-ca48-47d7-a221-d3c3b3c768af:image.png)

## 3.1 공용 게이트웨이 인터페이스 (CGI)

최초의 서버 확장이자 지금까지도 갖아 널리 쓰이는 서버 확장이다.

웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 쿼리 등을 제공하는 데 사용한다.

CGI 애플리케이션이 서버와 분리되면서 펄(Perl),Tcl, c, 다양한 셸 언어를 포함하여 수많은 언어로 구현할 수 있게 되었다.

CGI는 단순하므로 거의 모든 HTTP 서버가 지원한다.

클라가 CGI 애플리케이션이 무언가를 하고 있다는 것을 알 수 있는 유일한 단서는 URL에 있는 ‘cgi’ 혹은 ‘?’ 같은 것들뿐이다.

CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공한다. 

인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭하다고 할 수 있다. 

하지만 이런 분리 때문에 성능 관련 비용이 발생한다.

이 문제를 피하고자 새로운 CGI 형식인, Fast CGI가 개발되었다.

## 3.2 서버 확장 API

CGI 프로토콜은 구동 중인 HTTP 서버에 외부 인터프리터가 쉽게 접속할 수 있게 해주지만, 서버 자체의 동작을 바꾸고 싶거나 서버의 처리능력을 최고치로 끌어올리고자 할 때는 어떻게 해야할까?

서버 개발자는 웹 개발자가 자신의 모듈을 HTTP와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API를 제공하였다.

프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 하였다.

# 4. 애플리케이션 인터페이스와 웹 서비스

웹 애플리케이션이 더 많은 형식의 서비스를제공함에 따라, HTTP가 애플리케이션을 연결하는 도구로 활용할 수 있다는 게 더 확실해졌다.

애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나는, 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일이다.

애플리케이션이 상호 운용을 하다보면 HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있다.

인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할  표준과 프로토콜 집합을 개발하였다.

이러한 표준은, 원애 웹 서비스가 독립형 웹 애플리케이션(빌딩 블록) 그 자체를 의미함에도 불구하고, 그냥 그대로 웹 서비스로 불리게 되었다.

원래 웹 서비스가 새로운 용어는 아니지만, 여기서 웹 서비스는 애플리케이션이 정보를 공유하는데 사용하는 새로운 메커니즘을 의미한다. 

웹 서비스는 HTTP 같은 표준 웹 기술 위에서 개발한다.

웹 서비스는 SOAP을 통해 XML을 사용하여 정보를 교환한다.

XML(eXtensible Markup Language)은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공한다.

SOAP(Simple Object Access Protocol)은 HTTP 메시지에 XML 데이터를담는 방식에 관한 표준이다. 

# 5. 터널

HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다. 

HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.

웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서다.

따라서 웹 터널을 사용하면 웹 트래픽만을 허락하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다. 

## 5.1 CONNECT로 HTTP 터널 커넥션 맺기

CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다.

![image.png](attachment:3e25d4ad-5042-44d0-9f6b-725ca11295a5:image.png)

위 이미지는 SSL 터널링을 통해 HTTPS 요청을 클라이언트 ↔ 서버 간에 프록시를 거쳐 안전하게 전달하는 구조이다.

| 단계 | 설명 |
| --- | --- |
| a | 클라이언트가 프록시에 CONNECT 요청을 보냄 |
| b | 프록시가 실제 서버에 TCP 연결 시도 |
| c | 연결 성공 시 터널 생성 완료 |
| d | 클라이언트에 성공 메시지 전송 |
| e | 이후 암호화된 HTTPS 트래픽이 터널을 통해 전달됨 |

### CONNECT 요청

CONNECT 문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같다.

요청 URI는 호스트 명이 대신하며 콜론에 이어 포트를 기술한다. 

호스트와 포트는 다음과 같이 기술해야 한다.

![image.png](attachment:572220f3-af05-44c7-bb23-b60c31fdafe5:image.png)

시작줄 다음에는 다른 HTTP 메시지와 같이, 추가적인 HTTP 요청 헤더 필드가 있거나 없다.

보통 각 행은 CRLF로 끝나고, 헤더 목록의 끝은 빈 줄의 CRLF로 끝난다.

### CONNECT 응답

클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다린다.

일반 HTTP 메시지와 같이 200 응답 코드는 성공을 뜻한다.

편의상 응답에 있는 사유 구절은 ‘Connection Established’로 기술된다.

![image.png](attachment:e32cc0bc-24bf-48aa-b26d-3b8b5c987d00:image.png)

일반적인 HTTP 응답과는 달리 Content-Type 헤더를 포함할 필요는 없다.

커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문에 콘텐츠의 형식을 기술하는 Content-Type 헤더를 포함할 필요가 없다.

## 5.2 데이터 터널링, 시간, 커넥션 관리

터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없다.

터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.

터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달된다.

그 다음 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프락시에 의해서 끊어질 것이다.

커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려진다.

### 5.3 SSL 터널링

웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었다.

많은 회사가 더 강력한 보안을 위해 모든 트래픽이 패킷을 필터링하는 라우터와 프락시를 지나도록 하였으나, SSL 같이 암호화된 프로토콜은 정보가 암호화되어있어 낡은 방식의 프락시에서는 처리되지 않는다.

터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP 만을 허용하는 방화벽을 통과시킬 수 있다. 

![image.png](attachment:9b92f4a5-a4d4-49a6-85dd-9851fe2364de:image.png)

SSL 트래픽이 기존 프락시 방화벽을 통과할 수 있도록 HTTP에  터널링 기능이 추가되었다.

이 터널링 기능은 HTTP 메시지에 암호화된 날 데이터를 담고 있는 일반 HTTP 채널을 통해 데이터를 전송한다. 

터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다.

이는 보안 SSL 트래픽이 방화벽을 통과하는 데 유용하게 사용될 수 있다. 하지만 터널은 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있다. 

![image.png](attachment:e47539d4-383e-4afe-bd7f-647ca0c7a2cb:image.png)

## 5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

HTTP 프로토콜(SSL상의 HTTP)은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할 수 있다.

원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이(클라이언트 대신)를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식이다.

응답은 프록시가 받아서 복호화하고 난 후에, HTTP(보안이 좋지 않은)를 통해 클라이언트로 전송한다.

이는 게이트웨이가 FTP를 처리하는 방식과 같다.

하지만 이 접근은 몇 가지 단점이 있다.

- 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있다.
- 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없다.
- 게이트웨이는 SSL을 완벽히 지원해야 한다.
- 이 상황에서 SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없다.
- SSL 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버간에 생성된다.
- 프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링할 뿐이다.

## 5.5 터널 인증

HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다.

특히 프락시 인증 기능은,  클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.

![image.png](attachment:ec04f4f5-7eae-44b6-84ef-25adf3cfc923:image.png)

## 5.6 터널 보안에 대한 고려사항들

보통 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없다.

예를 들어 회사 방화벽에 터널을 생성하여 게임 트래픽을 사내로 유입시킬 수 있다.

터널의 오용을 최소화하기 위해서, 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 한다.

# 6. 릴레이

HTTP 릴레이는 HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프락시다.

릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달한다.

HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽을 전달하는 간단한 프락시를 구현하는 방식이 유용할 때가 있다.

데이터를 맹목적으로 전달하도록 구현하기는 쉽기 때문에, 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용되기도 하나, 잠재적으로 심각한 상호 운용 문제(예를 들어, Conection 헤더 제대로 처리 못함 이슈)를 가지고 있기 때문에 주의해서 배포해야 한다.
