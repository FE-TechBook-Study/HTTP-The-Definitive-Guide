# 8장. 통합점: 게이트웽, 터널, 릴레이

## 8.1 게이트웨이

### 게이트웨이가 고안된 배경

- 웹에 더 복잡한 리소스를 올려할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없음.
- 인터프리터 같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트웨이를 고안해 냄.

### 게이트웨이의 역할

- 리소스와 애플리케이션을 연결하는 역할
- 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고, 게이트웨이는 그에 응답한다. 게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작하는데, 동적인 콘텐트 생성/데이터 베이스 질의 등을 보낼 수 있다.
- HTTP 트래픽을 다른 프로토콜로 자동 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

- 웹 게이트웨이는 한쪽에서 HTTP, 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.
- 게이트웨이는 클라이언트 측, 서버 측 프로토콜을 빗금(/)으로 구분해 기술한다.
  `<클라이언트 프로토콜>/<서버 프로토콜>`
- 서버 측 게이트웨이는 클라이언트와 HTTP로 통신, 서버와는 외래 프로토콜로 통신한다.
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신, 서버와는 HTTP로 통신한다.

## 8.2 프로토콜 게이트웨이

브라우저에 명시적으로 게이트웨이를 설정하여 트래픽이 게이트웨이를 거쳐가게 하거나, 게이트웨이를 대리 서버(리버스 프록시)로 설정할 수 있다.

### 8.2.1 HTTP/\*: 서버 측 웹 게이트웨이

- 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.
- 예시
  - HTTP/FTP 인바운드 변환 게이트웨이 : 원 서버의 FTP 포트로 FTP 커넥션을 연결하고 FTP 프로토콜을 통해 객체를 가져온다. 객체를 받으면 HTTP 응답에 실어서 클라이언트에게 전송

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

- 모든 웹 요청을 암호화하여 개인 정보 보호와 보안을 제공하는 데 사용
- 클라이언트는 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화한다.

### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

- 보안 가속기로 유명
- 웹 서버의 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다.
- 이 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.
- 원 서버보다 더 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장하여 원 서버 부하를 감소
- 하지만 게이트웨이와 원 서버 간에 암호화하지 않은 트래픽을 전송하기 때문에 네트워크의 안전을 확실히 확인해야 한다.

## 8.3 리소스 게이트웨이

- 게이트웨이의 가장 일반적 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다.
- 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이이다.

  - 애플리케이션 서버는 API(Application Programming Interface)를 통해 클라이언트의 HTTP 요청을 서버에서 동작하고 있는 에플리케이션에게 전달

- 공용 게이트웨이 인터페이스 (CGI)
  - 최초의 API
  - 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합

### 8.3.1 공용 게이트웨이 인터페이스

- 최초의 서버 확장이자 지금까지도 널리 쓰이는 서버 확장
- 동적인 HTML, 신용카드 처리, DB 질의 등 제공
- 단순하기 때문에 거의 모든 HTTP 서버가 지원
- 사용자는 CGI가 내부에서 어떤 처리를 하는지 모르며, 알 수 있는 유일한 단서는 URL 내의 'cgi' 혹은 '?' 같은 것들
- CGI는 거의 모든 리소스 형식과 서버의 접점에 있으며 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공
- 이런 분리 때문에 성능 관련 비용 발생
  - 모든 CGI 요청마다 새로운 프로세스 생성에 따르는 부하
  - 서버의 성능 제한
- 성능 저하 대안으로 Fast CGI가 개발되었음.

### 8.3.2 서버 확장 API

- 웹 개발자가 서버의 모듈을 HTTP와 직접 연결할 수 있는 인터페이스
- 유명한 서버 대부분은 확장 API를 한 개 이상 제공

## 8.4 애플리케이션 인터페이스와 웹 서비스

- 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일은 까다로운 이슈 중 하나
- 웹 서비스 : 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합

## 8.5 터널

- 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공
- HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.
- 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위함.

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

- 웹 터널은 HTTP의 CONNECT 메서드를 사용해 커넥션을 맺는다.
- CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다.

#### CONNECT 요청

- 시작줄을 제외하고는 다른 HTTP 메서드와 동일하게 추가적인 헤더가 있거나 없다.
- 요청 URI는 호스트 명이 대신하며 콜론에 이어 포트를 기술
- 각 행은 CRLF로 끝나고, 헤더 목록의 끝은 빈 줄의 CRLF로 끝난다.

#### CONNECT 응답

- 200 응답 코드의 사유 구절은 'Connection Established'
- 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문에 Contect-Type 헤더를 포함할 필요는 없다.

### 8.5.2 데이터 터널림, 시간, 커넥션 관리

- 터널을 통하는 데이터는 게이트웨이에서 볼 수 없어서 게이트웨이는 패킷의 순서나 흐름에 대해 알 수 없다.

- 클라이언트는 성능 향상을 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전 터널 데이터를 전송한다.

  - 게이트웨이는 요청에 이어 데이터를 적절하게 처리할 수 있어야 함을 전제
  - 게이트웨이는 헤더를 포함해 읽어들인 모든 데이터를 서버에 전송해야 한다.

- 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 곳으로부터 온 데이터는 반대편으로 전달된다.
  - 그 다음 반대편의 커넥션도 프락시에 의해 끊어진다.
  - 아직 전송하지 않은 데이터는 버려진다.

### 8.5.3 SSL 터널링

- 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있다.
- 보안 SSL 트래픽이 방화벽을 통과하는 데 유용하게 사용되지만 악의적인 트래픽이 사내로 유입되는 경로가 될 수 있다.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

- HTTP/HTTPS 게이트웨이의 단점:

  - 클라이언트-게이트웨이 구간은 암호화되지 않음
  - 클라이언트가 최종 서버의 인증서를 검증할 수 없음

- SSL 터널링의 장점:

  - 클라이언트와 서버 간 종단간 보안 유지
  - 프록시에서 SSL 구현 불필요

### 8.5.5 터널 인증

- 프락시 인증 기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용

### 8.5.6 터널 보안에 대한 고려사항들

- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 X.
  - HTTPS 전용 포트 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 한다.

## 8.6 릴레이

- 릴레이의 특징

  - HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프록시
  - 복잡한 HTTP 처리 대신 단순하게 데이터만 전달
  - Connection 헤더 처리 등에서 문제가 발생할 수 있어 keep-alive 커넥션이 행(hang)에 걸림

- 주요 문제점:

  - HTTP 명세를 완전히 이해하지 못해 예상치 못한 동작 발생 가능
  - 특히 Connection 헤더 관련 처리에서 오류 발생

# 9장. 웹 로봇

- 연속된 웹 트랜잭션을 자동으로 수행하는 소프트웨어 프로그램

## 9.1 크롤러와 크롤링

#### 웹 크롤러의 개념

- 웹 크롤러는 먼저 웹페이지를 한 개 가져오고, 그 다음 그 페이지가 가리키는 모든 웹페이지를 가져오고, 다시 그 웹페이지들이 가리키는 모든 웹페이지들을 가져오는 식으로 재귀적으로 반복하는 방식으로 웹을 순회하는 로봇
- 웹 링크ㄹ 재귀적으로 따라가는 로봇을 크롤링 혹은 스파이더라고 부른다
- HTML 하이퍼링크들로 만들어진 웹을 따라 '기어다니기(crawl)' 때문이다.

### 9.1.1 어디에서 시작하는가: 루트 집합

- 크롤러가 방문할 URL들의 초기 집합을 루트 집합(root set)이라고 한다.
- 루트 집합 선택할 때 모든 링크를 크롤링하면 결과적으로 관심 있는 웹페이지 대부분을 가져오게 될 수 있도록 충분히 다른 장소에서 URL들을 선택해야 한다.

### 9.1.2 링크 추출과 상대 링크 정상화

크롤러는 웹을 돌아다니면서 꾸준히 HTML 문서를 검색한다.
크롤러는 검색한 각 페이지 안에 들어있는 URL 링크들을 파싱해서 크롤링할 페이지들의 목록에 추가해야 한다.

### 9.1.3 순환 피하기

로봇이 웹을 크롤링할 때, 루프나 순환에 빠지지 않도록 매우 조심해야 한다.

### 9.1.4 루프와 중복

#### 순환의 문제점

- 크롤러를 루프에 빠트려서 같은 페이지를 반복해서 가져오는데 네트워크 대역폭을 다 차지하게 될 수 있다.
- 크롤러의 반복적인 페이지 요청은 서버에 부담이 되어 사옹자의 접근을 막아버릴 수도 있다.
- 많은 수의 중복된 페이지를 가져오게 되어 중복된 콘텐츠가 넘쳐나게 될 것이다.

### 9.1.5 빵 부스러기의 흔적

수십억 개의 URL 중 어떤 URL을 방문하였는지 빠르게 판단하기 위해서는 복잡한 자료 구조를 사용할 필요가 있다.

#### 트리와 해시 테이블

복잡한 로봇이라면 검색 트리가 해시 테이블을 사용했을 수도 있다.

#### 느슨한 존재 비트맵

- 공간 사용을 최소화하기 위해, 존재 비트 배열과 같은 느슨한 자료 구조를 사용
  - 각 URL은 해시 함수에 의해 고정된 크기의 숫자로 변환되고 배열 안에 대응하는 '존재 비트'를 갖는다.
  - URL이 크롤링 되었을 때, 해당하는 존재 비트가 만들어진다.
  - 만약 존재 비트가 이미 존재한다면, 크롤러는 그 URL을 이미 크롤링 되었다고 간주
