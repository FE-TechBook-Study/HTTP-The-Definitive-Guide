# 4장. 커넥션 관리

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

## 4.1 TCP 커넥션

모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.  
클라이언트와 서버간 커넥션이 맺어지면 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다. TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

TCP는 IP 패킷(혹은 IP 데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송한다.  
HTTP는 'IP, TCP, HTTP'로 구성된 '프로토콜 스택'에서 최상위 계층이다.

HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해 메시지 데이터의 내용을 순서대로 보낸다.  
TCP는 세그먼트 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아 전달한다.
각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.

각 IP 패킷은 다음을 포함한다.

- IP 패킷 헤더
  - 발신지와 목적지 IP 주소, 크기, 기타 플래그
- TCP 세그먼트 헤더
  - TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값
- TCP 데이터 조각

### 4.1.3 TCP 커넥션 유지하기

컴퓨터가 갖고 있는 여러 개의 TCP는 포트 번호를 통해 커넥션을 유지한다.

TCP 커넥션은 아래 네 가지 값으로 유일한 커넥션을 생성하여 식별한다. 서로 다른 두 개의 TCP 커넥션은 네 가지 주요 구성요소의 값이 모두 같을 수 없다.

> <발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>

### 4.1.4 TCP 소켓 프로그래밍

소켓 API는 HTTP 프로그래머에게 TCP와 IP의 세부사항들을 숨긴다. 소켓 API는 유닉스 운영체제용으로 먼저 개발되었지만, 지금은 대부분의 운영체제와 프로그램 언어에서 이를 사용할 수 있게 되었다.

소켓 API를 사용하면, TCP 종단(endpoint) 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.  
TCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.

#### 클라이언트와 서버 TCP 소켓 인터페이스를 사용하여 상호작용하는 방법

클라이언트 측

- **(C1)** IP 주소와 포트를 얻다
- **(C2)** 새로운 소켓을 생성한다(socket)
- **(C3)** 서버의 IP:포트로 연결한다(connect)
- **(C4)** 성공적으로 연결
- **(C5)** HTTP 요청을 보낸다(write)
- **(C6)** HTTP 응답을 기다린다(read)
- **(C7)** HTTP 응답을 처리한다
- **(C8)** 커넥션을 닫는다(close)

서버 측

- **(S1)** 새로운 소켓을 만든다(socket)
- **(S2)** 80 포트로 소켓을 묶다
- **(S3)** 소켓 커넥션을 허가한다(listen)
- **(S4)** 커넥션을 기다린다(accept)
- **(S5)** 애플리케이션 커넥션 동치
- **(S6)** 요청을 읽기 시작한다(read)
- **(S7)** HTTP 요청 메시지를 처리한다
- **(S8)** HTTP 응답을 보낸다(write)
- **(S9)** 커넥션을 닫는다(close)

설명

1. S4 : 웹 서버는 커넥션을 기다리기 시작한다.
2. C3 : 클라이언트는 URL에서 IP 주소와 포트 번호를 알아내고 서버에 TCP 커넥션을 생성하기 시작한다. 커넥션 생성은 서버와의 거리, 서버의 부하, 인터넷 혼잡도에 따라서 시간이 걸린다.
3. C5 : 일단 커넥션이 맺어지면 클라는 HTTP 요청을 보내고
4. S6 : 서버는 그것을 읽는다.
5. S7,S8 : 서버가 요청 메시지를 다 받으면, 그 요청을 분석하여 클라가 원하는 동작을 수행하고 클라에게 데이터를 보낸다.
6. C6,C7 : 클라는 그것을 받아 응답 데이터를 처리한다.

## 4.2 TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.  
TCP 성능의 특성을 이해하고, HTTP의 커넥션 최적화 요소들을 알고 더 좋은 성능의 HTTP 애플리케이션을 설계 및 구현할 수 있다.

### 4.2.1 HTTP 트랜잭션 지연

트랜잭션을 처리하는 시간은 TCP 커넥션을 설정하고, 요청을 전송하고, 응답 메시지를 보내는 것에 비하면 상당히 짧다. 클라이언트나 서버가 너무 많은 데이터를 내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한, 대부분의 HTTP 지연은 **TCP 네트워크 지연** 때문에 발생한다.

#### HTTP 트랜잭션을 지연시키는 원인들

1. URI 호스트에 방문한 적이 없으면, 클라이언트가 DNS 인프라를 사용하여 호스트명을 IP 주소로 변환하는데 수십 초의 시간이 걸릴 것이다. 그러나 인프라의 발전으로 현재는 대부분 밀리초 단위로 끝난다.
2. 커넥션 설정 시간은 새로운 TCP 커넥션에서 항상 발생한다. 이는 보통 1~2초의 시간이 소요되지만(이 역시도 현재는 대부분 1초 미만으로 끝난다.), 수백 개의 HTTP 트랜잭션이 만들어지면 소요시간은 크게 증가할 것이다.
3. 커넥션이 맺어지고 요청 메시지가 TCP 파이프라인을 통해 전달되고 서버에 의해 처리되는 데 까지는 시간이 요소된다.
4. 웹 서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.

### 4.2.2 성능 관련 중요 요소

HTTP 프로그래머에게 영향을 주는 가장 일반적인 TCP 관련 지연들

- TCP 커넥션의 핸드셰이크 설정
- 인터넷 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback) 확인응답(acknowledgement)을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

새로운 TCP 커넥션을 열 때면, TCP는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환한다.

#### 핸드셰이크 순서

1. 클라이언트는 새로운 TCP 커넥션을 생성을 요청하기 위해 서버에 'SYN' 플래그를 가진 패킷(40~60바이트)을 보낸다.
2. 서버는 그 커넥션을 받고 요청이 받아들여졌음을 의미하는 'SYN'과 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다.
3. 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 'ACK' 확인응답 신호를 보낸다.

HTTP 트랜잭션이 아주 큰 데이터를 주고받지 않는 경우에는, SYN/SYN+ACK 커넥션 핸드셰이크가 눈에 띄는 지연을 발생시킨다. TCP의 ACK 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 큰 경우가 많고, 많은 HTTP 서버 응답 메시지는 하나의 IP 패킷에도 담길 수 있다.  
결국, 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP로 구성하는 데 쓴다.

### 4.2.4 확인응답 지연

인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 떼문에 TCP는 성공적인 데이터 전송을 보장하기 위해 자체적인 확인 체계를 가진다.
각 TCP 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환하는데 만약 송신자가 이를 받지 못하면 패킷에 문제가 있는 것으로 판단하고 데이터를 다시 전송한다.

#### 장점

확인응답은 크기가 작기 때문에, TCP는 같은 방향으로 송출되는 패킷에 확인응답을 편승시켜 효율적으로 사용한다. 편승 기회를 늘리기 위해 '확인응답 지연' 알고리즘을 구현한다.  
확인응답 지연은 송출할 확인응답을 특정 시간 동안(보통 100ms ~ 200ms) 버퍼에 저장하고, 편승시키기 위한 송출 데이터 패킷을 찾는다. 만약 찾지 못하면 별도 패킷을 만들어 전송된다.

#### 단점

요청-응답 패턴에서 막상 편승할 패킷을 찾으려고 하면 편승할 데이터가 없어 불필요한 지연이 생긴다.

### 4.2.5 TCP 느린 시작(slow start)

TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진지 얼마나 지났는지에 따라 달라진다.  
TCP 커넥션은 부하와 혼잡 제어를 위해 초기에는 최대 속도를 제한하고, 점진적으로 높여나간다. 이렇게 조율하는 것을 TCP 느린 시작이라고 부른다.

> 초기: 1개 패킷 → 확인응답 받으면 → 2개 패킷 → 4개 패킷 → 8개 패킷...
> &ensp;&ensp;&ensp;&ensp;&ensp;(지수적 증가 패턴)

이 혼잡제어 기능 때문에 새로운 연결마다 느린 시작 단계를 거쳐야한다. HTTP에는 이미 존재하는 커넥션을 재사용하는 기능이 있다.

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

네이글 알고리즘은 작은 크기의 패킷을 모아서 큰 패킷으로 합쳐서 전송하여 네트워크 효율성을 증대시킨다.  
이 알고리즘은 HTTP 성능에 문제를 발생시킨다.

- 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에 추가적인 데이터를 기다리며 불필요한 지연이 발생한다.
- 확인응답 지연 + 네이글 알고리즘을 함께 쓰일 경우, 네이글 알고리즘은 확인응답이 도착할 때 까지 기다리고있고 확인응답 지연 알고리즘은 확인응답을 100ms ~ 200ms 지연시켜 성능이 저하된다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

TCP 커넥션을 끊으면, IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓는다. 이는 같은 주소와 포트를 사용하는 새로운 TCP 커넥션이 세그먼트의 최대 생명주기에 두 배 정도('2MSL', 보통 2분) 동안에 생성되지 않도록 막아준다.

클라이언트가 서버에 접속할 때마다, 새로운 발신지 포트를 쓴다. 사용할 수 있는 포트의 수는 제한되어 있고 (약 60000개 가정) 2MSL초 동안(120초로 가정) 커넥션이 재사용될 수 없으므로, 초당 500개로 커넥션 생성시 사용 가능한 포트가 TIME_WAIT 상태로 인해 고갈된다.

문제 해결을 위해 부하 생성 장비를 더 많이 사용하거나 가상 IP 사용으로 포트 풀을 확장할 수 있다.

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

Connection 헤더는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 다른 커넥션에 전달되지 않는다. 다음 세 가지 종류의 토큰이 전달될 수 있다.

- HTTP 헤더 필드 명은, 이 커넥션에만 해당되는 헤더들을 나열한다.
- 임시 토큰값은, 커넥션에 대한 비표준 옵션을 의미한다.
- close 값은, 커넥션이 작업 완료 후 종료되어야 함을 의미한다.

홉별(hop-by-hop)헤더를 명시할 수 있는데 이것은 특정 두 서버 간에 영향을 미치고 다른 서버 간에는 영향을 미치지 않는 것을 의미한다.

> Connection : meter, close, bill-my-credit-card
>
> Meter, bill-my-credit-card 헤더를 다른 커넥션으로 전달하면 안되고 이 트랜잭션이 끝나면 커넥션이 끊길 것이라고 말한다.

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

클라이언트가 여러 개의 트랜잭션을 하나씩 순서대로 처리한다면 각 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생해 네트워크 지연 시간이 누적될 것이다.

이러한 HTTP 커넥션의 성능을 향상시킬 수 있는 기술을 알아보자.

- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션

## 4.4 병렬 커넥션

여러 개의 TCP 커넥션을 동시에 생성하여 병렬로 처리한다.

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

단일 커넥션의 대역폭 제한(동시에 전송할 수 있는 데이터의 최대 속도)과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹페이지를 더 빠르게 내려받을 수 있을 것이다. 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.

각 트랜잭션은 별도의 커넥션에서 동시에 처리되며 병렬로 내려받으면 커넥션 지연이 겹쳐짐으로써 총 지연시간이 줄어든다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

클라이언트의 인터넷 대역폭이 좁은 경우 각 객체를 병렬로 내려받는 것은 성능상의 장점은 거의 없어진다.  
또한 다수의 커넥션은 메모리를 많이 소모하고 서버에 부하가 발생할 수 있다.

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

병렬 커넥션이 실제로 페이지를 항상 더 빠르게 로드하지는 않지만, 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있다.

## 4.5 지속 커넥션

웹 클라이언트가 같은 사이트에 여러 개의 커넥션을 맺고 지속적으로 요청하는 속성을 사이트 지역성(site locality)라고 부른다.  
HTTP/1.1 을 지원하는 기기는 작업 완료 후 TCP 커넥션을 유지하여 재사용할 수 있다. 이를 지속 커넥션이라고 부른다. 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지한다.  
지속 커넥션을 재사용함으로써, 커넥션을 맺기 위한 준비작업에 따르는 시간을 절약할 수 있다. 또한 느린 시작으로 인한 지연을 피함으로써 더 빠르게 데이터를 전송할 수 있다.

### 4.5.1 지속 커넥션 vs 병렬 커넥션

#### 병렬 커넥션의 단점

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭 소모
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어짐
- 실제 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.

#### 지속 커넥션의 장점

- 커넥션 설정/해제 오버헤드 제거
- TCP 느린 시작 단계 반복 방지
- 서버 리소스 절약

지속 커넥션 + 병렬 커넥션을 함께 사용하는 것이 효과적이다. 많은 애플리케이션이 적은 수의 병렬 커넥션을 맺고 그것을 유지한다.  
두 가지 지속 커넥션 타입이 있다.

- HTTP/1.0+ : 'keep-alive' 커넥션
- HTTP/1.1 : '지속' 커넥션

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

HTTP/1.0의 keep-alive 커넥션이라는 지속 커넥션을 지원하기 위한 실험적 확장.  
커넥션을 맺고 끊는 데 필요한 작업이 없어서 시간을 단축할 수 있다.  
keep-alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에서는 빠졌다. 하지만 아직도 keep-alive 핸드셰이크가 널리 사용되고 있기 때문에 동작방식을 알 필요가 있다.

### 4.5.3 Keep-Alive 동작

HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 요청에 `Connection: Kepp-Alive` 헤더를 포함시켜야 한다. 이 요청을 받은 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함시켜 응답한다. 응답에 이 헤더가 없으면, 클라이언트는 서버가 응답 메시지 전송 후 서버 커넥션을 끊을 것이라고 추정한다.

### 4.5.4 Keep-Alive 옵션

Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐 언제든지 끊을 수 있으며 처리되는 트랜잭션의 수를 제한할 수도 있다. 쉼표로 구분된 옵션들로 제어할 수 있다.

- `timeout` : 커넥션 유지 시간 (초)
- `max` : 최대 트랜잭션 수

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- Content-Length 필수 : 메세지 경계 구분을 위해
- 프록시와 게이트웨이 : 메시지 전달 및 캐시에 넣기 전에 Connection 헤더를 제거
- 멍청한 프록시 문제 : Keep-Alive를 인식하지 못하는 중간 프록시

### 4.5.6 Keep-Alive와 멍청한 프락시

문제 상황:

```
클라이언트 -> [멍청한 프록시] -> 서버

1. 클라이언트: Connection: Keep-Alive 전송
2. 프록시: 헤더를 이해 못하고 그대로 서버에 전달(Connection 헤더는 홉별 헤더이므로 다음 서버로 전달되면 안된다.)
3. 서버: Keep-Alive로 응답.
4. 프록시: 응답을 그대로 클라이언트에 전달 but, keep-alive를 이해하지 못하고 서버가 커넥션을 끊기를 기다린다.
5. 서버는 프락시가 커넥션 유지를 요청한 것으로 알고 커넥션을 끊지 않는다.
6. 클라이언트가 응답 메시지를 받고 다음 요청을 보내는데, 프락시는 같은 커넥션상에서 다른 요청이 오는 경우는 예상하지 못하고 무시된다.
7. 결과 : 양쪽 다 Keep-Alive로 오해하며 무한대기하다가 타임아웃
```

프락시는 Connection 헤더와 Connection 헤더에 명시된 홉별 헤더들은 절대 전달하면 안된다.

### 4.5.7 Proxy-Connection 살펴보기

클라이언트의 요청이 프록시 등을 통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 Proxy-Connection 확장 헤더를 프락시에게 전달한다. 만약 이게 그대로 서버에 전달되더라도 Connection 헤더가 없기 때문에 keep-alive 커넥션이 맺어지지 않는다. 영리한 프록시는 Proxy-Connection이 keep-alive 요청하는 것임을 인식하여, 자체적으로 `Connection: Keep-Alive` 헤더를 웹 서버에 전송한다.

동작 과정:

```
클라이언트 → 영리한 프록시 → 서버

1. 클라이언트: Proxy-Connection: Keep-Alive
2. 영리한 프록시: Connection: Keep-Alive로 변환하여 서버에 전송
3. 정상적인 Keep-Alive 동작
```

### 4.5.8 HTTP/1.1의 지속 커넥션

HTTP/1.1에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 기본적으로 지원한다. 목적은 keep-alive 커넥션과 동일하다.  
트랜잭션이 끝난 다음 커넥션을 끊으려면 `Connection: close`를 명시해야 한다. 이게 없으면 응답 후에도 커넥션을 계속 유지하는 것으로 추정하지만 언제든 커넥션을 끊을수는 있다.

## 4.6 파이프라인 커넥션

요청을 순서대로 보내되, 응답을 기다리지 않고 다음 요청을 연속해서 보낸다.

#### 제약사항

- 지속 커넥션인지 확인 전까지는 파이프라인을 이어서는 안된다.
- 요청 순서대로 응답 순서가 보장되어야 한다.
- HEAD, GET 등 안전한 메서드에만 사용을 권장한다.

## 4.7 커넥션 끊기에 대한 미스터리

### 4.7.1 '마음대로' 커넥션 끊기

언제든 커넥션이 끊어질 수 있는 상황:

- 네트워크 장애
- 서버/클라이언트 종료
- 방화벽 정책
- 타임아웃

### 4.7.2 Content-Length와 Tuncation

각 HTTP 응답은 본문의 정확한 크기를 가지는 Content-Length 헤더를 가지고 있어야 한다. Content-Length 없이 커넥션을 종료하면 데이터 손실 감지가 어려울 수 있다.

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

커넥션은 에러가 없더라도 언제든 끊을 수 있다. 어떤 요청이 전송되었지만, 응답이 오기 전에 커넥션이 끊어지면 클라이언트는 실제로 서버에서 얼마만큼 요청이 처리되었는지 전혀 알 수 없다. 특히 POST 요청들은 중복은 피해야 한다.

한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(idempotent)하다고 한다.

#### 재시도 규칙

멱등성을 고려하여 같은 요청을 여러 번 해도 안전한지 확인해야 한다.

- 멱등 : GET, HEAD, PUT, DELETE, TRACE, OPTIONS - 자동 재시도 가능
- 비멱등 : POST - 재시도 신중히 판단

### 4.7.4 우아한 커넥션 끊기

#### 전체 끊기와 절반 끊기

- `close()` : TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다.
- `shutdown()` : 입력 또는 출력 중 하나를 개별적으로 끊기

#### TCP 끊기와 리셋 에러

절반 끊기는 출력 채널을 끊는 것이 안전하다.  
만약 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면 운영체제는 TCP 'connection reset by peer' 에러를 보낸다. 이것을 심각한 에러로 취급하여 버퍼에 저장된, 아직 읽히지 않은 데이터를 모두 삭제시킨다.

#### 우아하게 커넥션 끊기

1. 출력 채널을 먼저 종료 : 더 이상 데이터 전송 안함
2. 입력 채널 확인 : 상대방 데이터 수신 완료 대기
3. 완전 종료 : 소켓 종료
