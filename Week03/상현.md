# 상현
## 4.0 이번 장 요약

1. 클라이언트는 DNS를 통해 서버의 IP 주소를 알아낸다.
2. 클라이언트는 소켓(socket)을 생성한다.
3. 클라이언트는 connect()를 호출해 서버의 IP/Port로 연결을 시도한다.
    1. 이 때 connect()를할 때 클라이언트 OS가 자동적으로 IP와 Port number가 정해지고 binding된다
4. TCP 내부에서 3-way handshake가 진행되고 성공하면 연결이 수립된다.
5. TCP 연결이 되면 클라이언트는 데이터를 분할한다.
6. TCP는 세그먼트 단위로 데이터를 전송하며, 네이글 알고리즘을 통해 작은 데이터들을 하나의 세그먼트로 묶을지 결정한다
7. 각 세그먼트는 IP 패킷에 담겨 서버로 전달된다.
    1. 초기 전달 시에는 느린시작으로 세그먼트 수가 제한된다. 이후 2의 배수로 늘어난다. (1 → 2 → 4 → 8)
8. TCP에 대한  확인응답이 클라이언트로 온다
    1. 확인응답은 작은 데이터이기에 보통 클라이언트 단으로 돌아오는 것에 "편승"하여 온다. 그러나 "편승"할 것이 없으면 따로 만들어져서 보내진다.
9.  커넥션을 우아하게 끊기 위해선 출력 스트림을 먼저 끊고, 입력 스트림이 닫히기를 기다려야 한다.
그렇지 않으면 `connection reset by peer` 에러가 발생할 수 있다.
10. TCP는 커넥션을 닫은 후 일정 시간 동안 TIME_WAIT 상태로 남아있으며,이 기간 동안 포트 번호 재사용이 제한된다. 이는 이전 패킷이 새 커넥션에 섞이는 것을 방지하기 위함이다.

> Chrome AI:
> 
> 
> Chrome Developer Tools Network tab **primarily focuses on the application layer**, specifically the HTTP/HTTPS protocol. It shows you the details of the HTTP request and response as a whole – the headers, the body, the status code, and the timing of the different phases of the HTTP transaction (like sending the request and waiting for the response).
> 
> **It does not show you the details of the lower-level network layers**
> 

## 4.1 TCP(Transmission Control Protocol) 커넥션

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

HTTP는 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과
TCP 커넥션은 한 쪽에 있는 바이트들을 반대쪽으로 순서에 맞게 정확히 전달
(GET index → xedni TEG)

### 4.1.2 (GPT 활용)TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송

![스크린샷 2025-06-24 오후 3.26.11.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2Fe67c0858-afd8-4ebe-8a69-9d6f81d5e6b9%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-06-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.26.11.png/size/w=1920?exp=1751254182&sig=6sqa8kpPZuPYhH6ms0lqJOY4keUcuBOxM4n72OTCFI0&id=21c438a5-b001-806f-a98b-f0bcff625be1&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

1. 요청의 payload 또는 entity는 세그먼트 단위로 분해
2. 세그먼트는 IP pakcet에 담김
    1. IP Pakcet은
        1. IP packet header: IP 주소, 크기, 기타 플래그
        2. TCP 세그먼트 헤더: TCP 포트 번호, TCP 제어 플래그, 데이터 순서와 무결성 검사를 위한 숫자 값
        3. TCP 데이터 조각

### 4.1.3 TCP 커넥션 유지하기

TCP는 다음 네 가지 값으로 식별: `<발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>` 
TCP 연결 사이에서 일부 구성요서는 동일할 수 있지만 모든 값이 동일한 경우는 절대 없다

### 4.1.4 (GPT활용)TCP 소켓 프로그래밍

소켓 API는 복잡한 내부를 추상화해서 세부사항을 숨기고 필요한 인터페이스를 표출.
클리언트의 TCP 소켓과 서버의 TCP 소켓이 만들어지면 서로 통신 가능

여기서 소켓(socket)이란?

- 정의: IP주소 + 포트번호를 추상화 한 객체
- 역할: TCP 연결의 endpoint로 들어오는 신호를 처리하는 객체
- IP/Port와 다른건? IP/Port는 주소이고 주소를 들어오면 내부에서 외부 신호를 받아주는 socket이 있는 형태

## 4.2 TCP의 성능에 대한 고려

HTTP는 TCP바로 위에 있는 계층이기에, TCP 성능에 영향 받음.
TCP 커넥션 성능에 대해서 알아보는 단계

### 4.2.1 HTTP 트랜잭션 지연

DNS lookup부터 응답 반환까지 모든 것은 인터넷 요청이다. 각 부분에 병목이 있으면 결국 HTTP 트랜잭션의 소요시간은 늘어난다

(예)

- DNS lookup 당시 조회되지 않은 URI라면 DNS lookup 완료까지 시간 소요
- 다수의 TCP요청이 맺어지면 처리 병목
- HTTP 요청부터 응답까지의 기간 소요

### 4.2.2 성능 관련 중요 요소

아래 항목들은 고성능의 HTTP 소프트웨어를 개발하고 있다면 모두 이해. 아니라면 “SKIP”

- TCP 케넥셔의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(Nagle) 알고리즘
- TCP의 편승 확인응답을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 요청의 값이 작든 크든 TCP/IP 연결 발생.
- 요청 데이터가 작을수록 전송은 빠르지만, 연결 설정에 드는 시간(RTT)는 일정하게 존재
- 이로 인해 전체 트랜잭션에서 연결 성립 시간이 상대적으로 커 보이고, 경우에 따라 총 지연 시간의 절반 이상을 차지 가능

### 4.2.4 확인응답 지연

각 TCP 세그컨트는 순번과 데이터 무결성 체크섬을 가짐. 
각 세그먼트가 수신되면 송신자에거 확인응답 패킷을 반환. 만약 확인응답을 받지 못하면 송신자는 데이터를 다시 전송.

이 확인응답 지연은 크기가 작기에 송출되는 데이터 패킷에 확인응답을 “편승”. 또한, TCP 송출 하나에 편승되는 경우를 늘리기 위해서 “확인응답 지연”알고리즘을 통해서 한번에 뭉쳐서 보냄. 
그러나 만약 편승시키기 위한 데이터가 없으면 별도로 만들어서 전송

### 4.2.5 TCP 느린 시작(slow start)

TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진지 얼마나 지났는지에 따라 달라짐.

느린시작: 처음에는 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한 상승. 

- 급작스러운 부하와 혼잡을 방지하는 데 사용
- 속도가 빨라지는 이유(혼잡 윈도를 연다, opening the congestion window): 한 개가 성공적이면, 2개를 보내고, 2개가 성공적이면 4개를, 4개가 성공적이면 8개로 “2의 배수”로 패킷의 전달 갯수가 증가

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

네이글 알고리즘: 네트워크 효율을 위해 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한  개의 덩어리로 묶음

- 세그먼트가 최대 크기가 되지 않으면 전송하지 않음
- 문제점 가능:
    - 크기를 전부 채우지 않았기에 세그먼트 생성 지연 → 패킷 전송 지연
    - 확인 지연으로 인한 양쪽(서버, 클라이언트) 지연
        
        ```scheme
        1. 브라우저가 작은 데이터를 write() 함 → 네이글 알고리즘이 바로 전송 안 함
        2. 첫 세그먼트를 보내고 ACK 기다림
        3. 서버는 받은 후 바로 ACK 안 보내고 "다음 데이터 기다려보자" (Delayed ACK)
        4. 그런데 브라우저는 ACK 없으면 다음 데이터 못 보냄 (네이글 때문)
        → 서로 기다림 → 지연 발생
        ```
        
        - `TCP_NODELAY`값을 설정하여 지연을 막을 수 있다. Front에서 설정은 못하고 Back에서 설정

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

TCP 연결이 끊기면 커넥션의 IP주소와 포트 번호를 기억.
이 정보를 토대로 같은 영역에 TCP 커넥션이 일정 시간 동안 생성되지 않게 함. 
왜냐하면 이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지할 수 있기 때문에. 간단하게 하면, 이전 커넥션 내용이 새로운 커넥션으로 가는 현상을 방지하기 위해.

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

> **RFC 7230 6.1 Connection**
> 

이 헤더에는 세 가지 종류의 토큰 사용

- HTTP 헤더 필드 이름: 지금 커넥션(현재 요청)에서만 사용하고 그 다음 다른 곳에 넘길 때는 사용하지 않을 값을 의미
    
    ```scheme
    Connection: Upgrade
    Upgrade: websocket
    ```
    
    - 이건 **웹소켓 업그레이드를 지금 이 커넥션에서만 하자**는 의미
    - 그리고 이 `Upgrade` 헤더는 **프락시 같은 중개 서버를 통과할 때는 삭제**
- 임시토큰: 비표준 값 전달. 서로 약속한 특정 값
- `close`: 현재 통신이 완료되면 커넥션 종료를 의미

이 Connection 헤더는 hop-by-hop. 즉, 중간 프록시같은 게 있으면 이 헤더는 끝까지 전달되지 않음

- 위 `Connection: Upgrade`상황과 동일

### 4.3.2 순차적인 트래잭션 처리에 의한 지연

커넥션 관리자 되지 않아서 순차적 처리가 된다면 리소스 로드의 병목 발생
향상시키기 위해 다음 네 가지 방법

- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션

## 4.4 병렬 커넥션

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

단일 커넥션이 아닌 병렬 커넥션을 통해서 리소스를 병렬로 다운로드

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

일반적으로 빠르지만 클라이언트의 네트워크 대역폭이 좁을 때는 느릴 수 있다.

- 초당 보낼 수 있는데 데이터 양이 적기에 데이터 전송받는 데이터는 느릴 수 있다
- 다수의 커넥션은 메모리를 많이 소모하기에 성능 문제 발생 가능. 또한 서버가 허용하는 커넥션 개수 제한 가능

### 4.4.3 병렬 커넥션은 더 빠르게 “느껴질 수”있다

페이지 총 다운로드 시간이 더 걸리더라도 화면 전체에서 여러 작업이 일어나는 것을 눈으로 확인할 수 있다면 빠르다고 착각

## 4.5 지속 커넥션

HTTP 1.1에서 TCP 커넥션을 유지하여 재사용할 수 있는 옵션 생성. 이를 통해 커넥션을 맺기 위한 준비시간 절약 가능

### 4.5.1 지속 커넥션 vs 병렬 커넥션

지속 커넥션을 계속 유지하면 리소스 낭비.
병렬 커넥션은 계속 끊고 연결을 반복하여 시간 지연 가능성.

현대 웹사이트는 둘 다 사용하는 것으로 각자의 장접 사용:

- 튜닝된 커넥션 사용: 오고가는 패킷의 수가 늘어난 상태
- 다중 요청 동시 가능

HTTP 1.0은 ‘keep-alive’, HTTP 1.1은 ‘지속 커넥션’

### 4.5.2 HTTP 1.0의 Keep-Alive 커넥션

초기 HTTP 1.0부터 Keep-Alive 커넥션을 만들어 트렌제셕을 유지하는 노력 존재.

### 4.5.3 Keep-Alive 동작

HTTP 1.1에서 keep-alive는 명서에서 빠졌지만 아직 널리 사용중.
`Connection: Keep-Alive` 헤더를 포함시켜 요청. 서버 또한 `Connection: Keep-Alive`헤더를 반환하며 없으면 클라이언트는 커넥션을 끊을 것이라 추측

### 4.5.4 Keep-Alive 옵션

```scheme
Keep-Alive: <옵션들>,<옵션들>

// 실제 예시
Connection: Keep-Alive
Keep-Alive: timeout=5, max=100
```

- 쉽표로 옵션들 구분
- timeout은 커넥션이 얼마간 유지될 것인지 의미
- max는 몇 개의 HTTP 트랜재션을 처리할 때까지 유지될 것인지 의미
- 진단이나 디버깅용 속성을 위해 <옵션=[값]> 형태 사용 가능. 무시되거나 참고 정보로만 사용

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

음……굳이

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

![스크린샷 2025-06-26 오후 4.08.34.png](https://img.notionusercontent.com/s3/prod-files-secure%2F6eac9da7-a6e6-4d98-84db-37a4eaddb1d5%2F53cb1465-43dc-424f-9d2e-6254c3b99787%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-06-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.08.34.png/size/w=1920?exp=1751254301&sig=pX-07Kctzc0UfjwDzJhw0z927vedZ3p85l9KUoWLrNU&id=21e438a5-b001-800a-a0c9-c9cb95436265&table=block&userId=fa8dc9c2-7ea8-437a-8bc2-3fbca5c283fb)

멍청한 프락시: Connection 헤더를 인식 못 하고 전부 전달만 하는 프락시
**Connection을 이해하지 못 하기에 Keep-Alive** 또한 이해하지 못하여 TCP 하나당 하나의 요청 및 하나의 응답으로 생각해 클라이언트의 **두 번째 요청을 무시함**

### 4.5.7 Proxy-Connection 살펴보기

멍청한 프락시를 해결하기 위해 확장헤더인 Proxy-Connection을 사용하여 멍청한 프락시가 그대로 보내도 keep-alive 커넥션 발동 X

영리한 프락시는 Proxy-Connection을 해석하여 클라이언트 ↔ Proxy간의 `Connection: Keep-Alive`를 유지. Proxy ↔ 서버간의 Connection은 연결 선택사항

그러나 위 방법은 프락시가 하나만 있는 상황이거나, 2개 이상의 프락시가 있는데 둘다 동일하게 멍청하거나 영리하다면 동작 가능.

### 4.5.8 HTTP 1.1 지속 커넥션

keep-alive 커넥션이 아닌 지속 커넥션으로 대체되었으며 모든 커넥션에 자동 취급.
만약 커넥션을 끊으려면 `Connection: close`명시 필요

### 4.5.9 지속 커넥션의 제한과 규칙

….굳이?

## 4.6 파이프라인 커넥션

HTTP 1.1 지속 커넥션을 통해서 요청을 파이프라닝 가능. 
요청이 서버로 도착을 하면 다음 요청도 보내는 방식

그러나 여러 가지 제약 사항이 존재:

- 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라이닝 불가
- 응답은 요청 순서와 같게 와야함
    - HTTP 1.1 메세지는 ID값이 없어서 순서를 지켜야 어떤 요청의 응답인지 파악 가능
    - HTTP2에는 각 요청마다 ID값을 붙임
- 요청 중간에  끊기면 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청 보낼 준비 필요
- 비멱등성인 요청을 파이프라인에 보내면 안 됨.
    - 에러가 발생을 했는데 서버에서 처리가 되었는 지 알 수 없음

## 4.7 커넥션 끊기에 대한 미스터리

언제 어떻게 끊는가에 대한 명확한 기준이 없다.

### 4.7.1 ‘마음대로’커넥션 끊기

보통 메세지를 다 보낸 다음에 끊지만 에러가 있는 상황에서는 어떻게 끊을 지 서버는 모른다.
일정시간 동안 요청이 없는 없는 유휴 상태라면 끊을 수 있다.
그러나, 서버가 끊을 때 클라이언트가 데이터를 전송하지 않을 것이라고 확신하지 못한다.

### 4.7.2 Content-Length와 Truncation

Content-Length는 “이 메세지늬 바디는 정확히 이만큼”이라는 표현하는 정보.
끊어짐 신호를 감지하면 전달된 엔티티의 길이와 Content-Length의 값이 일치하거나 Content-Length 자체가 없다면 수신자는 데이터가 완전한지 알 수 없다.

- 위 경우 프락시가 위 정보를 캐시해서 잘 못 된정보를 주면 안되기에 캐시 X
- 서버에게 체크 필요

| 항목 | 설명 |
| --- | --- |
| 무슨 내용? | 서버가 Content-Length 없이 커넥션 종료로만 응답 끝냄 → HTTP적으로 위험 |
| 왜 문제? | 응답 길이를 모르면 파싱 실패, 캐시 문제, UX 오류 발생 가능 |
| 누구 책임? | 서버는 정확한 Content-Length 보내야 하고, 프락시는 수정하지 말고 전달만 해야 함 |
| 어투는 왜 그런가? | 어느 정도 HTTP/TCP 구조를 아는 독자 대상으로 간결하게 기술함 |

### 4.7.3 커넨션 끊기의 허용, 재시도, 멱등성

커넥션은 에러가 없어도 언제든지 끊어질 수 있다. 그래서 클라이언트는 커넥션 종료에 항상 대비해야 한다
멱등성이 있는 요청들은 끊어지고 재요청되더라도 문제가 없다. 

그러나, 비멱등성 요청들이 끊긴다면 이전 요청에 대한 응답을 받을 때까지 기다려야 한다.
또는, 자동으로 재시도가 되더라도 재요청을 보내기 원하는지 대화상자를 표현해야 한다.

### 4.7.4 우아한 커넥션 끊기

HTTP 명세에 “우아하게 커넥션을 끊어야 한다”라고 기재만 되어있을 뿐 그 방법을 기재 X.
일반적으로 우아한 커넥션 끊기는 “애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것”

이미 커넥션이 끊긴 채널에 데이터를 전송하면 운영체제는 “connection reset by peer”라는 메세지를 클라이언트에 반환
